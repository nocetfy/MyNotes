export const data = JSON.parse("{\"key\":\"v-78372a2b\",\"path\":\"/leetcode/dp/dp.html\",\"title\":\"动态规划\",\"lang\":\"zh-CN\",\"frontmatter\":{\"description\":\"动态规划 [TOC] 动态规划原理 能用动态规划解决的问题，需要满足三个条件：最优子结构，无后效性和子问题重叠。 最优子结构 具有最优子结构也可能是适合用贪心的方法求解。 注意要确保我们考察了最优解中用到的所有子问题。 证明问题最优解的第一个组成部分是做出一个选择； 对于一个给定问题，在其可能的第一步选择中，假定你已经知道哪种选择才会得到最优解。你现在并不关心这种选择具体是如何得到的，只是假定已经知道了这种选择； 给定可获得的最优解的选择后，确定这次选择会产生哪些子问题，以及如何最好地刻画子问题空间； 证明作为构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解。方法是反证法，考虑加入某个子问题的解不是其自身的最优解，那么就可以从原问题的解中用该子问题的最优解替换掉当前的非最优解，从而得到原问题的一个更优的解，从而与原问题最优解的假设矛盾。\",\"head\":[[\"meta\",{\"property\":\"og:url\",\"content\":\"https://newzone.top/leetcode/dp/dp.html\"}],[\"meta\",{\"property\":\"og:site_name\",\"content\":\"nocetfy\"}],[\"meta\",{\"property\":\"og:title\",\"content\":\"动态规划\"}],[\"meta\",{\"property\":\"og:description\",\"content\":\"动态规划 [TOC] 动态规划原理 能用动态规划解决的问题，需要满足三个条件：最优子结构，无后效性和子问题重叠。 最优子结构 具有最优子结构也可能是适合用贪心的方法求解。 注意要确保我们考察了最优解中用到的所有子问题。 证明问题最优解的第一个组成部分是做出一个选择； 对于一个给定问题，在其可能的第一步选择中，假定你已经知道哪种选择才会得到最优解。你现在并不关心这种选择具体是如何得到的，只是假定已经知道了这种选择； 给定可获得的最优解的选择后，确定这次选择会产生哪些子问题，以及如何最好地刻画子问题空间； 证明作为构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解。方法是反证法，考虑加入某个子问题的解不是其自身的最优解，那么就可以从原问题的解中用该子问题的最优解替换掉当前的非最优解，从而得到原问题的一个更优的解，从而与原问题最优解的假设矛盾。\"}],[\"meta\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"meta\",{\"property\":\"og:locale\",\"content\":\"zh-CN\"}],[\"script\",{\"type\":\"application/ld+json\"},\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"Article\\\",\\\"headline\\\":\\\"动态规划\\\",\\\"image\\\":[\\\"\\\"],\\\"dateModified\\\":null,\\\"author\\\":[]}\"]]},\"headers\":[{\"level\":2,\"title\":\"动态规划原理\",\"slug\":\"动态规划原理\",\"link\":\"#动态规划原理\",\"children\":[{\"level\":3,\"title\":\"最优子结构\",\"slug\":\"最优子结构\",\"link\":\"#最优子结构\",\"children\":[]},{\"level\":3,\"title\":\"无后效性\",\"slug\":\"无后效性\",\"link\":\"#无后效性\",\"children\":[]},{\"level\":3,\"title\":\"子问题重叠\",\"slug\":\"子问题重叠\",\"link\":\"#子问题重叠\",\"children\":[]},{\"level\":3,\"title\":\"基本思路\",\"slug\":\"基本思路\",\"link\":\"#基本思路\",\"children\":[]}]},{\"level\":2,\"title\":\"动态规划的解题步骤\",\"slug\":\"动态规划的解题步骤\",\"link\":\"#动态规划的解题步骤\",\"children\":[]},{\"level\":2,\"title\":\"动态规划应该如何 debug\",\"slug\":\"动态规划应该如何-debug\",\"link\":\"#动态规划应该如何-debug\",\"children\":[]},{\"level\":2,\"title\":\"基础问题\",\"slug\":\"基础问题\",\"link\":\"#基础问题\",\"children\":[]},{\"level\":2,\"title\":\"路径问题\",\"slug\":\"路径问题\",\"link\":\"#路径问题\",\"children\":[]},{\"level\":2,\"title\":\"记忆化搜索\",\"slug\":\"记忆化搜索\",\"link\":\"#记忆化搜索\",\"children\":[]},{\"level\":2,\"title\":\"线性dp\",\"slug\":\"线性dp\",\"link\":\"#线性dp\",\"children\":[]},{\"level\":2,\"title\":\"区间dp\",\"slug\":\"区间dp\",\"link\":\"#区间dp\",\"children\":[]},{\"level\":2,\"title\":\"背包dp\",\"slug\":\"背包dp\",\"link\":\"#背包dp\",\"children\":[{\"level\":3,\"title\":\"01 背包\",\"slug\":\"_01-背包\",\"link\":\"#_01-背包\",\"children\":[]},{\"level\":3,\"title\":\"滚动数组\",\"slug\":\"滚动数组\",\"link\":\"#滚动数组\",\"children\":[]},{\"level\":3,\"title\":\"完全背包\",\"slug\":\"完全背包\",\"link\":\"#完全背包\",\"children\":[]},{\"level\":3,\"title\":\"多重背包\",\"slug\":\"多重背包\",\"link\":\"#多重背包\",\"children\":[]}]},{\"level\":2,\"title\":\"序列dp\",\"slug\":\"序列dp\",\"link\":\"#序列dp\",\"children\":[]},{\"level\":2,\"title\":\"状压dp\",\"slug\":\"状压dp\",\"link\":\"#状压dp\",\"children\":[]},{\"level\":2,\"title\":\"状态机dp\",\"slug\":\"状态机dp\",\"link\":\"#状态机dp\",\"children\":[]},{\"level\":2,\"title\":\"数位dp\",\"slug\":\"数位dp\",\"link\":\"#数位dp\",\"children\":[]},{\"level\":2,\"title\":\"树形dp\",\"slug\":\"树形dp\",\"link\":\"#树形dp\",\"children\":[]},{\"level\":2,\"title\":\"打家截舍\",\"slug\":\"打家截舍\",\"link\":\"#打家截舍\",\"children\":[]},{\"level\":2,\"title\":\"股票问题\",\"slug\":\"股票问题\",\"link\":\"#股票问题\",\"children\":[{\"level\":3,\"title\":\"股票问题通解\",\"slug\":\"股票问题通解\",\"link\":\"#股票问题通解\",\"children\":[]}]}],\"git\":{\"createdTime\":null,\"updatedTime\":null,\"contributors\":[]},\"readingTime\":{\"minutes\":132.4,\"words\":39719},\"filePathRelative\":\"leetcode/dp/dp.md\",\"excerpt\":\"<h1> 动态规划</h1>\\n<p>[TOC]</p>\\n<h2> 动态规划原理</h2>\\n<p>能用动态规划解决的问题，需要满足三个条件：最优子结构，无后效性和子问题重叠。</p>\\n<h3> 最优子结构</h3>\\n<p>具有最优子结构也可能是适合用贪心的方法求解。</p>\\n<p>注意要确保我们考察了最优解中用到的所有子问题。</p>\\n<ol>\\n<li>证明问题最优解的第一个组成部分是做出一个选择；</li>\\n<li>对于一个给定问题，在其可能的第一步选择中，假定你已经知道哪种选择才会得到最优解。你现在并不关心这种选择具体是如何得到的，只是假定已经知道了这种选择；</li>\\n<li>给定可获得的最优解的选择后，确定这次选择会产生哪些子问题，以及如何最好地刻画子问题空间；</li>\\n<li>证明作为构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解。方法是反证法，考虑加入某个子问题的解不是其自身的最优解，那么就可以从原问题的解中用该子问题的最优解替换掉当前的非最优解，从而得到原问题的一个更优的解，从而与原问题最优解的假设矛盾。</li>\\n</ol>\",\"autoDesc\":true}")

if (import.meta.webpackHot) {
  import.meta.webpackHot.accept()
  if (__VUE_HMR_RUNTIME__.updatePageData) {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  }
}

if (import.meta.hot) {
  import.meta.hot.accept(({ data }) => {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  })
}
