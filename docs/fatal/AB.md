## 两种方法的题目

> 综合对比，哪种方法更优

#### [456. 132 模式](https://leetcode.cn/problems/132-pattern/)

> 方法1：枚举最小的数，利用单调递减栈来同时维护最大的数和次大的数

> 方法2：枚举最大的数，利用前缀分解，使用单调栈维护第2大数的单调递减栈

方法1更优，一般都是枚举中间数更好想，可以简化思考空间，变成规模更小的思考问题

#### [853. 车队](https://leetcode.cn/problems/car-fleet/)

> 方法1：计算出无限制下每个车的到达时间，然后利用单调递减栈，从前往后遍历位置，当遇到时间更长的车时，说明前面的车会被他拖慢，出栈，他们是同一个车队，最终栈内元素的大小就是车队的数量

> 方法2：计算出无限制下每个车的到达时间，然后利用单调递减栈，从后往前遍历位置，栈空或时间比栈顶更久时，元素入栈，时间比栈顶更短时，说明和栈顶元素一个车队，不做操作，最终栈内元素的大小就是车队的数量

方法1更优，从前往后，维护栈，更符合单调栈的操作习惯，思维难度更低

#### [3419. 图的最大边权的最小值](https://leetcode.cn/problems/minimize-the-maximum-edge-weight-of-graph/)

> 方法1: 二分答案，标准的最小化最大值，对值域范围进行二分，判断是否可行

> 方法2: dijkstra，逆向思维，可以从 0 出发，每次走当前能访问到的边中，边权最小的边，这类似 Dijkstra 求最短路。
>
> 本题是计算路径边权最大值，把 Dijkstra 算法中的 + 改成 max 即可。
>

方法2更优，更符合图论的思维方式，而且通过堆时间复杂度稍优

#### [1235. 规划兼职工作](https://leetcode.cn/problems/maximum-profit-in-job-scheduling/)

> 方法1：二分优化DP，类似打家劫舍的思想，从后往前思考，选了一段工作后，二分找前面能选的工作时间右区间

> 方法2: 利用TreeMap消除裸二分和dp数组，利用其有序的性质

方法2优，优雅，利用自带API的性质，更易理解

#### [2271. 毯子覆盖的最多白色砖块数](https://leetcode.cn/problems/maximum-white-tiles-covered-by-a-carpet/)

> 方法1: 复杂的滑动窗口，先将右端点对齐，然后找覆盖不到的范围，将覆盖不到的砖出窗口

> 方法2: 利用TreeMap的性质，来辅助滑动窗口

方法1更优，容易理解，变量清晰

#### [2909. 元素和最小的山形三元组 II](https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-ii/)

> 方法1: 利用TreeMap来维护后缀的最小值，数组来维护前缀的最小值，遍历当前元素，当满足条件时，计算答案

> 方法2: 前后缀分解，直接计算前后缀的最小值，遍历当前元素做为峰

方法2更优，空间相同的情况下，避免对TreeMap的移除操作。

#### [2559. 统计范围内的元音字符串数](https://leetcode.cn/problems/count-vowel-strings-in-ranges/)

> 方法1: 利用前缀和直接统计有多少满足条件的数，最后即转化为求子数组的和，利用前缀和求解即可

> 方法2: 利用TreeSet统计，然后统计subSet中元素的个数

方法1更优，利用前缀和，时间复杂度更低，直接转化为了O(n)

#### [2516. 每种字符至少取 K 个](https://leetcode.cn/problems/take-k-of-each-character-from-left-and-right/)

> 方法1: 滑动窗口，正难则反，统计窗口内的元素，出窗的条件可以转化为正向的三个元素的k的个数

> 方法2: 滑动窗口，正向解决，直接统计窗口内的元素

方法1更优，写起来方便，时间复杂度相同的情况下更简短

#### [1658. 将 x 减到 0 的最小操作数](https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/)

> 方法1: 滑动窗口，正难则反，统计窗口内的元素，出窗的条件可以转化为一个target

> 方法2: 直接统计，通过类似单调栈的思想解决

方法1更优，时间复杂度更低，实现更优雅

#### [2276. 统计区间中的整数数目](https://leetcode.cn/problems/count-integers-in-intervals/)

> 方法1: 利用TreeMap合并区间，添加区间时，用右端点找到地板区间，如果地板区间能和当前区间合并，则循环进行区间合并，同时维护数的个数

> 方法2: 区间更新，单点计算，使用线段树来维护

方法1更优，线段树更通用，但用在本题大材小用，方法1来实现更优雅，且时间更快。

#### [2134. 最少交换次数来组合所有的 1 II](https://leetcode.cn/problems/minimum-swaps-to-group-all-1s-together-ii/)

> 方法1: 直接进行统计，需要O(n^2)的时间复杂度

> 方法2: 环形数组问题，遍历数组的长度转化为数组加上窗口长度，预先统计窗口内1的个数，当左端点为1时，减个数，右端点为1时加个数，使用滑动窗口解决

方法2更优，利用滑动窗口减少了时间复杂度

#### [1888. 使二进制字符串字符交替的最少反转次数](https://leetcode.cn/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/)

> 方法1: 直接进行统计，需要O(n^2)的时间复杂度

> 方法2: 环形数组问题，将数组转化为双倍的长度，01和10序列也转化为双倍的长度，然后在其上对n的窗口进行匹配，左出右进，统计两个序列匹配的diff数，取最小值即为答案

方法2更优，利用滑动窗口减少了时间复杂度

#### [2953. 统计完全子字符串](https://leetcode.cn/problems/count-complete-substrings/)

> 方法1: 建一个26个元素的树，在树上进行新增和查找

> 方法2: 滑窗，通过滑窗辅助进行优化，利用数组来降低建树的成本，降低整体的时间复杂度

方法2更优，使用更合理的数据结构，有效的降低时间成本

#### [2156. 查找给定哈希值的子串](https://leetcode.cn/problems/find-substring-with-given-hash-value/)

> 方法1: 滑动窗口，用秦九韶算法计算 s[n-k:] 的哈希值，利用滑窗统计新的哈希值

> 方法2: 字符串哈希，直接进行计算

方法1更优，利用滑窗来降低时间复杂度，减少重复的运算