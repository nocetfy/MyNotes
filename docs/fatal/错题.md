# 错题

#### [3302. 字典序最小的合法序列](https://leetcode.cn/problems/find-the-lexicographically-smallest-valid-sequence/)

> **未想到用双指针解决子序列问题**，掌握不足。

> 子序列：双指针匹配。后缀匹配技巧。使用双指针只需要O(n)的时间复杂度

---

#### [3303. 第一个几乎相等子字符串的下标](https://leetcode.cn/problems/find-the-occurrence-of-first-almost-equal-substring/)

> **超出时间限制**
>
> 原因：时间复杂度过高，需要使用一些算法优化，本题知识点为:**z函数**，不会使用z函数。

> 子串：字符串哈希、KMP、z函数、后缀数组进行匹配
>
> z函数：对于每个后缀，匹配前缀匹配多长。两个串同向
>
> KMP：对于每个前缀，匹配前后缀能匹配多长。两个串对向

> 异同：都是求最小字典序，子序列由于不连续，可以贪心，取到前面的a就不取后面的a，因为两个字母是等效的。子串则不行。所以需要用一些特殊的子串匹配方法，如KMP等

---

#### [三阳开泰](https://ac.nowcoder.com/acm/contest/16832/H)

> 知识点：**数位DP**。对一维还比较熟悉，维度升高后，6维无从下手，本质还是吃的不透

> 六个维度的数位DP。相当于6个维度的limit。每个维度每一数位进行判断。是否满足条件。

```java
// 附1维的模板
class Solution {
    public int countSpecialNumbers(int n) {
        char[] s = Integer.toString(n).toCharArray();
        int[][] memo = new int[s.length][1 << 10];
        for (int[] row : memo) {
            Arrays.fill(row, -1); // -1 表示没有计算过
        }
        return dfs(0, 0, true, false, s, memo);
    }

    private int dfs(int i, int mask, boolean isLimit, boolean isNum, char[] s, int[][] memo) {
        if (i == s.length) {
            return isNum ? 1 : 0; // isNum 为 true 表示得到了一个合法数字
        }
        if (!isLimit && isNum && memo[i][mask] != -1) {
            return memo[i][mask]; // 之前计算过
        }
        int res = 0;
        if (!isNum) { // 可以跳过当前数位
            res = dfs(i + 1, mask, false, false, s, memo);
        }
        // 如果前面填的数字都和 n 的一样，那么这一位至多填数字 s[i]（否则就超过 n 啦）
        int up = isLimit ? s[i] - '0' : 9;
        // 枚举要填入的数字 d
        // 如果前面没有填数字，则必须从 1 开始（因为不能有前导零）
        for (int d = isNum ? 0 : 1; d <= up; d++) {
            if ((mask >> d & 1) == 0) { // d 不在 mask 中，说明之前没有填过 d
                res += dfs(i + 1, mask | (1 << d), isLimit && d == up, true, s, memo);
            }
        }
        if (!isLimit && isNum) {
            memo[i][mask] = res; // 记忆化
        }
        return res;
    }
}
```

---

#### [3311. 构造符合图结构的二维矩阵](https://leetcode.cn/problems/construct-2d-grid-matching-graph-layout/)

> **超出内存限制**：
>
> 原因：使用了死循环，出现bug，没结束循环，不停占用内存，导致超出内存

> 1. 实现的太复杂，写的太长，可以优化
> 2. 找一些更一般的例子，验证一下没bug
> 3. 一步一步来，保证前面的步骤没问题，再继续验证下面的步骤

---

#### [3312. 查询排序后的最大公约数](https://leetcode.cn/problems/sorted-gcd-pair-queries/)

> 没思路，从**值域出发**去思考，统计每个gcd可能的出现次数。
>
> 条件：直接计算的数据量太大，而**值域本身范围不大**的情况，可以考虑从值域去思考

> 1. 从最简单的情况开始推演，gcd是2的情况，可得所有偶数的公约数都有2，再减去最大公约数是2的倍数的情况。得到cnt(2) = C(all_even, 2) - cnt(4) - cnt(6) - ....
> 2. 推广到一般情况，得到cnt(i) = C(k*i, 2) - cnt(2i) - cnt(3i) - ....
> 3. 类似动态规划的递推式，从后往前，先算出大的值，再推算得到小的值。

#### [3321. 计算子数组的 x-sum II](https://leetcode.cn/problems/find-x-sum-of-all-k-long-subarrays-ii/)

> **规定时间没做出来**
>
> 思路正确，代码实现过于复杂。抽象思维，优化代码，注意代码质量与规范，多复用函数。

#### [3316. 从原字符串里进行删除操作的最多次数](https://leetcode.cn/problems/find-maximum-removals-from-source-string/)

> **没思路，动态规划转移方程**
>
> 自以为，没有用科学的方法去分析，一步步推导怎么往下求解

> 动态规划就是尝试策略，本质是暴力，对所有情况进行尝试。
>
> 从后往前思考，想最后一步发生了什么。然后往前推，倒数第2步发生了什么，找到规律，通过递归解决。
>
> 大问题：题目问的就是大问题，抽象进行转化。s[0:i] 和 r[0:j]的最大删除次数
>
> 怎么往小问题转移：通过思考每步之间的差异转化 f(i,j) -> f(i-1,j) ; f(i,j) -> f(i+1,j+1)  
>
> 边界：递归到头时怎么结束 i<0   i< j

> 动态规划有「选或不选」和「枚举选哪个」两种基本思考方式。子序列相邻无关一般是「选或不选」，子序列相邻相关（例如 LIS 问题）一般是「枚举选哪个」。本题属于子序列相邻无关问题，用「选或不选」解决。
>

#### [3320. 统计能获胜的出招序列数](https://leetcode.cn/problems/count-the-number-of-winning-sequences/)

> **没思路，动态规划转移方程**
>
> 同上，自以为，没有用科学的方法去分析，一步步推导怎么往下求解

> 从后往前思考，想最后一步发生了什么。然后往前推，倒数第2步发生了什么，找到规律，通过递归解决。
>
> 大问题：题目问的就是大问题，抽象进行转化。得分之差大于0。本轮得分按题目要求去算
>
> 怎么往小问题转移：通过思考每步之间的差异转化。后一轮的得分之差，减去后一轮的得分，加上ban位限制
>
> 边界：递归到头时怎么结束。三种情况：后面全赢也赢不了。后面全输也输不了。计算到头了

#### [3317. 安排活动的方案数](https://leetcode.cn/problems/find-the-number-of-possible-ways-for-an-event/)

> **没思路，动态规划转移方程**
>
> 同上，自以为，没有用科学的方法去分析，一步步推导怎么往下求解

> y种打分相对独立，剥离开这个点，先思考方案数。
>
> 大问题：一个表演者在不同的节目中表演的方案数。抽象：n个表演者表演x个节目
>
> 小问题：n-1个表演者表演x/x-1个节目
>
> 转移：第n个人演新节目，有x种选择；演老节目，有x-j+1中选择

#### [3326. 使数组非递减的最少除法操作次数](https://leetcode.cn/problems/minimum-division-operations-to-make-array-non-decreasing/)

> **没正确处理打表，贪心递推值转移处理**
>
> 1. 正确估计时间复杂度。判断是否需要打表提前处理。直接计算量级超过1e8，则可通过打表提前缓存优化，否则不需要。本题，最多到√1000000的级别，也就是1000内的质数，量级很小。不需要打表
> 2. 贪心计算时及时更新比较的数字，计算完成后更新，否则比较对象不正确

#### [3327. 判断 DFS 字符串是否是回文串](https://leetcode.cn/problems/check-if-dfs-strings-are-palindromes/)

> **超时，不会题目考察的算法**
>
> 不会manacher算法。还是不够当回事，很多算法都遇到过，放过了。
>
> 当成爱好，多学习了解一下。如字符串哈希、RMQ问题，倍增，线段树、筛法、排列组合计算等等。

#### [91. 解码方法](https://leetcode.cn/problems/decode-ways/)

> **解答错误，思考有遗漏**
>
> 对于特殊的0的情况，没有考虑到可以与前面的数字连起来凑成整数。

#### [1044. 最长重复子串](https://leetcode.cn/problems/longest-duplicate-substring/)

> **解答错误 ，边界case判断问题**
>
> 对边界case判断要更谨慎，仔细构造边界情况，确保测试无误。

#### [3333. 找到初始输入字符串 II](https://leetcode.cn/problems/find-the-original-typed-string-ii/)

> **没思路，正难则反，从反方向思考**
>
> 正着思考很难，或者数据量太大的时候，想一想从反方向去思考，通过总和-反得到正的答案。

#### [3336. 最大公约数相等的子序列数量](https://leetcode.cn/problems/find-the-number-of-subsequences-with-equal-gcd/)

> **动态规划没思路，状态推导方程没推出来**
>
> 强化对状态推导的练习，举一反三，加强思维推导，不要惧怕，理所当然觉得自己做不出来

#### [2601. 质数减法运算](https://leetcode.cn/problems/prime-subtraction-operation/)

> **贪心解答错误，贪心思考方向有误**
>
> 不要因为例子对了，就认为思路没问题，想想哪里可能有错，构造些例子。

#### [3343. 统计平衡排列的数目](https://leetcode.cn/problems/count-number-of-balanced-permutations/)

> **解答错误，数学方法掌握不到位：组合数学，费马小定理，逆元**
>
> 多学习下数学方法，组合数学，费马小定理，逆元等。通过数学方法优化动态规划的结果。继续练习动态规划，多于数学结合。

#### [3347. 执行操作后元素的最高频率 II](https://leetcode.cn/problems/maximum-frequency-of-an-element-after-performing-operations-ii/)

> **时间复杂度高导致超时，换个角度思考**
>
> 直接模拟的角度：每个数可以变成哪个数，再统计出现次数，换个角度想问题，可以变成每个可能出现的数，其最多的出现次数

#### [3352. 统计小于 N 的 K 可约简整数](https://leetcode.cn/problems/count-k-reducible-numbers-less-than-n/)

> **题目涉及映射转换，绕不过来，找到本质进行拆解**
>
> 直击本质，把核心的点进行拆解，一个一个去思考和解决。如本题，可以转化成两个问题，1.通过哪些数可以在k步内变为1   2.这些数的数量怎么求。转化后，就是两个动态规划问题，1个线性DP，1个数位DP。

#### [3348. 最小可整除数位乘积 II](https://leetcode.cn/problems/smallest-divisible-digit-product-ii/)

> **动态规划没思路，可以先用暴力做，再想办法优化**
>
> 可以先用暴力做法尝试，再去找规律，没思路时先不去想一步到位，通过找到规律结合算法知识进行时间上的优化。如本题，先尝试暴力搜索，再看规律，可以发现数位DP的问题，用一个类似的方法去尝试优化。

#### [3357. 最小化相邻元素的最大差值](https://leetcode.cn/problems/minimize-the-maximum-adjacent-element-difference/)

> **学习不透彻，思考不够底层。透彻的学习下贪心的思想**
>
> 透彻的学习下贪心的思想和具体思路，如区间贪心、返回贪心。。。等

#### [630. 课程表 III](https://leetcode.cn/problems/course-schedule-iii/)

> **特殊case检测没考虑到，考虑周全一点**
>
> 第2次了，注意边界情况，仔细构造特殊case，验证答案。

#### [3362. 零数组变换 III](https://leetcode.cn/problems/zero-array-transformation-iii/)

> **贪心没思路，没想到正确的推导。排序的规则没找对**
>
> 从特殊的情况开始推导，一步步找到规律和性质。

#### [3363. 最多可收集的水果数目](https://leetcode.cn/problems/find-the-maximum-number-of-fruits-collected/)

> **动态规划没绕过弯来，加强思维脱敏训练**
>
> 多练习思维，排除干扰项，直击本质。

#### [3367. 移除边之后的权重最大和](https://leetcode.cn/problems/maximize-sum-of-weights-after-edge-removals/)

> **动态规划没思路，加强动态规划练习**
>
> 从特殊到一般，先从最特殊情况思考，找到思路。代入回一般情况，推导出转移方程。

#### [牛群喂食计划](https://www.nowcoder.com/practice/7da784c2befa4c2aaef46e2e37c23aee?tpId=363&tqId=10605844&ru=/exam/oj&qru=/ta/super-company23Year/question-ranking&sourceUrl=%2Fexam%2Foj%3FquestionJobId%3D10%26subTabName%3Donline_coding_page)

> **数据范围考虑不周，有错误**
>
> 注意特殊的情况，如0，可以将特殊情况先排除开，单独进行累计计算，避免对正常算法框架的干扰

#### [奶牛排队](https://www.nowcoder.com/practice/e89a2676a740471cbd4d62d4eba303ad?tpId=363&tqId=10606125&ru=/exam/oj&qru=/ta/super-company23Year/question-ranking&sourceUrl=%2Fexam%2Foj%3Ftab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D196)

> **链表指针使用空指针**
>
> 链表的指针使用要小心，注意空的情况，使用虚拟节点尽可能规避空指针

#### [3399. 字符相同的最短子字符串 II](https://leetcode.cn/problems/smallest-substring-with-identical-characters-ii/)

> **贪心思路不对**
>
> ​	切割没有多余的限制，不需要考虑DP，局部贪心就是全局贪心的最优解。保持每个子串互相独立，不因为修改影响到别的子串，所以如果要求是m，则每隔m个数切一刀。

#### [3395. 唯一中间众数子序列 I](https://leetcode.cn/problems/subsequences-with-a-unique-middle-mode-i/)

> **审题不严，没想到正难则反**
>
> ​	注意审题，注意到不能改变元素的顺序。正着想情况很多，考虑从反方向入口去思考。

#### [948. 令牌放置](https://leetcode.cn/problems/bag-of-tokens/)

> **不严谨，忽略了边界条件**
>
> 必须有得分才可以用分去换能量，没有实现这个条件，注意边界情况。

#### [2874. 有序三元组中的最大值 II](https://leetcode.cn/problems/maximum-value-of-an-ordered-triplet-ii/)

> **贪心思考有误，维护的东西不明确**
>
> 前缀分解出最大值，有限制的最小值，和满足条件下的差值，枚举右，即枚举k，维护左，即nums[i]-nums[j]。因为左侧的都满足，所以需要前置处理出前缀的最大差值。而不是直接用max[i-2]-min[i-1]

#### [3403. 从盒子中找出字典序最大的字符串 I](https://leetcode.cn/problems/find-the-lexicographically-largest-string-from-the-box-i/)

> **超时/超内存，没找到合适和优化和贪心的办法**
>
> 有两种办法可以优化。
>
> 1. 先遍历一遍找到最大的开头字母，则这个字母开头的子串才可以作为答案
>
> 2. 每个字符都做为开头，长度取最大长度(length)，不足则取到末尾

#### [3404. 统计特殊子序列的数目](https://leetcode.cn/problems/count-special-subsequences/)

> **数据公式转化差，判断重复情况考虑不出来**
>
> $a\times c = b\times d$，则$a/b = d/c$，只转到了一半，数学知识运用起来。
>
> 枚举中间数c，则b在枚举的过程中也是固定的，因为如果套两层去枚举a和b，则会出现重复的。每次b会随着c而变化。

#### [456. 132 模式](https://leetcode.cn/problems/132-pattern/)

> **单调栈思想有误，找更大数维护最小栈**
>
> 在利用最大栈找更大的数，导致找不出来，熟练掌握单调栈的思想

#### [3409. 最长相邻绝对差递减子序列](https://leetcode.cn/problems/longest-subsequence-with-decreasing-adjacent-difference/)

> **前缀和优化动态规划，没思路**
>
> 观察性质，利用前缀和进行优化，需要训练综合的动态规划

#### [3413. 收集连续 K 个袋子可以获得的最多硬币数量](https://leetcode.cn/problems/maximum-coins-from-k-consecutive-bags/)

> **滑动窗口滑两次，思维题没思路**
>
> 基础打牢，本题的弱化版本之前就没有弄懂，把前置的知识弄懂，多想能怎么变形

#### [3414. 不重叠区间的最大得分](https://leetcode.cn/problems/maximum-score-of-non-overlapping-intervals/)

> **动态规划+二分查找优化，没有思路**
>
> 观察性质，利用二分进行优化，前置有题目是简单版，一步步弄懂，训练思维综合的动态规划

#### [3420. 统计 K 次操作以内得到非递减子数组的数目](https://leetcode.cn/problems/count-non-decreasing-subarrays-after-k-operations/)

> **综合题目，优化条件没想到，单调栈+单调队列+滑动窗口+树**
>
>
> 综合考虑，重点在于怎么维护滑动窗口出左窗口，可以使用树快速计算出可以返还的操作次数，利用单调队列快速得到右窗口需要进入的操作次数，单调栈辅助建树，得到从头节点的一棵单调树

#### [3425. 最长特殊路径](https://leetcode.cn/problems/longest-special-path/)

> **思维，把滑窗放到树上，没想到**
>
> 训练经典题目树上的做法，归纳总结性质

#### [3426. 所有安放棋子方案的曼哈顿距离](https://leetcode.cn/problems/manhattan-distances-of-all-arrangements-of-pieces/)

> **贡献法，未掌握此算法技巧**
>
> 集中练习，熟练掌握，灵活运用。目前已对贡献法做了集中练习

#### [3430. 最多 K 个元素的子数组的最值之和](https://leetcode.cn/problems/maximum-and-minimum-sums-of-at-most-size-k-subarrays/)

> **同一周的题目，也是贡献法，未掌握此算法技巧**
>
> 集中练习，熟练掌握，灵活运用。目前已对贡献法做了集中练习

#### [3441. 变成好标题的最少代价](https://leetcode.cn/problems/minimum-cost-good-caption/)

> **中位数贪心 + 动态规划，运用不熟练**
>
> 贪心思维与动态规划比较短板，需要加强练习

#### [3444. 使数组包含目标值倍数的最少增量](https://leetcode.cn/problems/minimum-increments-for-target-multiples-in-an-array/)

> **动态规划，运用不熟练**
>
> 动态规划中的状压DP，需要加强练习

#### [3448. 统计可以被最后一个数位整除的子字符串数目](https://leetcode.cn/problems/count-substrings-divisible-by-last-digit/)

> **动态规划，运用不熟练**
>
> 动态规划中的多维DP，需要加强练习

#### [3449. 最大化游戏分数的最小值](https://leetcode.cn/problems/maximize-the-minimum-game-score/)

> **贪心思维，运用不熟练**
>
> 贪心没想到，需要加强练习

#### [3459. 最长 V 形对角线段的长度](https://leetcode.cn/problems/length-of-longest-v-shaped-diagonal-segment/)

> **动态规划，使用记忆化搜索更好写，什么情况使用哪种写法不够了解**
>
> 已归纳总结，当转移方向不好想，比如4个方向都能转移，可以转移成圈时，优先用记忆化搜索

#### [3445. 奇偶频次间的最大差值 II](https://leetcode.cn/problems/maximum-difference-between-even-and-odd-frequency-ii/)

> **数据结构综合运用，没想到**
>
> 综合考虑，需要对于基础知识更熟练，组合运用。

#### [3464. 正方形上的点之间的最大距离](https://leetcode.cn/problems/maximize-the-distance-between-points-on-a-square/)

> **数学或贪心，关键点没思路**
>
> 多学习下数学概念，各种距离之间的关系。练习贪心和思维，掌握方法技巧

#### [3486. 最长特殊路径 II](https://leetcode.cn/problems/longest-special-path-ii/)

> **没思路，树上dp问题解决**
>
> 利用好思维导图，按优先级解决动态规划问题

#### [3490. 统计美丽整数的数目](https://leetcode.cn/problems/count-beautiful-numbers/)

> **数位DP，写法不太会**
>
> 寻找动态规划的本质，掌握各个类型的入手方法

####  [3485. 删除元素后 K 个字符串的最长公共前缀](https://leetcode.cn/problems/longest-common-prefix-of-k-strings-after-removal/)

>**思维/字典树**
>
>字典树需要掌握数据结构。思维法可以不用字典数，加强推导能力

#### [3495. 使数组元素都变为零的最少操作次数](https://leetcode.cn/problems/minimum-operations-to-make-array-elements-zero/)

> **公式推导，需要考虑二进制和位信息**
>
> 当有2的幂次时，优先考虑利用位信息和移位操作，找到位信息和题目的联系。将除法映射为右移，乘法映射为左移

#### [3509. 最大化交错和为 K 的子序列乘积](https://leetcode.cn/problems/maximum-product-of-subsequences-with-an-alternating-sum-equal-to-k/)

> **没正确估计出复杂度，不敢尝试**
>
> 大胆尝试，总比什么都不干好

#### [3510. 移除最小数对使数组有序 II](https://leetcode.cn/problems/minimum-pair-removal-to-sort-array-ii/)

> **被纸老虎吓到了，想的太暴力/太困难，不需要考虑单调，直接排序即可**
>
> 多思考题目的本质问题，如果有显式或者隐式的顺序要求，一定先考虑排序。

#### [3599. 划分数组得到最小 XOR](https://leetcode.cn/problems/partition-array-to-minimize-xor/)

> **异或的性质掌握不到位**
>
> 与运算越与越小，或运算越或越大。异或运算都有可能
