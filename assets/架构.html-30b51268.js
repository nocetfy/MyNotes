import{_ as p,X as o,Y as c,Z as s,a0 as n,a1 as t,$ as e,H as i}from"./framework-1ee2252c.js";const l={},r=e('<h1 id="架构" tabindex="-1"><a class="header-anchor" href="#架构" aria-hidden="true">#</a> 架构</h1><p>[toc]</p><h2 id="缓存" tabindex="-1"><a class="header-anchor" href="#缓存" aria-hidden="true">#</a> 缓存</h2><p>缓存的优势主要有以下几点：</p><ul><li>提升访问性能</li><li>降低网络拥堵</li><li>减轻服务负载</li><li>增强可扩展性</li></ul><p>缺点包括：</p><ul><li>首先，服务系统中引入缓存，会增加系统的复杂度。</li><li>其次，由于缓存相比原始 DB 存储的成本更高，所以系统部署及运行的费用也会更高。</li><li>最后，由于一份数据同时存在缓存和 DB 中，甚至缓存内部也会有多个数据副本，多份数据就会存在一致性问题，同时缓存体系本身也会存在可用性问题和分区的问题。这就需要我们加强对缓存原理、缓存组件以及优秀缓存体系实践的理解，从系统架构之初就对缓存进行良好设计，降低缓存引入的副作用，让缓存体系成为服务系统高效稳定运行的强力基石。</li></ul><hr><h2 id="负载均衡" tabindex="-1"><a class="header-anchor" href="#负载均衡" aria-hidden="true">#</a> 负载均衡</h2><p>负载均衡（Load Balance，简称 LB）是高并发、高可用系统必不可少的关键组件，目标是 <strong>尽力将网络流量平均分发到多个服务器上，以提高系统整体的响应速度和可用性</strong>。</p><p>负载均衡的主要作用如下：</p><ul><li><strong>高并发</strong>：负载均衡通过算法调整负载，尽力均匀的分配应用集群中各节点的工作量，以此提高应用集群的并发处理能力（吞吐量）。</li><li><strong>伸缩性</strong>：添加或减少服务器数量，然后由负载均衡进行分发控制。这使得应用集群具备伸缩性。</li><li><strong>高可用</strong>：负载均衡器可以监控候选服务器，当服务器不可用时，自动跳过，将请求分发给可用的服务器。这使得应用集群具备高可用的特性。</li><li><strong>安全防护</strong>：有些负载均衡软件或硬件提供了安全性功能，如：黑白名单处理、防火墙，防 DDos 攻击等。</li></ul><h3 id="硬件负载均衡" tabindex="-1"><a class="header-anchor" href="#硬件负载均衡" aria-hidden="true">#</a> 硬件负载均衡</h3><p>硬件负载均衡，一般是在定制处理器上运行的独立负载均衡服务器，<strong>价格昂贵，土豪专属</strong>。</p>',14),u=s("strong",null,"主流产品",-1),d={href:"https://f5.com/zh",target:"_blank",rel:"noopener noreferrer"},k={href:"https://www.a10networks.com.cn/",target:"_blank",rel:"noopener noreferrer"},g=e('<p>硬件负载均衡的 <strong>优点</strong>：</p><ul><li><strong>功能强大</strong>：支持全局负载均衡并提供较全面的、复杂的负载均衡算法。</li><li><strong>性能强悍</strong>：硬件负载均衡由于是在专用处理器上运行，因此吞吐量大，可支持单机百万以上的并发。</li><li><strong>安全性高</strong>：往往具备防火墙，防 DDos 攻击等安全功能。</li></ul><p>硬件负载均衡的 <strong>缺点</strong>：</p><ul><li><strong>成本昂贵</strong>：购买和维护硬件负载均衡的成本都很高。</li><li><strong>扩展性差</strong>：当访问量突增时，超过限度不能动态扩容。</li></ul><h3 id="软件负载均衡" tabindex="-1"><a class="header-anchor" href="#软件负载均衡" aria-hidden="true">#</a> 软件负载均衡</h3><h4 id="软件负载均衡-1" tabindex="-1"><a class="header-anchor" href="#软件负载均衡-1" aria-hidden="true">#</a> 软件负载均衡</h4><p>软件负载均衡，<strong>应用最广泛</strong>，无论大公司还是小公司都会使用。</p><p>软件负载均衡从软件层面实现负载均衡，一般可以在任何标准物理设备上运行。</p>',8),h=s("strong",null,"主流产品",-1),m={href:"https://www.nginx.com/",target:"_blank",rel:"noopener noreferrer"},v={href:"http://www.haproxy.org/",target:"_blank",rel:"noopener noreferrer"},b={href:"https://github.com/alibaba/LVS",target:"_blank",rel:"noopener noreferrer"},f={href:"https://github.com/alibaba/LVS",target:"_blank",rel:"noopener noreferrer"},y={href:"http://www.haproxy.org/",target:"_blank",rel:"noopener noreferrer"},w={href:"https://www.nginx.com/",target:"_blank",rel:"noopener noreferrer"},x={href:"http://www.haproxy.org/",target:"_blank",rel:"noopener noreferrer"},q=e(`<p>软件负载均衡的 <strong>优点</strong>：</p><ul><li><strong>扩展性好</strong>：适应动态变化，可以通过添加软件负载均衡实例，动态扩展到超出初始容量的能力。</li><li><strong>成本低廉</strong>：软件负载均衡可以在任何标准物理设备上运行，降低了购买和运维的成本。</li></ul><p>软件负载均衡的 <strong>缺点</strong>：</p><ul><li><strong>性能略差</strong>：相比于硬件负载均衡，软件负载均衡的性能要略低一些。</li></ul><h3 id="算法" tabindex="-1"><a class="header-anchor" href="#算法" aria-hidden="true">#</a> 算法</h3><h4 id="随机算法" tabindex="-1"><a class="header-anchor" href="#随机算法" aria-hidden="true">#</a> 随机算法</h4><p><strong><code>随机（Random）</code></strong> 算法 <strong>将请求随机分发到候选服务器</strong>。</p><p>随机算法 <strong>适合服务器硬件相同的场景</strong>。学习过概率论的都知道，调用量较小的时候，可能负载并不均匀，<strong>调用量越大，负载越均衡</strong>。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/20210415165323.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="加权随机算法" tabindex="-1"><a class="header-anchor" href="#加权随机算法" aria-hidden="true">#</a> 加权随机算法</h4><p><strong><code>加权随机（Weighted Random）</code></strong> 算法在随机算法的基础上，按照概率调整权重，进行负载分配。</p><h4 id="轮询算法" tabindex="-1"><a class="header-anchor" href="#轮询算法" aria-hidden="true">#</a> 轮询算法</h4><p><strong><code>轮询（Round Robin）</code></strong> 算法的策略是：<strong>将请求依次分发到候选服务器</strong>。</p><p>如下图所示，负载均衡器收到来自客户端的 6 个请求，(1, 3, 5) 的请求会被发送到服务器 1，(2, 4, 6) 的请求会被发送到服务器 2。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210415164758.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>该算法适合场景：各服务器处理能力相近，且每个事务工作量差异不大。如果存在较大差异，那么处理较慢的服务器就可能会积压请求，最终无法承担过大的负载。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/20210415165041.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="加权轮询算法" tabindex="-1"><a class="header-anchor" href="#加权轮询算法" aria-hidden="true">#</a> 加权轮询算法</h4><p><strong><code>加权轮询（Weighted Round Robbin）</code></strong> 算法在轮询算法的基础上，增加了权重属性来调节转发服务器的请求数目。性能高、处理速度快的节点应该设置更高的权重，使得分发时优先将请求分发到权重较高的节点上。</p><p>如下图所示，服务器 A 设置权重为 5，服务器 B 设置权重为 1，负载均衡器收到来自客户端的 6 个请求，那么 (1, 2, 3, 4, 5) 请求会被发送到服务器 A，(6) 请求会被发送到服务器 B。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/20210415165140.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="最小活跃数" tabindex="-1"><a class="header-anchor" href="#最小活跃数" aria-hidden="true">#</a> 最小活跃数</h3><p><strong><code>最小活跃数（Least Active）</code></strong> 算法 <strong>将请求分发到连接数/请求数最少的候选服务器</strong>（目前处理请求最少的服务器）。</p><ul><li>特点：根据候选服务器当前的请求连接数，动态分配。</li><li>场景：<strong>适用于对系统负载较为敏感或请求连接时长相差较大的场景</strong>。</li></ul><p>由于每个请求的连接时长不一样，如果采用简单的轮循或随机算法，都可能出现<strong>某些服务器当前连接数过大，而另一些服务器的连接过小</strong>的情况，这就造成了负载并非真正均衡。虽然，轮询或算法都可以通过加权重属性的方式进行负载调整，但加权方式难以应对动态变化。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/20210415171432.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>最小活跃数算法会记录当前时刻，每个候选节点正在处理的连接数，然后选择连接数最小的节点。该策略能够动态、实时地反应服务器的当前状况，较为合理地将负责分配均匀，适用于对当前系统负载较为敏感的场景。</p><p>例如下图中，服务器 1 当前连接数最小，那么新到来的请求 6 就会被发送到服务器 1 上。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/20210415165935.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><code>加权最小活跃数(Weighted Least Connection)</code>在最小活跃数的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数。</p><p>​ 最小活跃数算法实现要点：活跃调用数越小，表明该服务节点处理能力越高，单位时间内可处理更多的请求，应优先将请求分发给该服务。在具体实现中，每个服务节点对应一个活跃数 active。初始情况下，所有服务提供者活跃数均为 0。每收到一个请求，活跃数加 1，完成请求后则将活跃数减 1。在服务运行一段时间后，性能好的服务提供者处理请求的速度更快，因此活跃数下降的也越快，此时这样的服务提供者能够优先获取到新的服务请求、这就是最小活跃数负载均衡算法的基本思想。</p><h3 id="最小活跃数-1" tabindex="-1"><a class="header-anchor" href="#最小活跃数-1" aria-hidden="true">#</a> 最小活跃数</h3><p><strong><code>最小活跃数（Least Active）</code></strong> 算法 <strong>将请求分发到连接数/请求数最少的候选服务器</strong>（目前处理请求最少的服务器）。</p><ul><li>特点：根据候选服务器当前的请求连接数，动态分配。</li><li>场景：<strong>适用于对系统负载较为敏感或请求连接时长相差较大的场景</strong>。</li></ul><p>由于每个请求的连接时长不一样，如果采用简单的轮循或随机算法，都可能出现<strong>某些服务器当前连接数过大，而另一些服务器的连接过小</strong>的情况，这就造成了负载并非真正均衡。虽然，轮询或算法都可以通过加权重属性的方式进行负载调整，但加权方式难以应对动态变化。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/20210415171432-20230304202539205.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>最小活跃数算法会记录当前时刻，每个候选节点正在处理的连接数，然后选择连接数最小的节点。该策略能够动态、实时地反应服务器的当前状况，较为合理地将负责分配均匀，适用于对当前系统负载较为敏感的场景。</p><p>例如下图中，服务器 1 当前连接数最小，那么新到来的请求 6 就会被发送到服务器 1 上。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/20210415165935-20230304202539286.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><code>加权最小活跃数(Weighted Least Connection)</code>在最小活跃数的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数。</p><p>​ 最小活跃数算法实现要点：活跃调用数越小，表明该服务节点处理能力越高，单位时间内可处理更多的请求，应优先将请求分发给该服务。在具体实现中，每个服务节点对应一个活跃数 active。初始情况下，所有服务提供者活跃数均为 0。每收到一个请求，活跃数加 1，完成请求后则将活跃数减 1。在服务运行一段时间后，性能好的服务提供者处理请求的速度更快，因此活跃数下降的也越快，此时这样的服务提供者能够优先获取到新的服务请求、这就是最小活跃数负载均衡算法的基本思想。</p><h3 id="哈希" tabindex="-1"><a class="header-anchor" href="#哈希" aria-hidden="true">#</a> 哈希</h3><p><strong><code>哈希（Hash）</code></strong> 算法<strong>根据一个 key （可以是唯一 ID、IP 等），通过哈希计算得到一个数值，用该数值在候选服务器列表的进行取模运算，得到的结果便是选中的服务器</strong>。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/20210415172716-20230304202628925.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可以保证同一 IP 的客户端的请求会转发到同一台服务器上，用来实现会话粘滞（Sticky Session）。</p><ul><li>特点：保证特定用户总是请求到相同的服务器，若服务器宕机，会话会丢失。</li></ul><hr><h3 id="一致性哈希" tabindex="-1"><a class="header-anchor" href="#一致性哈希" aria-hidden="true">#</a> 一致性哈希</h3><p><strong><code>一致性哈希（Consistent Hash）</code></strong> 算法的目标是：<strong>相同的请求尽可能落到同一个服务器上</strong>。</p><p><strong>一致性哈希</strong> 可以很好的解决 <strong>稳定性问题</strong>，可以将所有的存储节点排列在首尾相接的 <code>Hash</code> 环上，每个 <code>key</code> 在计算 <code>Hash</code> 后会 <strong>顺时针</strong> 找到 <strong>邻接</strong> 的存储节点存放。而当有节点 <strong>加入</strong> 或 <strong>退出</strong> 时，仅影响该节点在 <code>Hash</code> 环上 <strong>顺时针相邻</strong> 的 <strong>后续节点</strong>。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/partition-consistent-hash.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><strong>相同的请求</strong>是指：一般在使用一致性哈希时，需要指定一个 key 用于 hash 计算，可能是：用户 ID、请求方 IP、请求服务名称，参数列表构成的串</li><li><strong>尽可能</strong>是指：服务器可能发生上下线，少数服务器的变化不应该影响大多数的请求。</li></ul><p>当某台候选服务器宕机时，原本发往该服务器的请求，会基于虚拟节点，平摊到其它候选服务器，不会引起剧烈变动。</p><ul><li><strong>优点</strong></li></ul><p><strong>加入</strong> 和 <strong>删除</strong> 节点只影响 <strong>哈希环</strong> 中 <strong>顺时针方向</strong> 的 <strong>相邻的节点</strong>，对其他节点无影响。</p><ul><li><strong>缺点</strong></li></ul><p><strong>加减节点</strong> 会造成 <strong>哈希环</strong> 中部分数据 <strong>无法命中</strong>。当使用 <strong>少量节点</strong> 时，<strong>节点变化</strong> 将大范围影响 <strong>哈希环</strong> 中 <strong>数据映射</strong>，不适合 <strong>少量数据节点</strong> 的分布式方案。<strong>普通</strong> 的 <strong>一致性哈希分区</strong> 在增减节点时需要 <strong>增加一倍</strong> 或 <strong>减去一半</strong> 节点才能保证 <strong>数据</strong> 和 <strong>负载的均衡</strong>。</p><blockquote><p><strong>注意</strong>：因为 <strong>一致性哈希分区</strong> 的这些缺点，一些分布式系统采用 <strong>虚拟槽</strong> 对 <strong>一致性哈希</strong> 进行改进，比如 <code>Dynamo</code> 系统、Redis。</p></blockquote><h4 id="hash环的数据倾斜问题" tabindex="-1"><a class="header-anchor" href="#hash环的数据倾斜问题" aria-hidden="true">#</a> Hash环的数据倾斜问题</h4><p>一致性哈希虽然为我们提供了稳定的切换策略，但是它也有一些小缺陷。因为 hash取模算法得到的结果是随机的，我们并不能保证各个服务节点能均匀的分配到哈希环上。</p><p>例如当有4个服务节点时，我们把哈希环认为是一个圆盘时钟，我们并不能保证4个服务节点刚好均匀的落在时钟的 12、3、6、9点上。</p><p>分布不均匀就会产生一个问题，用户的请求访问就会不均匀，同时4个服务承受的压力就会不均匀。这种问题现象我们称之为，<strong>Hash环的数据倾斜问题</strong>。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/image-20230304203032912.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如果想要均衡的将缓存分布到每台服务器上，最好能让这每台服务器尽量多的、均匀的出现在hash环上，但是如上图中所示，真实的服务器资源只有4台，我们怎样凭空的让它们多起来呢？</p><p>既然没有多余的真正的物理服务器节点，我们就只能将现有的物理节点通过虚拟的方法复制出来。</p><p>这些由实际节点虚拟复制而来的节点被称为 <strong>&quot;虚拟节点&quot;</strong>，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在服务器IP或主机名的后面增加编号来实现。</p><p>如上图所示，假如 服务器1 的 IP 是 <code>192.168.32.132</code>，那么原 服务器1 节点在环形空间的位置就是<code>hash(&quot;192.168.32.132&quot;) % 2^32</code>。</p><p>我们基于 服务器1 构建两个虚拟节点，Server1-A 和 Server1-B，虚拟节点在环形空间的位置可以利用（IP+后缀）计算，例如：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>hash<span class="token punctuation">(</span><span class="token string">&quot;192.168.32.132#A&quot;</span><span class="token punctuation">)</span> % <span class="token number">2</span>^32
hash<span class="token punctuation">(</span><span class="token string">&quot;192.168.32.132#B&quot;</span><span class="token punctuation">)</span> % <span class="token number">2</span>^32
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>此时，环形空间中不再有物理节点 服务器1，服务器2，……，替代的是只有虚拟节点 Server1-A，Server1-B，Server2-A，Server2-B，……。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/image-20230304203148834.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>​ 同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到 “Server1-A”、“Server1-B” 两个虚拟节点的数据均定位到 服务器1上。这样就解决了服务节点少时数据倾斜的问题。</p><h4 id="实现" tabindex="-1"><a class="header-anchor" href="#实现" aria-hidden="true">#</a> 实现</h4><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 不带虚拟节点的一致性Hash算法
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConsistentHashingWithoutVirtualNode</span> <span class="token punctuation">{</span>
    <span class="token doc-comment comment">/**
     * 待添加入Hash环的服务器列表
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> servers <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;192.168.0.0:111&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;192.168.0.1:111&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;192.168.0.2:111&quot;</span><span class="token punctuation">,</span>
            <span class="token string">&quot;192.168.0.3:111&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;192.168.0.4:111&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token doc-comment comment">/**
     * key表示服务器的hash值，value表示服务器的名称
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> treeMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/*
     * 程序初始化，将所有的服务器放入sortedMap中
     */</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> server <span class="token operator">:</span> servers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">getHash</span><span class="token punctuation">(</span>server<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;[&quot;</span> <span class="token operator">+</span> server <span class="token operator">+</span> <span class="token string">&quot;]加入集合中, 其Hash值为&quot;</span> <span class="token operator">+</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
            treeMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> server<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token doc-comment comment">/**
     * 使用FNV1_32_HASH算法计算服务器的Hash值,这里不使用重写hashCode的方法，最终效果没区别
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getHash</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">final</span> <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">16777619</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token number">2166136261L</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            hash <span class="token operator">=</span> <span class="token punctuation">(</span>hash <span class="token operator">^</span> str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> p<span class="token punctuation">;</span>
        hash <span class="token operator">+=</span> hash <span class="token operator">&lt;&lt;</span> <span class="token number">13</span><span class="token punctuation">;</span>
        hash <span class="token operator">^=</span> hash <span class="token operator">&gt;&gt;</span> <span class="token number">7</span><span class="token punctuation">;</span>
        hash <span class="token operator">+=</span> hash <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span>
        hash <span class="token operator">^=</span> hash <span class="token operator">&gt;&gt;</span> <span class="token number">17</span><span class="token punctuation">;</span>
        hash <span class="token operator">+=</span> hash <span class="token operator">&lt;&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span>

        <span class="token comment">// 如果算出来的值为负数则取其绝对值</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>hash <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> hash <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> hash<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token doc-comment comment">/**
     * 得到应当路由到的结点
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">getServer</span><span class="token punctuation">(</span><span class="token class-name">String</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 得到带路由的结点的Hash值</span>
        <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">getHash</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 得到大于该Hash值的第一个</span>
        <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> entry <span class="token operator">=</span> treeMap<span class="token punctuation">.</span><span class="token function">ceilingEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">isNull</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span> <span class="token operator">?</span> treeMap<span class="token punctuation">.</span><span class="token function">firstEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nodes <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;127.0.0.1:1111&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;221.226.0.1:2222&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;10.211.0.1:3333&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> node <span class="token operator">:</span> nodes<span class="token punctuation">)</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;[&quot;</span> <span class="token operator">+</span> node <span class="token operator">+</span> <span class="token string">&quot;]的hash值为&quot;</span> <span class="token operator">+</span>
                    <span class="token function">getHash</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;, 被路由到结点[&quot;</span> <span class="token operator">+</span> <span class="token function">getServer</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;]&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 带虚拟节点的一致性Hash算法
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConsistentHashingWithVirtualNode</span> <span class="token punctuation">{</span>
    <span class="token doc-comment comment">/**
     * 待添加入Hash环的服务器列表
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> servers <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;192.168.0.0:111&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;192.168.0.1:111&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;192.168.0.2:111&quot;</span><span class="token punctuation">,</span>
            <span class="token string">&quot;192.168.0.3:111&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;192.168.0.4:111&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token doc-comment comment">/**
     * 真实结点列表
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> realNodes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token doc-comment comment">/**
     * 虚拟节点，key表示虚拟节点的hash值，value表示虚拟节点的名称
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> virtualNodes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token doc-comment comment">/**
     * 虚拟节点的数目，这里写死，为了演示需要，一个真实结点对应5个虚拟节点
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">VIRTUAL_NODES</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>

    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token comment">// 先把原始的服务器添加到真实结点列表中</span>
        <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>realNodes<span class="token punctuation">,</span> servers<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 再添加虚拟节点</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> str <span class="token operator">:</span> realNodes<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token constant">VIRTUAL_NODES</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">String</span> virtualNodeName <span class="token operator">=</span> str <span class="token operator">+</span> <span class="token string">&quot;&amp;&amp;VN&quot;</span> <span class="token operator">+</span> i<span class="token punctuation">;</span>
                <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">getHash</span><span class="token punctuation">(</span>virtualNodeName<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;虚拟节点[&quot;</span> <span class="token operator">+</span> virtualNodeName <span class="token operator">+</span> <span class="token string">&quot;]被添加, hash值为&quot;</span> <span class="token operator">+</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
                virtualNodes<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> virtualNodeName<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token doc-comment comment">/**
     * 使用FNV1_32_HASH算法计算服务器的Hash值,这里不使用重写hashCode的方法，最终效果没区别
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getHash</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">final</span> <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">16777619</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token number">2166136261L</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            hash <span class="token operator">=</span> <span class="token punctuation">(</span>hash <span class="token operator">^</span> str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> p<span class="token punctuation">;</span>
        hash <span class="token operator">+=</span> hash <span class="token operator">&lt;&lt;</span> <span class="token number">13</span><span class="token punctuation">;</span>
        hash <span class="token operator">^=</span> hash <span class="token operator">&gt;&gt;</span> <span class="token number">7</span><span class="token punctuation">;</span>
        hash <span class="token operator">+=</span> hash <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span>
        hash <span class="token operator">^=</span> hash <span class="token operator">&gt;&gt;</span> <span class="token number">17</span><span class="token punctuation">;</span>
        hash <span class="token operator">+=</span> hash <span class="token operator">&lt;&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span>

        <span class="token comment">// 如果算出来的值为负数则取其绝对值</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>hash <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> hash <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> hash<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token doc-comment comment">/**
     * 得到应当路由到的结点
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">getServer</span><span class="token punctuation">(</span><span class="token class-name">String</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 得到带路由的结点的Hash值</span>
        <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">getHash</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 得到大于该Hash值第一个节点</span>
        <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> entry <span class="token operator">=</span> virtualNodes<span class="token punctuation">.</span><span class="token function">floorEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> virtualNode <span class="token operator">=</span> entry <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> virtualNodes<span class="token punctuation">.</span><span class="token function">firstEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> virtualNode<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> virtualNode<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">&quot;&amp;&amp;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nodes <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;127.0.0.1:1111&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;221.226.0.1:2222&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;10.211.0.1:3333&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> node <span class="token operator">:</span> nodes<span class="token punctuation">)</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;[&quot;</span> <span class="token operator">+</span> node <span class="token operator">+</span> <span class="token string">&quot;]的hash值为&quot;</span> <span class="token operator">+</span>
                    <span class="token function">getHash</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;, 被路由到结点[&quot;</span> <span class="token operator">+</span> <span class="token function">getServer</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;]&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="限流" tabindex="-1"><a class="header-anchor" href="#限流" aria-hidden="true">#</a> 限流</h2><p>​ 在高并发场景下，为了应对瞬时海量请求的压力，保障系统的平稳运行，必须预估系统的流量阈值，通过限流规则阻断处理不过来的请求。限流可以认为是服务降级的一种。限流就是<strong>限制系统的输入和输出流量已达到保护系统的目的</strong>。一般来说系统的吞吐量是可以被测算的，为了保证系统的稳定运行，一旦达到需要限制的阈值，就需要限制流量并采取一些措施以完成限制流量的目的。比如：延迟处理，拒绝处理，或者部分拒绝处理等等。</p><p>限流规则包含三个部分：时间粒度，接口粒度，最大限流值。限流规则设置是否合理直接影响到限流是否合理有效。</p><h3 id="计数器算法" tabindex="-1"><a class="header-anchor" href="#计数器算法" aria-hidden="true">#</a> 计数器算法</h3><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/20210625174706.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>计数器法的<strong>原理</strong>是：设置一个计数器，用于统计指定时间段内的请求数量，并在指定时间段之后重置计数器。在这个过程中，如果请求量超过限定的阈值，则拒绝请求。</p><p>这种算法的缺陷是：这种算法是针对一个时间段进行统计，如果请求分布不均匀，极端情况下，<strong>所有请求都在某一刻收到，还是可能压垮系统</strong>。</p><h3 id="滑动窗口" tabindex="-1"><a class="header-anchor" href="#滑动窗口" aria-hidden="true">#</a> 滑动窗口</h3><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/20210625180432.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>​ 滑动窗口法是计数器算法的一种改进，<strong>增加一个时间粒度的度量单位，将原来的一个时间窗口划分成多个时间窗口，并且不断向右滑动该窗口</strong>。流量经过滑动时间窗口算法整形之后，可以保证任意时间窗口内，都不会超过最大允许的限流值，从流量曲线上来看会更加平滑，可以部分解决上面提到的临界突发流量问题。</p><p>​ 对比固定时间窗口限流算法，滑动时间窗口限流算法的时间窗口是持续滑动的，并且除了需要一个计数器来记录时间窗口内接口请求次数之外，还需要记录在时间窗口内每个接口请求到达的时间点，对内存的占用会比较多。 在临界位置的突发请求都会被算到时间窗口内，因此可以解决计数器算法的临界问题。</p><p>滑动窗口法的<strong>缺陷</strong>：基于时间窗口的限流算法，<strong>只能在选定的时间粒度上限流，对选定时间粒度内的更加细粒度的访问频率不做限制</strong>。</p><h3 id="漏桶法" tabindex="-1"><a class="header-anchor" href="#漏桶法" aria-hidden="true">#</a> 漏桶法</h3><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/20210625164126.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>漏桶算法内部有一个容器，当请求进来时，相当于水倒入漏斗，然后从下端小口慢慢匀速的流出。不管上面流量多大，下面流出的速度始终保持不变。</p><p>漏桶算法的本质是，<strong>不管理请求量有多大，处理请求的速度始终是固定的</strong>。这种模式类似生活中的漏斗，上宽下窄。请求进来的速度是未知的，可能突然进来很多请求，没来得及处理的请求就先放在漏斗里。漏斗本身也有容量上限，如果桶满了，那么新进来的请求就丢弃。</p><p>漏桶算法的<strong>优点</strong>是：这种策略的好处是，做到了流量整形，即无论流量多大，即便是突发的大流量，输出依旧是一个稳定的流量。</p><p>漏桶算法的<strong>缺点</strong>是：无法应对短时间的突刺流量。</p><p><strong>漏桶策略适用于间隔性突发流量且流量不用即时处理的场景</strong>。</p><h3 id="令牌桶法" tabindex="-1"><a class="header-anchor" href="#令牌桶法" aria-hidden="true">#</a> 令牌桶法</h3><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/20210625161944.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>令牌桶算法的<strong>原理</strong>：</p><ol><li>接口限制 T 秒内最大访问次数为 N，则每隔 T/N 秒会放一个 token 到桶中</li><li>桶内最多存放 M 个 token，如果 token 到达时令牌桶已经满了，那么这个 token 就会被丢弃</li><li>接口请求会先从令牌桶中取 token，拿到 token 则处理接口请求，拿不到 token 则进行限流处理</li></ol><p>因为令牌桶存放了很多令牌，那么大量的突发请求会被执行，但是它不会出现临界问题，在令牌用完之后，令牌是以一个恒定的速率添加到令牌桶中的，因此不能再次发送大量突发请求。</p><p>规定固定容量的桶，token 以固定速度往桶内填充，当桶满时 token 不会被继续放入，每过来一个请求把 token 从桶中移除,如果桶中没有 token 不能请求。</p><p><strong>令牌桶算法适用于有突发特性的流量，且流量需要即时处理的场景</strong>。</p><blockquote><p>滑动窗口：更适用于<strong>拒绝</strong>场景，如果超限，可直接拒绝。漏桶、令牌桶更使用于阻塞排队，如果超限，可以等待之后处理。</p></blockquote><hr><h2 id="请求合并" tabindex="-1"><a class="header-anchor" href="#请求合并" aria-hidden="true">#</a> 请求合并</h2><p>在高并发系统中，我们经常遇到这样的需求：系统产生大量的请求，但是这些请求实时性要求不高。我们就可以将这些请求合并，达到一定数量我们统一提交。最大化的利用系统性IO,提升系统的吞吐性能。</p><p>所以请求合并框架需要考虑以下两个需求：</p><ol><li>当请求收集到一定数量时提交数据</li><li>一段时间后如果请求没有达到指定的数量也进行提交</li></ol><ul><li><code>hystrix collapser</code>: 需要每个请求的结果，并且不在意每个请求的 cost 会增加。</li><li><code>BatchCollapser</code>: 不在意请求的结果，需要请求合并能在时间和数量两个维度上触发。</li><li><code>ConcurrentHashMultiset</code>：请求重复率很高的统计类场景。</li></ul><hr><h2 id="降级、熔断" tabindex="-1"><a class="header-anchor" href="#降级、熔断" aria-hidden="true">#</a> 降级、熔断</h2><h3 id="熔断" tabindex="-1"><a class="header-anchor" href="#熔断" aria-hidden="true">#</a> 熔断</h3><p>在高可用设计中，也有熔断的技术手段，熔断模式保护的是业务系统不被外部大流量或者下游系统的异常而拖垮。</p><p>通过添加合理的熔断策略，可以防止系统不断地去请求可能超时和失败的下游业务，跳过下游服务的异常场景，防止被拖垮，也就是防止出现服务雪崩的情况。</p><p>熔断策略其实是一种熔断器模式，你可以想象一下家里应用的电路过载保护器，不过熔断器的设计要更复杂，一个设计完善的熔断策略，可以在下游服务异常时关闭调用，在下游服务恢复正常时，逐渐恢复流量。</p><p>熔断器的实现其实是数据结构中有限状态机（Finite-state Machines，FSM）的一种应用，关于 FSM 的具体分析和应用，不是本课时的目标，因为 FSM 不光在算法领域有应用，在复杂系统设计时，为了更好的标识状态流转，用有限状态机来描述会特别清晰。</p><p>熔断器的恢复时间，也就是平均故障恢复时间，称为 MTTR，在稳定性设计中是一个常见的指标，在 Hystrix 的断路器设计中，有以下几个状态。</p><ul><li>Closed：熔断器关闭状态，比如系统检测到下游失败到了 50% 的阈值，会开启熔断。</li><li>Open：熔断器打开状态，此时对下游的调用在内部直接返回错误，不发出请求，但是在一定的时间周期以后，会进入下一个半熔断状态。</li><li>Half-Open：半熔断状态，允许少量的服务请求，如果调用都成功（或一定比例）则认为恢复了，关闭熔断器，否则认为还没好，又回到熔断器打开状态。</li></ul><table><thead><tr><th style="text-align:left;">Sentinel</th><th style="text-align:left;">Hystrix</th><th style="text-align:left;">resilience4j</th><th></th></tr></thead><tbody><tr><td style="text-align:left;">隔离策略</td><td style="text-align:left;">信号量隔离（并发线程数限流）</td><td style="text-align:left;">线程池隔离/信号量隔离</td><td>信号量隔离</td></tr><tr><td style="text-align:left;">熔断降级策略</td><td style="text-align:left;">基于响应时间、异常比率、异常数</td><td style="text-align:left;">基于异常比率</td><td>基于异常比率、响应时间</td></tr><tr><td style="text-align:left;">实时统计实现</td><td style="text-align:left;">滑动窗口（LeapArray）</td><td style="text-align:left;">滑动窗口（基于 RxJava）</td><td>Ring Bit Buffer</td></tr><tr><td style="text-align:left;">动态规则配置</td><td style="text-align:left;">支持多种数据源</td><td style="text-align:left;">支持多种数据源</td><td>有限支持</td></tr><tr><td style="text-align:left;">扩展性</td><td style="text-align:left;">多个扩展点</td><td style="text-align:left;">插件的形式</td><td>接口的形式</td></tr><tr><td style="text-align:left;">基于注解的支持</td><td style="text-align:left;">支持</td><td style="text-align:left;">支持</td><td>支持</td></tr><tr><td style="text-align:left;">限流</td><td style="text-align:left;">基于 QPS，支持基于调用关系的限流</td><td style="text-align:left;">有限的支持</td><td>Rate Limiter</td></tr><tr><td style="text-align:left;">流量整形</td><td style="text-align:left;">支持预热模式、匀速器模式、预热排队模式</td><td style="text-align:left;">不支持</td><td>简单的 Rate Limiter 模式</td></tr><tr><td style="text-align:left;">系统自适应保护</td><td style="text-align:left;">支持</td><td style="text-align:left;">不支持</td><td>不支持</td></tr><tr><td style="text-align:left;">控制台</td><td style="text-align:left;">提供开箱即用的控制台，可配置规则、查看秒级监控、机器发现等</td><td style="text-align:left;">简单的监控查看</td><td>不提供控制台，可对接其他监控系统</td></tr></tbody></table><h3 id="降级" tabindex="-1"><a class="header-anchor" href="#降级" aria-hidden="true">#</a> 降级</h3><p>降级指系统将某些业务或者接口的功能降低，可以是只提供部分功能，也可以是完全停掉所有功能。</p><p>例如，论坛可以降级为只能看帖子，不能发帖子；也可以降级为只能看帖子和评论，不能发评论；而App的日志上传接口，可以完全停掉一段时间，这段时间内App都不能上传日志。</p><p>降级的核心思想就是丢车保帅，优先保证核心业务。</p><p>例如，对于论坛来说，90%的流量是看帖子，那我们就优先保证看帖的功能；对于一个App来说，日志上传接口只是一个辅助的功能，故障时完全可以停掉。</p><p>常见的实现降级的方式有两种：</p><h4 id="系统后门降级" tabindex="-1"><a class="header-anchor" href="#系统后门降级" aria-hidden="true">#</a> 系统后门降级</h4><p>简单来说，就是系统预留了后门用于降级操作。例如，系统提供一个降级URL，当访问这个URL时，就相当于执行降级指令，具体的降级指令通过URL的参数传入即可。这种方案有一定的安全隐患，所以也会在URL中加入密码这类安全措施。</p><p>系统后门降级的方式实现成本低，但主要缺点是如果服务器数量多，需要一台一台去操作，效率比较低，这在故障处理争分夺秒的场景下是比较浪费时间的。</p><h4 id="独立降级系统" tabindex="-1"><a class="header-anchor" href="#独立降级系统" aria-hidden="true">#</a> 独立降级系统</h4><p>为了解决系统后门降级方式的缺点，我们可以将降级操作独立到一个单独的系统中，实现复杂的权限管理、批量操作等功能。</p><p>其基本架构如下：</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/4d162df260470248a4fe8250ae44f469.jpg" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><hr><h2 id="灾备与故障转移" tabindex="-1"><a class="header-anchor" href="#灾备与故障转移" aria-hidden="true">#</a> 灾备与故障转移</h2><h3 id="异地多活" tabindex="-1"><a class="header-anchor" href="#异地多活" aria-hidden="true">#</a> 异地多活</h3><p>切流：某个机房出现问题时，可以快速将流量切到另一个机房去。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/16342320382165.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>分片的核心思路在于，<strong>让同一个用户的相关请求，只在一个机房内完成所有业务「闭环」，不再出现「跨机房」访问</strong>。</p><hr>`,139);function _(S,H){const a=i("ExternalLinkIcon");return o(),c("div",null,[r,s("p",null,[n("硬件负载均衡的 "),u,n(" 有："),s("a",d,[n("F5"),t(a)]),n(" 和 "),s("a",k,[n("A10"),t(a)]),n("。")]),g,s("p",null,[n("软件负载均衡的 "),h,n(" 有："),s("a",m,[n("Nginx"),t(a)]),n("、"),s("a",v,[n("HAProxy"),t(a)]),n("、"),s("a",b,[n("LVS"),t(a)]),n("。")]),s("ul",null,[s("li",null,[s("a",f,[n("LVS"),t(a)]),n(" 可以作为四层负载均衡器。其负载均衡的性能要优于 Nginx。")]),s("li",null,[s("a",y,[n("HAProxy"),t(a)]),n(" 可以作为 HTTP 和 TCP 负载均衡器。")]),s("li",null,[s("a",w,[n("Nginx"),t(a)]),n("、"),s("a",x,[n("HAProxy"),t(a)]),n(" 可以作为四层或七层负载均衡器。")])]),q])}const A=p(l,[["render",_],["__file","架构.html.vue"]]);export{A as default};
