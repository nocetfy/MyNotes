const e=JSON.parse('{"key":"v-4248c02f","path":"/leetcode/tree/trie.html","title":"字典树 前缀树","lang":"zh-CN","frontmatter":{"description":"字典树 前缀树 Trie Trie 树又叫字典查找树。顾名思义，字典查找树，主要解决的就是字符串的查找。有以下两个优势。 查找命中的时间复杂度是 O(k)，k指的是需要查询的 key 的长度。这里注意和字库的大小无关。 对于未命中的字符，只需要查询若干字符就可。 基本数据结构 首先 Trie 树，是一棵树。树是由需要建立的所有词构成。 假设我们有，bee 、sea、 shells，she，sells，几个单词。我们可以使用这几个单词构建一棵树。","head":[["meta",{"property":"og:url","content":"https://newzone.top/MyNotes/leetcode/tree/trie.html"}],["meta",{"property":"og:site_name","content":"nocetfy"}],["meta",{"property":"og:title","content":"字典树 前缀树"}],["meta",{"property":"og:description","content":"字典树 前缀树 Trie Trie 树又叫字典查找树。顾名思义，字典查找树，主要解决的就是字符串的查找。有以下两个优势。 查找命中的时间复杂度是 O(k)，k指的是需要查询的 key 的长度。这里注意和字库的大小无关。 对于未命中的字符，只需要查询若干字符就可。 基本数据结构 首先 Trie 树，是一棵树。树是由需要建立的所有词构成。 假设我们有，bee 、sea、 shells，she，sells，几个单词。我们可以使用这几个单词构建一棵树。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"字典树 前缀树\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[]}"]]},"headers":[{"level":2,"title":"Trie","slug":"trie","link":"#trie","children":[{"level":3,"title":"基本数据结构","slug":"基本数据结构","link":"#基本数据结构","children":[]},{"level":3,"title":"题目","slug":"题目","link":"#题目","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":3.71,"words":1114},"filePathRelative":"leetcode/tree/trie.md","excerpt":"<h1> 字典树 前缀树</h1>\\n<h2> Trie</h2>\\n<p>Trie 树又叫字典查找树。顾名思义，字典查找树，主要解决的就是字符串的查找。有以下两个优势。</p>\\n<ul>\\n<li>查找命中的时间复杂度是 O(k)，k指的是需要查询的 key 的长度。这里注意和字库的大小无关。</li>\\n<li>对于未命中的字符，只需要查询若干字符就可。</li>\\n</ul>\\n<h3> 基本数据结构</h3>\\n<p>首先 Trie 树，是一棵树。树是由需要建立的所有词构成。</p>\\n<p>假设我们有，bee 、sea、 shells，she，sells，几个单词。我们可以使用这几个单词构建一棵树。</p>","autoDesc":true}');export{e as data};
