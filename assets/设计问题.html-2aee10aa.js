const e=JSON.parse('{"key":"v-2d485bdb","path":"/interview/%E5%BC%80%E6%94%BE%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E9%97%AE%E9%A2%98.html","title":"系统设计","lang":"zh-CN","frontmatter":{"description":"系统设计 [toc] 即时消息系统 即时消息系统，但是基本上好多即时通讯软件都属于这一类，比如微信，比如 QQ，比如 Facebook Messenger，比如 WhatsApp。 用户发送消息，直接发给 Chat Service，它会做少量的处理并持久化，然后放到基于 channel 的队列中，每一个对话（thread）都会有一个 channel，这个过程中，它并不关心这个对话有多少人参与（支持群聊）。 队列有两类消费者，一类是 Message Service 用来服务在线用户。由于单台机器和客户端的连接数量有限（比如小于 2^16=65536），因此 Message Service 需要有很多机器，根据用户的 id 来 sharding，它们去订阅自己感兴趣的频道，有新的消息就发送给用户。 Message Service 获取客户端的心跳，保持来自客户端的连接（long polling 或者 socket）为了实时性肯定要用 push 模型。因此它知道用户的当前在线状态，也知道最后一条发送成功消息的时间戳（状态）。这个状态可以用于决定用户离线时消息是否要通过其它方式通知用户。 还有一类是 Notification Service 用来发离线通知。 Chat Service 有两个职责，一个是处理发消息的请求，一个是接纳读取历史消息的请求，这两个功能可以分成两个组件，也可以一个组件，我放在一起了。 右侧的消息数据库，RDB 往往不太适合，因为消息数量太大，对于一组对话（thread）的展示，需要找到该对话 N 条最近的记录，行数据库效率较低，可以考虑列数据库，比如 HBase。这种方式下，同一 thread 下的消息都是按时序存放在一起的，读的效率非常高，写因为基本是 append，也很方便。 用户数据的存储，可以使用 RDB，也可以使用 KV 数据库。 这里面存放的数据库表包括：用户表；对话表；用户对话关联表：二者是 M:N 的关系，并且每个用户都可以有对于特定对话的设置，例如设置对话中的昵称，是否屏蔽消息通知等等。 对于图中基于 Channel 的队列，把数据 fanout 给下游，它有几个作用，一个是解耦，把消息发送和消息接收分离开，消息发送者可能只管把消息发到群里，但是并不关心这个群应该有几个用户得到通知；第二个是缓冲，无论是为离线用户服务的 Notification Service，还是为在线用户服务的 Message Service，它们消费数据的速率是无法确定的。 对于用户上线、下线的实现，其实也类似，上线、下线的事件可以推送到一个特定的 Channel 里面。用户的好友，也就是感兴趣的 Notification Service 的个体去订阅消息；还有一种思路是把状态更新到用户表里面，这样所有人都可以查询得到，这后一种方式适合非好友也要查看用户状态的情况。上、下线需要保留缓冲时间，容许一定状态的延迟，没必要，也不应过于实时。","head":[["meta",{"property":"og:url","content":"https://newzone.top/MyNotes/interview/%E5%BC%80%E6%94%BE%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E9%97%AE%E9%A2%98.html"}],["meta",{"property":"og:site_name","content":"nocetfy"}],["meta",{"property":"og:title","content":"系统设计"}],["meta",{"property":"og:description","content":"系统设计 [toc] 即时消息系统 即时消息系统，但是基本上好多即时通讯软件都属于这一类，比如微信，比如 QQ，比如 Facebook Messenger，比如 WhatsApp。 用户发送消息，直接发给 Chat Service，它会做少量的处理并持久化，然后放到基于 channel 的队列中，每一个对话（thread）都会有一个 channel，这个过程中，它并不关心这个对话有多少人参与（支持群聊）。 队列有两类消费者，一类是 Message Service 用来服务在线用户。由于单台机器和客户端的连接数量有限（比如小于 2^16=65536），因此 Message Service 需要有很多机器，根据用户的 id 来 sharding，它们去订阅自己感兴趣的频道，有新的消息就发送给用户。 Message Service 获取客户端的心跳，保持来自客户端的连接（long polling 或者 socket）为了实时性肯定要用 push 模型。因此它知道用户的当前在线状态，也知道最后一条发送成功消息的时间戳（状态）。这个状态可以用于决定用户离线时消息是否要通过其它方式通知用户。 还有一类是 Notification Service 用来发离线通知。 Chat Service 有两个职责，一个是处理发消息的请求，一个是接纳读取历史消息的请求，这两个功能可以分成两个组件，也可以一个组件，我放在一起了。 右侧的消息数据库，RDB 往往不太适合，因为消息数量太大，对于一组对话（thread）的展示，需要找到该对话 N 条最近的记录，行数据库效率较低，可以考虑列数据库，比如 HBase。这种方式下，同一 thread 下的消息都是按时序存放在一起的，读的效率非常高，写因为基本是 append，也很方便。 用户数据的存储，可以使用 RDB，也可以使用 KV 数据库。 这里面存放的数据库表包括：用户表；对话表；用户对话关联表：二者是 M:N 的关系，并且每个用户都可以有对于特定对话的设置，例如设置对话中的昵称，是否屏蔽消息通知等等。 对于图中基于 Channel 的队列，把数据 fanout 给下游，它有几个作用，一个是解耦，把消息发送和消息接收分离开，消息发送者可能只管把消息发到群里，但是并不关心这个群应该有几个用户得到通知；第二个是缓冲，无论是为离线用户服务的 Notification Service，还是为在线用户服务的 Message Service，它们消费数据的速率是无法确定的。 对于用户上线、下线的实现，其实也类似，上线、下线的事件可以推送到一个特定的 Channel 里面。用户的好友，也就是感兴趣的 Notification Service 的个体去订阅消息；还有一种思路是把状态更新到用户表里面，这样所有人都可以查询得到，这后一种方式适合非好友也要查看用户状态的情况。上、下线需要保留缓冲时间，容许一定状态的延迟，没必要，也不应过于实时。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"系统设计\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[]}"]]},"headers":[{"level":2,"title":"即时消息系统","slug":"即时消息系统","link":"#即时消息系统","children":[]},{"level":2,"title":"流媒体设计","slug":"流媒体设计","link":"#流媒体设计","children":[]},{"level":2,"title":"朋友圈feed流设计","slug":"朋友圈feed流设计","link":"#朋友圈feed流设计","children":[{"level":3,"title":"微博设计","slug":"微博设计","link":"#微博设计","children":[]},{"level":3,"title":"好友动态怎么提醒","slug":"好友动态怎么提醒","link":"#好友动态怎么提醒","children":[]}]},{"level":2,"title":"短链系统设计","slug":"短链系统设计","link":"#短链系统设计","children":[]},{"level":2,"title":"秒杀系统设计","slug":"秒杀系统设计","link":"#秒杀系统设计","children":[]},{"level":2,"title":"K-V数据库设计","slug":"k-v数据库设计","link":"#k-v数据库设计","children":[]},{"level":2,"title":"RPC系统设计","slug":"rpc系统设计","link":"#rpc系统设计","children":[]},{"level":2,"title":"幂等性设计","slug":"幂等性设计","link":"#幂等性设计","children":[]},{"level":2,"title":"分布式调度系统设计","slug":"分布式调度系统设计","link":"#分布式调度系统设计","children":[]},{"level":2,"title":"API网关设计","slug":"api网关设计","link":"#api网关设计","children":[]},{"level":2,"title":"防资损设计","slug":"防资损设计","link":"#防资损设计","children":[]},{"level":2,"title":"扫码登录设计","slug":"扫码登录设计","link":"#扫码登录设计","children":[{"level":3,"title":"整体流程","slug":"整体流程","link":"#整体流程","children":[]},{"level":3,"title":"状态机设计","slug":"状态机设计","link":"#状态机设计","children":[]},{"level":3,"title":"后端接口","slug":"后端接口","link":"#后端接口","children":[]},{"level":3,"title":"问题思考","slug":"问题思考","link":"#问题思考","children":[]}]},{"level":2,"title":"OAUTH2.0流程","slug":"oauth2-0流程","link":"#oauth2-0流程","children":[{"level":3,"title":"ACCESS_TOKEN与FRESH_TOKEN之token的有效期问题","slug":"access-token与fresh-token之token的有效期问题","link":"#access-token与fresh-token之token的有效期问题","children":[]},{"level":3,"title":"为什么使用refresh_token而不是直接去获取一个新的access_token呢？","slug":"为什么使用refresh-token而不是直接去获取一个新的access-token呢","link":"#为什么使用refresh-token而不是直接去获取一个新的access-token呢","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":25.04,"words":7511},"filePathRelative":"interview/开放设计/设计问题.md","excerpt":"<h1> 系统设计</h1>\\n<p>[toc]</p>\\n<h2> 即时消息系统</h2>\\n<p>即时消息系统，但是基本上好多即时通讯软件都属于这一类，比如微信，比如 QQ，比如 Facebook Messenger，比如 WhatsApp。</p>\\n<figure><img src=\\"https://raw.githubusercontent.com/nocetfy/image/main/img/image.png\\" alt=\\"\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption></figcaption></figure>\\n<ul>\\n<li>用户发送消息，直接发给 Chat Service，它会做少量的处理并持久化，然后放到基于 channel 的队列中，每一个对话（thread）都会有一个 channel，这个过程中，它并不关心这个对话有多少人参与（支持群聊）。</li>\\n<li>队列有两类消费者，一类是 Message Service 用来服务在线用户。由于单台机器和客户端的连接数量有限（比如小于 2^16=65536），因此 Message Service 需要有很多机器，根据用户的 id 来 sharding，它们去订阅自己感兴趣的频道，有新的消息就发送给用户。</li>\\n<li>Message Service 获取客户端的心跳，保持来自客户端的连接（long polling 或者 socket）为了实时性肯定要用 push 模型。因此它知道用户的当前在线状态，也知道最后一条发送成功消息的时间戳（状态）。这个状态可以用于决定用户离线时消息是否要通过其它方式通知用户。</li>\\n<li>还有一类是 Notification Service 用来发离线通知。</li>\\n<li>Chat Service 有两个职责，一个是处理发消息的请求，一个是接纳读取历史消息的请求，这两个功能可以分成两个组件，也可以一个组件，我放在一起了。</li>\\n<li>右侧的消息数据库，RDB 往往不太适合，因为消息数量太大，对于一组对话（thread）的展示，需要找到该对话 N 条最近的记录，行数据库效率较低，可以考虑列数据库，比如 HBase。这种方式下，同一 thread 下的消息都是按时序存放在一起的，读的效率非常高，写因为基本是 append，也很方便。</li>\\n<li>用户数据的存储，可以使用 RDB，也可以使用 KV 数据库。 这里面存放的数据库表包括：用户表；对话表；用户对话关联表：二者是 M:N 的关系，并且每个用户都可以有对于特定对话的设置，例如设置对话中的昵称，是否屏蔽消息通知等等。</li>\\n<li>对于图中基于 Channel 的队列，把数据 fanout 给下游，它有几个作用，一个是解耦，把消息发送和消息接收分离开，消息发送者可能只管把消息发到群里，但是并不关心这个群应该有几个用户得到通知；第二个是缓冲，无论是为离线用户服务的 Notification Service，还是为在线用户服务的 Message Service，它们消费数据的速率是无法确定的。</li>\\n<li>对于用户上线、下线的实现，其实也类似，上线、下线的事件可以推送到一个特定的 Channel 里面。用户的好友，也就是感兴趣的 Notification Service 的个体去订阅消息；还有一种思路是把状态更新到用户表里面，这样所有人都可以查询得到，这后一种方式适合非好友也要查看用户状态的情况。上、下线需要保留缓冲时间，容许一定状态的延迟，没必要，也不应过于实时。</li>\\n</ul>","autoDesc":true}');export{e as data};
