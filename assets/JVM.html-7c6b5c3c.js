import{_ as n,X as a,Y as s,$ as e}from"./framework-47f15ee6.js";const t={},p=e(`<h1 id="jvm" tabindex="-1"><a class="header-anchor" href="#jvm" aria-hidden="true">#</a> JVM</h1><p>[toc]</p><h2 id="jvm内存模型" tabindex="-1"><a class="header-anchor" href="#jvm内存模型" aria-hidden="true">#</a> JVM内存模型</h2><h3 id="运行时数据区" tabindex="-1"><a class="header-anchor" href="#运行时数据区" aria-hidden="true">#</a> 运行时数据区</h3><p>​ 内存是非常重要的系统资源，是硬盘和 CPU 的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行。不同的 JVM 对于内存的划分方式和管理机制存在着部分差异。</p><p>下图是 JVM 整体架构，中间部分就是 Java 虚拟机定义的各种运行时数据区域。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/20230223235458.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>​ Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程一一对应的数据区域会随着线程开始和结束而创建和销毁。</p><ul><li><p>线程私有：程序计数器、虚拟机栈、本地方法区</p></li><li><p>线程共享：堆、方法区，堆外内存(Java7 的永久代或 JDK8 的元空间、代码缓存)</p></li></ul><hr><h3 id="类的生命周期" tabindex="-1"><a class="header-anchor" href="#类的生命周期" aria-hidden="true">#</a> 类的生命周期</h3><p>​ 类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持 Java 语言的运行时绑定 (也成为动态绑定或晚期绑定)。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/1642142864493-cafe2b9c-5363-447b-8d94-4517395556c9.png" alt="1.png" tabindex="0" loading="lazy"><figcaption>1.png</figcaption></figure><h3 id="类的加载-查找并加载类的二进制数据" tabindex="-1"><a class="header-anchor" href="#类的加载-查找并加载类的二进制数据" aria-hidden="true">#</a> 类的加载：查找并加载类的二进制数据</h3><p>加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情:</p><ul><li><p>通过一个类的全限定名来获取其定义的二进制字节流。</p></li><li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p></li><li><p>在 Java 堆中生成一个代表这个类的 java.lang.Class 对象，作为对方法区中这些数据的访问入口。</p></li></ul><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/1642142868007-fe4238d3-0003-4f69-94af-18dc02e79c23.png" alt="2.png" tabindex="0" loading="lazy"><figcaption>2.png</figcaption></figure><p>​ 相对于类加载的其他阶段而言，加载阶段 (准确地说，是加载阶段获取类的二进制字节流的动作) 是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p><p>​ 加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在 Java 堆中也创建一个 java.lang.Class 类的对象，这样便可以通过该对象访问方法区中的这些数据。</p><h4 id="类加载机制" tabindex="-1"><a class="header-anchor" href="#类加载机制" aria-hidden="true">#</a> 类加载机制</h4><h5 id="类加载器结构" tabindex="-1"><a class="header-anchor" href="#类加载器结构" aria-hidden="true">#</a> 类加载器结构</h5><p>通过组合而不是继承来实现。</p><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/image-20230225004824326.png" alt="image-20230225004824326" style="zoom:50%;"><ul><li><strong>BootstrapClassLoader</strong>：启动类类加载器，它用来加载&lt;JAVA_HOME&gt;/jre/lib路径,**-**Xbootclasspath参数指定的路径以&lt;JAVA_HOME&gt;/jre/classes中的类。BootStrapClassLoader是由c++实现的。</li><li><strong>ExtClassLoader</strong>：拓展类类加载器，它用来加载&lt;JAVA_HOME&gt;/jre/lib/ext路径以及java.ext.dirs系统变量指定的类路径下的类。</li><li><strong>AppClassLoader</strong>：应用程序类类加载器，它主要加载应用程序ClassPath下的类（包含jar包中的类）。它是java应用程序默认的类加载器。</li><li><strong>用户自定义类加载器</strong>：用户根据自定义需求，自由的定制加载的逻辑，继承AppClassLoader，仅仅覆盖findClass（）即将继续遵守双亲委派模型。</li></ul><h5 id="双亲委派模型" tabindex="-1"><a class="header-anchor" href="#双亲委派模型" aria-hidden="true">#</a> 双亲委派模型</h5><p>​ <strong>当一个类加载器收到了类加载的请求的时候，他不会直接去加载指定的类，而是把这个请求委托给自己的父加载器去加载。只有父加载器无法加载这个类的时候，才会由当前这个加载器来负责类的加载。</strong></p><p>对双亲委派的破坏：</p><ul><li>是JNDI、JDBC等需要加载SPI接口实现类的情况。</li></ul><blockquote><p>DriverManager会先被类加载器加载，因为java.sql.DriverManager类是位于rt.jar下面的 ，所以他会被根加载器加载。</p><p>类加载时，会执行该类的静态方法。其中有一段关键的代码是：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>ServiceLoader<span class="token operator">&lt;</span>Driver<span class="token operator">&gt;</span> loadedDrivers <span class="token operator">=</span> ServiceLoader<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>Driver<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这段代码，会尝试加载classpath下面的所有实现了Driver接口的实现类。</p><p>那么，问题就来了。</p><p><strong>DriverManager是被根加载器加载的，那么在加载时遇到以上代码，会尝试加载所有Driver的实现类，但是这些实现类基本都是第三方提供的，根据双亲委派原则，第三方的类不能被根加载器加载。</strong></p><p>那么，怎么解决这个问题呢？</p><p>于是，就<strong>在JDBC中通过引入ThreadContextClassLoader（线程上下文加载器，默认情况下是AppClassLoader）的方式破坏了双亲委派原则。</strong></p><p>我们深入到ServiceLoader.load方法就可以看到：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">S</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">ServiceLoader</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">S</span><span class="token punctuation">&gt;</span></span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">S</span><span class="token punctuation">&gt;</span></span> service<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">ClassLoader</span> cl <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token class-name">ServiceLoader</span><span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>service<span class="token punctuation">,</span> cl<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第一行，获取当前线程的线程上下⽂类加载器 AppClassLoader，⽤于加载 classpath 中的具体实现类。</p></blockquote><ul><li><p>实现热插拔热部署工具。为了让代码动态生效而无需重启，实现方式时把模块连同类加载器一起换掉就实现了代码的热替换。</p></li><li><p>tomcat等web容器的出现。</p></li></ul><blockquote><p><strong>如果采用默认的双亲委派类加载机制，那么是无法加载多个相同的类。</strong></p><p>所以，<strong>Tomcat破坏双亲委派原则，提供隔离的机制，为每个web容器单独提供一个WebAppClassLoader加载器。</strong></p><p>​ Tomcat的类加载机制：为了实现隔离性，优先加载 Web 应用自己定义的类，所以没有遵照双亲委派的约定，每一个应用自己的类加载器——WebAppClassLoader负责加载本身的目录下的class文件，加载不到时再交给CommonClassLoader加载，这和双亲委派刚好相反。</p></blockquote><ul><li>OSGI、Jigsaw等模块化技术的应用。</li></ul><blockquote><p><strong>在JDK9中，整个JDK都基于模块化进行构建，以前的rt.jar, tool.jar被拆分成数十个模块，编译的时候只编译实际用到的模块，同时各个类加载器各司其职，只加载自己负责的模块。</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>cn<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 找到当前类属于哪个模块</span>
    <span class="token class-name">LoadedModule</span> loadedModule <span class="token operator">=</span> <span class="token function">findLoadedModule</span><span class="token punctuation">(</span>cn<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>loadedModule <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//获取当前模块的类加载器</span>
        <span class="token class-name">BuiltinClassLoader</span> loader <span class="token operator">=</span> loadedModule<span class="token punctuation">.</span><span class="token function">loader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//进行类加载</span>
        c <span class="token operator">=</span> <span class="token function">findClassInModuleOrNull</span><span class="token punctuation">(</span>loadedModule<span class="token punctuation">,</span> cn<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token comment">// 找不到模块信息才会进行双亲委派</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClassOrNull</span><span class="token punctuation">(</span>cn<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><hr><h3 id="程序计数器" tabindex="-1"><a class="header-anchor" href="#程序计数器" aria-hidden="true">#</a> 程序计数器</h3><p>​ 程序计数寄存器(Program Counter Register)，Register 的命名源于 CPU 的寄存器，寄存器存储指令相关的线程信息，CPU 只有把数据装载到寄存器才能够运行。这里，并非是广义上所指的物理寄存器，叫程序计数器(或 PC 计数器或指令计数器)会更加贴切，并且也不容易引起一些不必要的误会。JVM 中的 程序计数器是对物理 PC 寄存器的一种抽象模拟。</p><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。</p><h4 id="作用" tabindex="-1"><a class="header-anchor" href="#作用" aria-hidden="true">#</a> 作用</h4><p>程序计数器用来存储指向下一条指令的地址，即将要执行的指令代码。由执行引擎读取下一条指令。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/20230223235809.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如图，框中内容即为程序计数器存储的指令地址，执行引擎通过指令地址找到操作指令</p><p>(分析：进入 class 文件所在目录，执行 javap -v xx.class 反解析(或者通过 IDEA 插件 Jclasslib 直接查看，如上图)，可以看到当前类对应的 Code 区(汇编指令)、本地变量表、异常表和代码行偏移量映射表、常量池等信息。)</p><h4 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h4><p>通过下面两个问题，理解下程序计数器</p><ul><li>使用程序计数器存储字节码指令地址有什么用呢？为什么使用程序计数器记录当前线程的执行地址呢？</li></ul><blockquote><p>​ 因为 CPU 需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。JVM 的字节码解释器就需要通过改变程序计数器的值来明确下一条应该执行什么样的字节码指令。</p></blockquote><ul><li>程序计数器为什么会被设定为线程私有的？</li></ul><blockquote><p>​ 多线程在一个特定的时间段内只会执行其中某一个线程方法，CPU 会不停的做任务切换，这样必然会导致经常中断或恢复。为了能够准确的记录各个线程正在执行的当前字节码指令地址，所以为每个线程都分配了一个程序计数器，每个线程都独立计算，不会互相影响。</p></blockquote><p>相关总结如下：</p><ul><li><p>它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域</p></li><li><p>在 JVM 规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期一致</p></li><li><p>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。如果当前线程正在执行的是 Java 方法，程序计数器记录的是 JVM 字节码指令地址，如果是执行 native 方法，则是未指定值(undefined)</p></li><li><p>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</p></li><li><p>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</p></li><li><p>它是唯一一个在 JVM 规范中没有规定任何 OutOfMemoryError 情况的区域</p></li></ul><hr><h3 id="虚拟机栈" tabindex="-1"><a class="header-anchor" href="#虚拟机栈" aria-hidden="true">#</a> 虚拟机栈</h3><h4 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h4><p>由于跨平台性的设计，Java 的指令都是根据栈来设计的(由于不同平台 CPU 架构不同，所以基于栈设计)。与基于寄存器的设计相比：</p><ul><li><p>优点：跨平台，指令集小，编译器容易实现。</p></li><li><p>缺点：性能下降，实现同样的功能的指令更多。</p></li></ul><p><strong>作用</strong>：主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</p><p><strong>特点</strong>：</p><ul><li><p>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</p></li><li><p>JVM 直接对虚拟机栈的操作只有两个：每个方法执行，伴随着入栈(进栈 / 压栈)，方法执行结束出栈</p></li><li><p>栈不存在垃圾回收问题</p></li></ul><p><strong>栈中可能出现的异常</strong>：</p><p>Java 虚拟机规范允许 <strong>Java 虚拟机栈的大小是动态的或者是固定不变的</strong></p><ul><li><p>如果采用固定大小的 Java 虚拟机栈，那每个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个 StackOverflowError 异常</p></li><li><p>如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个 OutOfMemoryError 异常</p></li></ul><p>可以通过参数 -Xss 来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</p><hr><h4 id="栈的存储单位" tabindex="-1"><a class="header-anchor" href="#栈的存储单位" aria-hidden="true">#</a> 栈的存储单位</h4><p>栈中存储什么？</p><ul><li><p>每个线程都有自己的栈，栈中的数据都是以栈帧(Stack Frame)的格式存在</p></li><li><p>在这个线程上正在执行的每个方法都各自有对应的一个栈帧</p></li><li><p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</p></li></ul><h4 id="栈运行原理" tabindex="-1"><a class="header-anchor" href="#栈运行原理" aria-hidden="true">#</a> 栈运行原理</h4><p>​ 不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。Java 方法有两种返回函数的方式，一种是正常的函数返回，使用 return 指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</p><p>IDEA 可以在 debug 窗口看到 Frames 中各种方法的压栈和出栈情况</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/20230224000253.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h4 id="栈帧的内部结构" tabindex="-1"><a class="header-anchor" href="#栈帧的内部结构" aria-hidden="true">#</a> 栈帧的内部结构</h4><p>每个栈帧(Stack Frame)中存储着：</p><ul><li><p>局部变量表(Local Variables)</p></li><li><p>操作数栈(Operand Stack)(或称为表达式栈)</p></li><li><p>动态链接(Dynamic Linking)：指向运行时常量池的方法引用</p></li><li><p>方法返回地址(Return Address)：方法正常退出或异常退出的地址</p></li><li><p>一些附加信息</p></li></ul><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/20230224000320.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h5 id="局部变量表" tabindex="-1"><a class="header-anchor" href="#局部变量表" aria-hidden="true">#</a> 局部变量表</h5><p>​ 局部变量表(Local Variables)，又称局部变量数组或本地变量表，是一个<strong>数字数组</strong>，主要用于存储方法参数和定义在方法体内的<strong>局部变量</strong>，这些数据类型包括基本数据类型(8 种)、对象引用(reference)，以及 returnAddress(指向了一条字节码指令的地址)类型。由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong>。</p><p>​ <strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的 Code 属性的 Maximum local variables 数据项中。在方法运行期间是不会改变局部变量表的大小的。<strong>局部变量表中的变量只在当前方法调用中有效</strong>。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。<strong>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁</strong>。</p><h6 id="槽-slot" tabindex="-1"><a class="header-anchor" href="#槽-slot" aria-hidden="true">#</a> 槽 Slot</h6><ul><li><p>局部变量表最基本的存储单元是 Slot(变量槽)</p></li><li><p>在局部变量表中，32 位以内的类型只占用一个 Slot (包括 returnAddress 类型)，64 位的类型(long 和 double)占用两个连续的 Slot</p></li></ul><blockquote><p>byte、short、char 在存储前被转换为 int，boolean 也被转换为 int，0 表示 false，非 0 表示 true</p><p>long 和 double 则占据两个 Slot</p></blockquote><ul><li><p>JVM 会为局部变量表中的每一个 Slot 都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值，索引值的范围从 0 开始到局部变量表最大的 Slot 数量</p></li><li><p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个 Slot 上</p></li><li><p>如果需要访问局部变量表中一个 64bit 的局部变量值时，只需要使用前一个索引即可。(比如：访问 long 或 double 类型变量，不允许采用任何方式单独访问其中的某一个 Slot)</p></li><li><p>如果当前帧是由构造方法或实例方法创建的，那么该对象引用 this 将会存放在 index 为 0 的 Slot 处，其余的参数按照参数表顺序继续排列(静态方法中为什么不可以引用 this，就是因为 this 变量不存在于静态方法的局部变量表中)</p></li><li><p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。(下图中，this、a、b、c 理论上应该有 4 个变量，c 复用了 b 的槽)</p></li></ul><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/20230224000614.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><p>在栈帧中，与性能调优关系最为密切的就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递</p></li><li><p>局部变量表中的变量也是重要的垃圾回收根节点，垃圾回收时可以从局部变量表中的变量作为根节点判断对象是否仍被引用</p></li></ul><hr><h5 id="操作数栈" tabindex="-1"><a class="header-anchor" href="#操作数栈" aria-hidden="true">#</a> 操作数栈</h5><ul><li><p>每个独立的栈帧中除了包含局部变量表之外，还包含一个后进先出(Last-In-First-Out)的操作数栈，也可以称为表达式栈(Expression Stack)</p></li><li><p>操作数栈，在方法执行过程中，根据字节码指令，往操作数栈中写入数据或提取数据，即入栈(push)、出栈(pop)</p></li><li><p>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。比如，执行复制、交换、求和等操作</p></li></ul><h6 id="概述-1" tabindex="-1"><a class="header-anchor" href="#概述-1" aria-hidden="true">#</a> 概述</h6><ul><li><p>操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</p></li><li><p>操作数栈就是 JVM 执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，此时这个方法的操作数栈是空的</p></li><li><p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的 Code 属性的 max_stack 数据项中</p></li><li><p>栈中的任何一个元素都可以是任意的 Java 数据类型</p></li></ul><blockquote><p>32bit 的类型占用一个栈单位深度</p><p>64bit 的类型占用两个栈单位深度</p></blockquote><ul><li><p>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问</p></li><li><p>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新 程序计数器中下一条需要执行的字节码指令</p></li><li><p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证</p></li><li><p>另外，我们说 Java 虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。</p></li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>

  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">98</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code> <span class="token number">0</span> bipush <span class="token number">100</span>
 <span class="token number">2</span> istore_0
 <span class="token number">3</span> bipush <span class="token number">98</span>
 <span class="token number">5</span> istore_1
 <span class="token number">6</span> iload_0
 <span class="token number">7</span> iload_1
 <span class="token number">8</span> iadd
 <span class="token number">9</span> istore_2
<span class="token number">10</span> <span class="token keyword">return</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>​ 前面的指令分别将100和98压入操作数栈，<code>istore_0</code>和<code>istore_1</code>从操作数栈中弹出结果，并把它存储到局部变量区索引为 0和1 的位置。之后的两个指令 <code>iload_0</code> 和 <code>iload_1</code> 将存储在局部变量中索引为 0 和 1 的整数压入操作数栈中，其后 <code>iadd</code> 指令从操作数栈中弹出那两个整数相加，再将结果压入操作数栈。第四条指令 <code>istore_2</code> 则从操作数栈中弹出结果，并把它存储到局部变量区索引为 2 的位置。</p></blockquote><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/20230224001024.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h6 id="栈顶缓存-top-of-stack-cashing" tabindex="-1"><a class="header-anchor" href="#栈顶缓存-top-of-stack-cashing" aria-hidden="true">#</a> 栈顶缓存(Top-of-stack-Cashing)</h6><p>​ 基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派(instruction dispatch)次数和内存读 / 写次数。由于操作数是存储在内存中的，因此频繁的执行内存读 / 写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM 设计者们提出了栈顶缓存技术，将栈顶元素全部缓存在物理 CPU 的寄存器中，以此降低对内存的读 / 写次数，提升执行引擎的执行效率。</p><hr><h5 id="动态链接-指向运行时常量池的方法引用" tabindex="-1"><a class="header-anchor" href="#动态链接-指向运行时常量池的方法引用" aria-hidden="true">#</a> 动态链接(指向运行时常量池的方法引用)</h5><ul><li><p>每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接 (Dynamic Linking)。</p></li><li><p>在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用(Symbolic Reference)保存在 Class 文件的常量池中。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</p></li></ul><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/20230224001105.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h6 id="jvm-是如何执行方法调用的" tabindex="-1"><a class="header-anchor" href="#jvm-是如何执行方法调用的" aria-hidden="true">#</a> JVM 是如何执行方法调用的</h6><p>​ 方法调用不同于方法执行，方法调用阶段的唯一任务就是确定被调用方法的版本(即调用哪一个方法)，暂时还不涉及方法内部的具体运行过程。Class 文件的编译过程中不包括传统编译器中的连接步骤，一切方法调用在 Class 文件里面存储的都是符号引用，而不是方法在实际运行时内存布局中的入口地址(直接引用)。也就是需要在类加载阶段，甚至到运行期才能确定目标方法的直接引用。</p><p>除了方法调用，还包括解析、分派(静态分派、动态分派、单分派与多分派)</p><p>在 JVM 中，将符号引用转换为调用方法的直接引用与方法的绑定机制有关</p><ul><li><p>静态链接：当一个字节码文件被装载进 JVM 内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</p></li><li><p>动态链接：如果被调用的方法在编译期无法被确定下来，也就是说，只能在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接</p></li></ul><p>对应的方法的绑定机制为：早期绑定(Early Binding)和晚期绑定(Late Binding)。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p><ul><li><p>早期绑定：早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p></li><li><p>晚期绑定：如果被调用的方法在编译器无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式就被称为晚期绑定。</p></li></ul><h6 id="虚方法和非虚方法" tabindex="-1"><a class="header-anchor" href="#虚方法和非虚方法" aria-hidden="true">#</a> 虚方法和非虚方法</h6><ul><li><p>如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法，比如静态方法、私有方法、final 方法、实例构造器、父类方法都是非虚方法</p></li><li><p>其他方法称为虚方法</p></li></ul><h6 id="虚方法表" tabindex="-1"><a class="header-anchor" href="#虚方法表" aria-hidden="true">#</a> 虚方法表</h6><p>​ 在面向对象编程中，会频繁的使用到动态分派，如果每次动态分派都要重新在类的方法元数据中搜索合适的目标有可能会影响到执行效率。为了提高性能，JVM 采用在类的方法区建立一个虚方法表(virtual method table)，使用索引表来代替查找。非虚方法不会出现在表中。</p><p>​ 每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</p><p>​ 虚方法表会在类加载的连接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM 会把该类的方法表也初始化完毕。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OverridingInternalExample</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Mammal</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;ohlllalalalalalaoaoaoa&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Human</span> <span class="token keyword">extends</span> <span class="token class-name">Mammal</span> <span class="token punctuation">{</span>

        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

        <span class="token comment">// Valid overload of speak</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">speak</span><span class="token punctuation">(</span><span class="token class-name">String</span> language<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>language<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">&quot;Hindi&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Namaste&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token string">&quot;Human Class&quot;</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Mammal</span> anyMammal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Mammal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        anyMammal<span class="token punctuation">.</span><span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Output - ohlllalalalalalaoaoaoa</span>
        <span class="token comment">// 10: invokevirtual #4 </span>

        <span class="token class-name">Mammal</span> humanMammal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Human</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        humanMammal<span class="token punctuation">.</span><span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Output - Hello</span>
        <span class="token comment">// 23: invokevirtual #4 </span>

        <span class="token class-name">Human</span> human <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Human</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        human<span class="token punctuation">.</span><span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Output - Hello</span>
        <span class="token comment">// 36: invokevirtual #7 </span>

        human<span class="token punctuation">.</span><span class="token function">speak</span><span class="token punctuation">(</span><span class="token string">&quot;Hindi&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Output - Namaste</span>
        <span class="token comment">// 42: invokevirtual #9 </span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/20230224001213.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><blockquote><p>在 Java 中，每个引用变量都包含两个隐藏指针</p><ol><li>一个指向再次包含对象方法的表的指针和一个指向 Class 对象的指针。例如[speak(), speak(String) Class object]</li><li>指向在堆上为该对象的数据分配的内存的指针，例如实例变量的值。因此，所有对象引用都间接持有对包含该对象所有方法引用的表的引用。 Java 从 C++ 中借用了这个概念，这个表被称为虚拟表(vtable)。 vtable 是一个类似数组的结构，其中包含虚拟方法名称及其对数组索引的引用。JVM 在将类加载到内存时只为每个类创建一个 vtable。因此，每当 JVM 遇到 invokevirtual 指令集时，它会检查该类的 vtable 中的方法引用并调用特定方法，在我们的例子中，该方法是来自对象而不是引用的方法。因为所有这些都只在运行时解决，并且在运行时 JVM 知道要调用哪个方法，这就是为什么方法覆盖被称为动态多态或简称为多态或动态绑定的原因。</li></ol></blockquote><hr><h5 id="方法返回地址-return-address" tabindex="-1"><a class="header-anchor" href="#方法返回地址-return-address" aria-hidden="true">#</a> 方法返回地址(return address)</h5><p>用来存放调用该方法的程序计数器的值。</p><p>一个方法的结束，有两种方式</p><ul><li><p>正常执行完成</p></li><li><p>出现未处理的异常，非正常退出</p></li></ul><p>​ 无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的 PC 计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定的，栈帧中一般不会保存这部分信息。</p><p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p><ol><li><p>执行引擎遇到任意一个方法返回的字节码指令，会有返回值传递给上层的方法调用者，简称正常完成出口 一个方法的正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定。在字节码指令中，返回指令包含 ireturn (当返回值是 boolean、byte、char、short 和 int 类型时使用)、lreturn、freturn、dreturn 以及 areturn，另外还有一个 return 指令供声明为 void 的方法、实例初始化方法、类和接口的初始化方法使用。</p></li><li><p>在方法执行的过程中遇到了异常，并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称异常完成出口 方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。</p></li></ol><p>​ 本质上，<strong>方法的退出就是当前栈帧出栈的过程</strong>。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置程序计数器值等，让调用者方法继续执行下去。</p><p>正常完成出口和异常完成出口的区别在于：<strong>通过异常完成出口退出的不会给他的上层调用者产生任何的返回值</strong>。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>  <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">giveMeThatOldFashionedBoolean</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> bVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>bVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Got old fashioned.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// The bytecode sequence for the try block:</span>
   <span class="token number">0</span> iload_0               <span class="token comment">// Push local variable 0 (arg passed as divisor)</span>
   <span class="token number">1</span> ifeq <span class="token number">11</span>               <span class="token comment">// Push local variable 1 (arg passed as dividend)</span>
   <span class="token number">4</span> iconst_1              <span class="token comment">// Push int 1</span>
   <span class="token number">5</span> istore_3              <span class="token comment">// Pop an int (the 1), store into local variable 3</span>
   <span class="token number">6</span> jsr <span class="token number">24</span>                <span class="token comment">// Jump to the mini-subroutine for the finally clause</span>
   <span class="token number">9</span> iload_3               <span class="token comment">// Push local variable 3 (the 1)</span>
  <span class="token number">10</span> ireturn               <span class="token comment">// Return int on top of the stack (the 1)</span>
  <span class="token number">11</span> iconst_0              <span class="token comment">// Push int 0</span>
  <span class="token number">12</span> istore_3              <span class="token comment">// Pop an int (the 0), store into local variable 3</span>
  <span class="token number">13</span> jsr <span class="token number">24</span>                <span class="token comment">// Jump to the mini-subroutine for the finally clause</span>
  <span class="token number">16</span> iload_3               <span class="token comment">// Push local variable 3 (the 0)</span>
  <span class="token number">17</span> ireturn               <span class="token comment">// Return int on top of the stack (the 0)</span>
<span class="token comment">// The bytecode sequence for a catch clause that catches any kind of exception</span>
<span class="token comment">// thrown from within the try block.</span>
  <span class="token number">18</span> astore_1              <span class="token comment">// Pop the reference to the thrown exception, store</span>
                           <span class="token comment">// into local variable 1</span>
  <span class="token number">19</span> jsr <span class="token number">24</span>                <span class="token comment">// Jump to the mini-subroutine for the finally clause</span>
  <span class="token number">22</span> aload_1               <span class="token comment">// Push the reference (to the thrown exception) from</span>
                           <span class="token comment">// local variable 1</span>
  <span class="token number">23</span> athrow                <span class="token comment">// Rethrow the same exception</span>
<span class="token comment">// The miniature subroutine that implements the finally block.</span>
  <span class="token number">24</span> astore_2              <span class="token comment">// Pop the return address, store it in local variable 2</span>
  <span class="token number">25</span> getstatic #<span class="token number">8</span>          <span class="token comment">// Get a reference to java.lang.System.out</span>
  <span class="token number">28</span> ldc #<span class="token number">1</span>                <span class="token comment">// Push &lt;String &quot;Got old fashioned.&quot;&gt; from the constant pool</span>
  <span class="token number">30</span> invokevirtual #<span class="token number">7</span>      <span class="token comment">// Invoke System.out.println()</span>
  <span class="token number">33</span> ret <span class="token number">2</span>                 <span class="token comment">// Return to return address stored in local variable 2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>​ jsr 指令执行完之后，JVM 会把控制跳转到指定的偏移量上，同时会把紧接在这条 jsr 指令之后的字节码指令的地址压到操作数栈顶。位于偏移量 24 的字节码指令马上把操作数栈顶的 returnAddress 保存了下来(到局部变量 2)，最后的 ret 则从局部变量 2 找到 returnAddress 跳转回到刚才那条 jsr 指令之后的地方继续执行。</p></blockquote><p>​ JDK 里的 javac 从 JDK 1.4.2 开始就不生成 jsr/ret 指令了, 把 finally 块的内容复制到原本每个 jsr 指令所在的地方。这样就不需要 jsr/ret 了，代价则是字节码大小会膨胀。</p><h5 id="附加信息" tabindex="-1"><a class="header-anchor" href="#附加信息" aria-hidden="true">#</a> 附加信息</h5><p>栈帧中还允许携带与 Java 虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息，但这些信息取决于具体的虚拟机实现。</p><hr><h3 id="本地方法栈" tabindex="-1"><a class="header-anchor" href="#本地方法栈" aria-hidden="true">#</a> 本地方法栈</h3><p>Java 虚拟机栈用于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用</p><ul><li><p>本地方法栈也是线程私有的</p></li><li><p>允许线程固定或者可动态扩展的内存大小</p></li></ul><blockquote><ul><li><p>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java 虚拟机将会抛出一个 StackOverflowError 异常</p></li><li><p>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么 Java 虚拟机将会抛出一个 OutofMemoryError 异常</p></li></ul></blockquote><ul><li><p>本地方法是使用 C 语言实现的</p></li><li><p>它的具体做法是 Native Method Stack 中登记 native 方法，在 Execution Engine 执行时加载本地方法库当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</p></li><li><p>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区，它甚至可以直接使用本地处理器中的寄存器，直接从本地内存的堆中分配任意数量的内存</p></li><li><p>并不是所有 JVM 都支持本地方法。因为 Java 虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果 JVM 产品不打算支持 native 方法，也可以无需实现本地方法栈。</p></li><li><p>在 Hotspot JVM 中，直接将本地方法栈和虚拟机栈合二为一</p></li></ul><blockquote><p>栈是运行时的单位，而堆是存储的单位。栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪。</p></blockquote><hr><h3 id="堆内存" tabindex="-1"><a class="header-anchor" href="#堆内存" aria-hidden="true">#</a> 堆内存</h3><h4 id="内存划分" tabindex="-1"><a class="header-anchor" href="#内存划分" aria-hidden="true">#</a> 内存划分</h4><p>​ 对于大多数应用，Java 堆是 Java 虚拟机管理的内存中最大的一块，被所有线程共享。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数据都在这里分配内存。</p><p>为了进行高效的垃圾回收，虚拟机把堆内存逻辑上划分成三块区域(分代的唯一理由就是优化 GC 性能)：</p><ul><li><p>新生代(年轻代)：新对象和没达到一定年龄的对象都在新生代</p></li><li><p>老年代(老年代)：被长时间使用的对象，老年代的内存空间应该要比年轻代更大</p></li><li><p>元空间(JDK1.8 之前叫永久代)：像一些方法中的操作临时对象等，JDK1.8 之前是占用 JVM 内存，JDK1.8 之后直接使用物理内存</p></li></ul><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/20230224001650.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>​ Java 虚拟机规范规定，Java 堆可以是处于物理上不连续的内存空间中，只要逻辑上是连续的即可，像磁盘空间一样。实现时，既可以是固定大小，也可以是可扩展的，主流虚拟机都是可扩展的(通过 -Xmx 和 -Xms 控制)，如果堆中没有完成实例分配，并且堆无法再扩展时，就会抛出 OutOfMemoryError 异常。</p><h5 id="年轻代-young-generation" tabindex="-1"><a class="header-anchor" href="#年轻代-young-generation" aria-hidden="true">#</a> 年轻代 (Young Generation)</h5><p>​ 年轻代是所有新对象创建的地方。当填充年轻代时，执行垃圾收集。这种垃圾收集称为 Minor GC。年轻一代被分为三个部分：<code>eden</code>(Eden Memory)和两个幸存区(<code>Survivor</code> Memory，被称为 from/to 或 s0/s1)，默认比例是 8:1:1</p><ul><li><p>大多数新创建的对象都位于 Eden 内存空间中</p></li><li><p>当 Eden 空间被对象填充时，执行 Minor GC，并将所有幸存者对象移动到一个幸存者空间中</p></li><li><p>Minor GC 检查幸存者对象，并将它们移动到另一个幸存者空间。所以每次，一个幸存者空间总是空的</p></li><li><p>经过多次 GC 循环后存活下来的对象被移动到老年代。通常，这是通过设置年轻一代对象的年龄阈值来实现的，然后他们才有资格提升到老一代</p></li></ul><h5 id="老年代-old-generation" tabindex="-1"><a class="header-anchor" href="#老年代-old-generation" aria-hidden="true">#</a> 老年代 (Old Generation)</h5><p>​ 旧的一代内存包含那些经过许多轮小型 GC 后仍然存活的对象。通常，垃圾收集是在老年代内存满时执行的。老年代垃圾收集称为 主 GC(Major GC)，通常需要更长的时间。</p><p>大对象直接进入老年代(大对象是指需要大量连续内存空间的对象)。这样做的目的是避免在 <code>Eden</code> 区和两个 <code>Survivor</code> 区之间发生大量的内存拷贝</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/20230224001806.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="元空间" tabindex="-1"><a class="header-anchor" href="#元空间" aria-hidden="true">#</a> 元空间</h4><p>​ 不管是 JDK8 之前的永久代，还是 JDK8 及以后的元空间，都可以看作是 Java 虚拟机规范中方法区的实现。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap(非堆)，目的是与 Java 堆区分开。元空间放在后边的方法区再说。</p><hr><h4 id="设置堆内存大小和-oom" tabindex="-1"><a class="header-anchor" href="#设置堆内存大小和-oom" aria-hidden="true">#</a> 设置堆内存大小和 OOM</h4><p>Java 堆用于存储 Java 对象实例，那么堆的大小在 JVM 启动的时候就确定了，我们可以通过 -Xmx 和 -Xms 来设定</p><ul><li><p>-Xms 用来表示堆的起始内存，等价于 -XX:InitialHeapSize</p></li><li><p>-Xmx 用来表示堆的最大内存，等价于 -XX:MaxHeapSize</p></li></ul><p>如果堆的内存大小超过 -Xmx 设定的最大内存， 就会抛出 OutOfMemoryError 异常。</p><p>我们通常会将 -Xmx 和 -Xms 两个参数配置为相同的值，其目的是为了能够在垃圾回收机制清理完堆区后不再需要重新分隔计算堆的大小，从而提高性能</p><ul><li><p>默认情况下，初始堆内存大小为：电脑内存大小 / 64</p></li><li><p>默认情况下，最大堆内存大小为：电脑内存大小 / 4</p></li></ul><p>可以通过代码获取到我们的设置值，当然也可以模拟 OOM：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token comment">//返回 JVM 堆大小</span>
  <span class="token keyword">long</span> initalMemory <span class="token operator">=</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">totalMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">/</span><span class="token number">1024</span><span class="token punctuation">;</span>
  <span class="token comment">//返回 JVM 堆的最大内存</span>
  <span class="token keyword">long</span> maxMemory <span class="token operator">=</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">maxMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">/</span><span class="token number">1024</span><span class="token punctuation">;</span>

  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;-Xms : &quot;</span><span class="token operator">+</span>initalMemory <span class="token operator">+</span> <span class="token string">&quot;M&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;-Xmx : &quot;</span><span class="token operator">+</span>maxMemory <span class="token operator">+</span> <span class="token string">&quot;M&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;系统内存大小：&quot;</span> <span class="token operator">+</span> initalMemory <span class="token operator">*</span> <span class="token number">64</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">+</span> <span class="token string">&quot;G&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;系统内存大小：&quot;</span> <span class="token operator">+</span> maxMemory <span class="token operator">*</span> <span class="token number">4</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">+</span> <span class="token string">&quot;G&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="查看-jvm-堆内存分配" tabindex="-1"><a class="header-anchor" href="#查看-jvm-堆内存分配" aria-hidden="true">#</a> 查看 JVM 堆内存分配</h5><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/20230224001914.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在默认不配置 JVM 堆内存大小的情况下，JVM 根据默认值来配置当前内存大小</p><ol><li>默认情况下新生代和老年代的比例是 1:2，可以通过 –XX:NewRatio 来配置</li></ol><ul><li>新生代中的 Eden : From Survivor : To Survivor 的比例是 8:1:1，可以通过 -XX:SurvivorRatio 来配置</li></ul><ol start="2"><li>若在 JDK 7 中开启了 -XX:+UseAdaptiveSizePolicy，JVM 会动态调整 JVM 堆中各个区域的大小以及进入老年代的年龄。JDK 1.8 默认使用 UseParallelGC 垃圾回收器，该垃圾回收器默认启动了 AdaptiveSizePolicy。</li></ol><p>每次 GC 后都会重新计算 Eden、From Survivor、To Survivor 的大小</p><p>计算依据是<strong>GC过程</strong>中统计的<strong>GC时间</strong>、<strong>吞吐量</strong>、<strong>内存占用量</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">java</span> <span class="token parameter variable">-XX:+PrintFlagsFinal</span> <span class="token parameter variable">-version</span> <span class="token operator">|</span> <span class="token function">grep</span> HeapSize
    uintx ErgoHeapSizeLimit                         <span class="token operator">=</span> <span class="token number">0</span>                                   <span class="token punctuation">{</span>product<span class="token punctuation">}</span>
    uintx HeapSizePerGCThread                       <span class="token operator">=</span> <span class="token number">87241520</span>                            <span class="token punctuation">{</span>product<span class="token punctuation">}</span>
    uintx InitialHeapSize                          :<span class="token operator">=</span> <span class="token number">134217728</span>                           <span class="token punctuation">{</span>product<span class="token punctuation">}</span>
    uintx LargePageHeapSizeThreshold                <span class="token operator">=</span> <span class="token number">134217728</span>                           <span class="token punctuation">{</span>product<span class="token punctuation">}</span>
    uintx MaxHeapSize                              :<span class="token operator">=</span> <span class="token number">2147483648</span>                          <span class="token punctuation">{</span>product<span class="token punctuation">}</span>
<span class="token function">java</span> version <span class="token string">&quot;1.8.0_211&quot;</span>
Java<span class="token punctuation">(</span>TM<span class="token punctuation">)</span> SE Runtime Environment <span class="token punctuation">(</span>build <span class="token number">1.8</span>.0_211-b12<span class="token punctuation">)</span>
Java HotSpot<span class="token punctuation">(</span>TM<span class="token punctuation">)</span> <span class="token number">64</span>-Bit Server VM <span class="token punctuation">(</span>build <span class="token number">25.211</span>-b12, mixed mode<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ jmap <span class="token parameter variable">-heap</span> 进程号
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><hr><h4 id="对象在堆中的生命周期" tabindex="-1"><a class="header-anchor" href="#对象在堆中的生命周期" aria-hidden="true">#</a> 对象在堆中的生命周期</h4><ol><li>在 JVM 内存模型的堆中，堆被划分为新生代和老年代</li></ol><ul><li>新生代又被进一步划分为 Eden 区 和 Survivor 区，Survivor 区由 From Survivor 和 To Survivor 组成</li></ul><ol start="2"><li>当创建一个对象时，对象会被优先分配到新生代的 Eden 区</li></ol><ul><li>此时 JVM 会给对象定义一个对象年轻计数器(-XX:MaxTenuringThreshold)</li></ul><ol start="3"><li>当 Eden 空间不足时，JVM 将执行新生代的垃圾回收(Minor GC)</li></ol><ul><li><p>JVM 会把存活的对象转移到 Survivor 中，并且对象年龄 +1</p></li><li><p>对象在 Survivor 中同样也会经历 Minor GC，每经历一次 Minor GC，对象年龄都会 + 1</p></li></ul><ol start="4"><li>如果分配的对象超过了 -XX:PetenureSizeThreshold，对象会直接被分配到老年代</li></ol><hr><h4 id="对象的分配过程" tabindex="-1"><a class="header-anchor" href="#对象的分配过程" aria-hidden="true">#</a> 对象的分配过程</h4><p>​ 为对象分配内存是一件非常严谨和复杂的任务，JVM 的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法和内存回收算法密切相关，所以还需要考虑 GC 执行完内存回收后是否会在内存空间中产生内存碎片。</p><ol><li><p>new 的对象先放在eden区，此区有大小限制</p></li><li><p>当eden的空间填满时，程序又需要创建对象，JVM 的垃圾回收器将对eden区进行垃圾回收(Minor GC)，将eden区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到eden区</p></li><li><p>然后将eden中的剩余对象移动到survivor0区</p></li><li><p>如果再次触发垃圾回收，此时上次幸存下来的放到survivor0区，如果没有回收，就会放到survivor1区</p></li><li><p>如果再次经历垃圾回收，此时会重新放回survivor0区，接着再去survivor1区</p></li><li><p>什么时候才会去老年代呢？ 默认是 15 次回收标记</p></li><li><p>当老年代内存不足时，再次触发 Major GC，进行老年代的内存清理</p></li><li><p>若老年代执行了 Major GC 之后发现依然无法进行对象的保存，就会产生 OOM 异常</p></li></ol><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/20230224002252.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h4 id="tlab" tabindex="-1"><a class="header-anchor" href="#tlab" aria-hidden="true">#</a> TLAB</h4><ul><li>堆空间都是共享的么?</li></ul><blockquote><p>不一定，因为还有 TLAB 这个概念，在堆中划分出一块区域，为每个线程所独占。</p></blockquote><ul><li>为什么有 TLAB？</li></ul><blockquote><p>TLAB：Thread Local Allocation Buffer，也就是为每个线程单独分配了一个缓冲区。</p><p>​ 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据。由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的。为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</p></blockquote><ul><li>什么是 TLAB</li></ul><blockquote><p>​ 从内存模型而不是垃圾收集的角度，对 Eden 区域继续进行划分，JVM 为每个线程分配了一个私有缓存区域，它包含在 Eden 空间内。多线程同时分配内存时，使用 TLAB 可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称为快速分配策略。所有 OpenJDK 衍生出来的 JVM 都提供了 TLAB 的设计。尽管不是所有的对象实例都能够在 TLAB 中成功分配内存，但 JVM 确实是将 TLAB 作为内存分配的首选。在程序中，开发人员可以通过选项 -XX:UseTLAB 设置是否开启 TLAB 空间。默认情况下，TLAB 空间的内存非常小，仅占有整个 Eden 空间的 1%，当然我们可以通过选项-XX:TLABWasteTargetPercent 设置 TLAB 空间所占用 Eden 空间的百分比大小。一旦对象在 TLAB 空间分配内存失败时，JVM 就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在 Eden 空间中分配内存。</p></blockquote><ul><li>TLAB 分配过程</li></ul><blockquote><p>对象首先是通过 TLAB 开辟空间，如果不能放入，那么需要通过 Eden 来进行分配。</p></blockquote><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/20230224002422.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h4 id="堆是分配对象存储的唯一选择吗" tabindex="-1"><a class="header-anchor" href="#堆是分配对象存储的唯一选择吗" aria-hidden="true">#</a> 堆是分配对象存储的唯一选择吗</h4><p>​ 随着 JIT 编译期的发展和逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么 “绝对” 了。</p><h5 id="逃逸分析" tabindex="-1"><a class="header-anchor" href="#逃逸分析" aria-hidden="true">#</a> 逃逸分析</h5><p>​ 逃逸分析 (Escape Analysis) 是目前 Java 虚拟机中比较前沿的优化技术。这是一种可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot 编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p><p>逃逸分析的基本行为就是分析对象动态作用域：</p><ul><li><p>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</p></li><li><p>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中，称为方法逃逸。</p></li></ul><p>例如：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StringBuffer</span> <span class="token function">craeteStringBuffer</span><span class="token punctuation">(</span><span class="token class-name">String</span> s1<span class="token punctuation">,</span> <span class="token class-name">String</span> s2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token class-name">StringBuffer</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
   sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">return</span> sb<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ StringBuffer sb 是一个方法内部变量，上述代码中直接将 sb 返回，这样这个 StringBuffer 有可能被其他方法所改变，这样它的作用域就不只是在方法内部，虽然它是一个局部变量，称其逃逸到了方法外部。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。</p><p>上述代码如果想要 StringBuffer sb 不逃出方法，可以这样写：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">createStringBuffer</span><span class="token punctuation">(</span><span class="token class-name">String</span> s1<span class="token punctuation">,</span> <span class="token class-name">String</span> s2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token class-name">StringBuffer</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
   sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不直接返回 StringBuffer，那么 StringBuffer 将不会逃逸出方法。</p><p>参数设置：</p><ul><li><p>在 JDK 6u23 版本之后，HotSpot 中默认就已经开启了逃逸分析</p></li><li><p>如果使用较早版本，可以通过 -XX:+DoEscapeAnalysis 显式开启</p></li></ul><p>开发中使用局部变量，就不要在方法外定义。</p><p>使用逃逸分析，编译器可以对代码做优化：</p><ul><li><p><strong>栈上分配</strong>：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配</p></li><li><p><strong>同步省略</strong>：如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步</p></li><li><p><strong>分离对象或标量替换</strong>：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分(或全部)可以不存储在内存，而存储在 CPU 寄存器</p></li></ul><p>开启/禁用逃逸分析时间对比</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/20230224002546.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h5 id="同步省略-锁消除" tabindex="-1"><a class="header-anchor" href="#同步省略-锁消除" aria-hidden="true">#</a> 同步省略(锁消除)</h5><ul><li><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能</p></li><li><p>在动态编译同步块的时候，JIT 编译器可以借助逃逸分析来判断同步块所使用的锁对象是否能够被一个线程访问而没有被发布到其他线程。如果没有，那么 JIT 编译器在编译这个同步块的时候就会取消对这个代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫做同步省略，也叫锁消除。</p></li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">keep</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">Object</span> keeper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">synchronized</span><span class="token punctuation">(</span>keeper<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>keeper<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ 如上代码，代码中对 keeper 这个对象进行加锁，但是 keeper 对象的生命周期只在 keep() 方法中，并不会被其他线程所访问到，所以在 JIT 编译阶段就会被优化掉。优化成：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">keep</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">Object</span> keeper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>keeper<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>开启/关闭锁消除时间对比：</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/1641893217411-c17f82b6-ef48-421f-a3f9-f72d698f50a7.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><hr><h5 id="标量替换" tabindex="-1"><a class="header-anchor" href="#标量替换" aria-hidden="true">#</a> 标量替换</h5><p>​ <strong>标量</strong>(Scalar)是指一个无法再分解成更小的数据的数据。Java 中的原始数据类型就是标量。</p><p>​ 相对的，那些的还可以分解的数据叫做<strong>聚合量</strong>(Aggregate)，Java 中的对象就是聚合量，因为其还可以分解成其他聚合量和标量。</p><p>​ 在 JIT 阶段，通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM 不会创建该对象，而会将该对象成员变量分解若干个被这个方法使用的成员变量所代替。这些代替的成员变量在栈帧或寄存器上分配空间。这个过程就是<strong>标量替换</strong>。</p><p>​ 通过 -XX:+EliminateAllocations 可以开启标量替换，-XX:+PrintEliminateAllocations 查看标量替换情况。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token function">alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token class-name">Point</span> point <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;point.x=&quot;</span><span class="token operator">+</span>point<span class="token punctuation">.</span>x<span class="token operator">+</span><span class="token string">&quot;; point.y=&quot;</span><span class="token operator">+</span>point<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ 以上代码中，point 对象并没有逃逸出 alloc() 方法，并且 point 对象是可以拆解成标量的。那么，JIT 就不会直接创建 Point 对象，而是直接使用两个标量<code> int x</code> ，<code>int y</code> 来替代 Point 对象。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
   <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;point.x=&quot;</span><span class="token operator">+</span>x<span class="token operator">+</span><span class="token string">&quot;; point.y=&quot;</span><span class="token operator">+</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>开启/关闭标量替换的时间对比：</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/20230224002829.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h5 id="栈上分配" tabindex="-1"><a class="header-anchor" href="#栈上分配" aria-hidden="true">#</a> 栈上分配</h5><p>​ JIT 编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</p><p>​ 常见的栈上分配的场景：<strong>给成员变量赋值、方法返回值、实例引用传递</strong>。</p><h6 id="总结-1" tabindex="-1"><a class="header-anchor" href="#总结-1" aria-hidden="true">#</a> 总结：</h6><p>​ 关于逃逸分析的论文在 1999 年就已经发表了，但直到 JDK 1.6 才有实现，而且这项技术到如今也并不是十分成熟的。</p><p>​ <strong>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程</strong>。</p><p>​ 一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p><p>​ 虽然这项技术并不十分成熟，但是他也是即时编译器优化技术中一个十分重要的手段。通过逃逸分析，JVM 会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于 JVM 设计者的选择。Oracle Hotspot JVM 中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。</p><hr><h3 id="方法区" tabindex="-1"><a class="header-anchor" href="#方法区" aria-hidden="true">#</a> 方法区</h3><ul><li><p>方法区(Method Area)是所有线程共享的内存区域。</p></li><li><p>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap(非堆)，目的应该是与 Java 堆区分开。</p></li><li><p>运行时常量池(Runtime Constant Pool)是方法区的一部分。Class 文件中除了有类的版本 / 字段 / 方法 / 接口等描述信息外，还有一项信息是常量池(Constant Pool Table)，用于存放编译期生成的各种字面量和符号引用，这部分内容将类在加载后进入方法区的运行时常量池中存放。运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的是 <code>String.intern()</code> 方法。受方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 异常。</p></li><li><p>方法区的大小和堆空间一样，可以选择固定大小也可选择可扩展，方法区的大小决定了系统可以放多少个类，如果系统类太多，导致方法区溢出，虚拟机同样会抛出内存溢出错误。</p></li><li><p>JVM 关闭后方法区即被释放 。</p></li></ul><h4 id="不同实现" tabindex="-1"><a class="header-anchor" href="#不同实现" aria-hidden="true">#</a> 不同实现</h4><ul><li><p>方法区(method area)只是 JVM 规范中定义的一个概念，用于存储类信息、常量池、静态变量、JIT 编译后的代码等数据，并没有规定如何去实现它，不同的厂商有不同的实现。而永久代(PermGen)是 Hotspot 虚拟机特有的概念， Java8 的时候又被元空间取代了，永久代和元空间都可以理解为方法区的落地实现。</p></li><li><p>永久代物理是堆的一部分，和新生代，老年代地址是连续的(受垃圾回收器管理)，而元空间存在于本地内存(我们常说的堆外内存，不受垃圾回收器管理)，这样就不受 JVM 限制了，也比较难发生 OOM(都会有溢出异常)</p></li><li><p>Java7 中我们通过 -XX:PermSize 和 -xx:MaxPermSize 来设置永久代参数，Java8 之后，随着永久代的取消，这些参数也就随之失效了，改为通过 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize 用来设置元空间参数</p></li><li><p>存储内容不同，元空间存储类的元信息，静态变量和常量池等并入堆中。相当于永久代的数据被分到了堆和元空间中</p></li><li><p>如果方法区域中的内存不能用于满足分配请求，则 Java 虚拟机抛出 OutOfMemoryError</p></li><li><p>JVM 规范说方法区在逻辑上是堆的一部分，但目前实际上是与 Java 堆分开的(Non-Heap)</p></li></ul><p>所以对于方法区，Java8 之后的变化：</p><ul><li><p>移除了永久代(PermGen)，替换为元空间(Metaspace)；</p></li><li><p>永久代中的 class metadata 转移到了 native memory(本地内存，而不是虚拟机)；</p></li><li><p>永久代中的 interned Strings 和 class static variables 转移到了 Java heap；</p></li><li><p>永久代参数 (PermSize MaxPermSize) -&gt; 元空间参数(MetaspaceSize MaxMetaspaceSize)</p></li></ul><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/20230224002955.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h4 id="方法区内部结构" tabindex="-1"><a class="header-anchor" href="#方法区内部结构" aria-hidden="true">#</a> 方法区内部结构</h4><p>方法区用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/1641894120098-8d95d9a0-9cd9-43ab-b642-3338ed7fc9ad.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h5 id="类型信息" tabindex="-1"><a class="header-anchor" href="#类型信息" aria-hidden="true">#</a> 类型信息</h5><p>对每个加载的类型(类 class、接口 interface、枚举 enum、注解 annotation)，JVM 必须在方法区中存储以下类型信息</p><ul><li><p>这个类型的完整有效名称(全名 = 包名。类名)</p></li><li><p>这个类型直接父类的完整有效名(对于 interface 或是 java.lang.Object，都没有父类)</p></li><li><p>这个类型的修饰符(public，abstract，final 的某个子集)</p></li><li><p>这个类型直接接口的一个有序列表</p></li></ul><h5 id="域-field-信息" tabindex="-1"><a class="header-anchor" href="#域-field-信息" aria-hidden="true">#</a> 域(Field)信息</h5><ul><li><p>JVM 必须在方法区中保存类型的所有域的相关信息以及域的声明顺序</p></li><li><p>域的相关信息包括：域名称、域类型、域修饰符(public、private、protected、static、final、volatile、transient 的某个子集)</p></li></ul><h5 id="方法-method-信息" tabindex="-1"><a class="header-anchor" href="#方法-method-信息" aria-hidden="true">#</a> 方法(Method)信息</h5><p>JVM 必须保存所有方法的</p><ul><li><p>方法名称</p></li><li><p>方法的返回类型</p></li><li><p>方法参数的数量和类型</p></li><li><p>方法的修饰符(public，private，protected，static，final，synchronized，native，abstract 的一个子集)</p></li><li><p>方法的字符码(bytecodes)、操作数栈、局部变量表及大小(abstract 和 native 方法除外)</p></li><li><p>异常表(abstract 和 native 方法除外)</p></li></ul><blockquote><p>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</p></blockquote><hr><h4 id="栈、堆、方法区的交互关系" tabindex="-1"><a class="header-anchor" href="#栈、堆、方法区的交互关系" aria-hidden="true">#</a> 栈、堆、方法区的交互关系</h4><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/20230224003128.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h4 id="运行时常量池" tabindex="-1"><a class="header-anchor" href="#运行时常量池" aria-hidden="true">#</a> 运行时常量池</h4><p>​ 运行时常量池(Runtime Constant Pool)是方法区的一部分，理解运行时常量池的话，我们先来说说字节码文件(Class 文件)中的常量池(常量池表)</p><h5 id="常量池" tabindex="-1"><a class="header-anchor" href="#常量池" aria-hidden="true">#</a> 常量池</h5><p>​ 一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表(Constant Pool Table)，包含各种字面量和对类型、域和方法的符号引用。</p><ul><li>为什么需要常量池？</li></ul><blockquote><p>一个 Java 源文件中的类、接口，编译后产生一个字节码文件。而 Java 中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候用到的就是运行时常量池。</p></blockquote><p>如下，我们通过 jclasslib 查看一个类，字节码中的 <code>#2\`\` #3</code>指向的就是 Constant Pool</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/20230224003240.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/20230224003250.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>​ 常量池可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。</p><hr><h5 id="运行时常量池-1" tabindex="-1"><a class="header-anchor" href="#运行时常量池-1" aria-hidden="true">#</a> 运行时常量池</h5><ul><li><p>在加载类和结构到虚拟机后，就会创建对应的运行时常量池</p></li><li><p>常量池表(Constant Pool Table)是 Class 文件的一部分，用于存储编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中</p></li><li><p>JVM 为每个已加载的类型(类或接口)都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的</p></li><li><p>运行时常量池中包含各种不同的常量，包括编译器就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或字段引用。此时不再是常量池中的符号地址了，这里换为真实地址</p></li></ul><blockquote><p>运行时常量池，相对于 Class 文件常量池的另一个重要特征是：动态性，Java 语言并不要求常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中，String 类的 intern() 方法就是这样的</p></blockquote><ul><li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则 JVM 会抛出 OutOfMemoryError 异常。</li></ul><h4 id="方法区在-jdk6、7、8-中的演进细节" tabindex="-1"><a class="header-anchor" href="#方法区在-jdk6、7、8-中的演进细节" aria-hidden="true">#</a> 方法区在 JDK6、7、8 中的演进细节</h4><p>只有 HotSpot 才有永久代的概念</p><table><thead><tr><th>jdk1.6 及之前</th><th>有永久代，静态变量存放在永久代上</th></tr></thead><tbody><tr><td>jdk1.7</td><td>有永久代，但已经逐步 “去永久代”，字符串常量池、静态变量移除，保存在堆中</td></tr><tr><td>jdk1.8 及之后</td><td>取消永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆中</td></tr></tbody></table><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/20230224003337.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/20230224003345.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/20230224003352.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h5 id="移除永久代原因" tabindex="-1"><a class="header-anchor" href="#移除永久代原因" aria-hidden="true">#</a> 移除永久代原因</h5><ul><li><p>为永久代设置空间大小是很难确定的。 在某些场景下，如果动态加载类过多，容易产生 Perm 区的 OOM。如果某个实际 Web 工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现 OOM。而元空间和永久代最大的区别在于，元空间不在虚拟机中，而是使用本地内存，所以默认情况下，元空间的大小仅受本地内存限制</p></li><li><p>对永久代进行调优较困难</p></li><li><p>JRockit 与 HotSpot 融合后的结果，因为 JRockit 没有永久代，所以 HotSpot 不需要配置永久代。</p></li></ul><h5 id="stringtable" tabindex="-1"><a class="header-anchor" href="#stringtable" aria-hidden="true">#</a> StringTable</h5><ul><li>为什么要调整位置？</li></ul><p>​ jdk7 中将 StringTable 放到了堆空间中。因为永久代的回收效率很低，在 Full GC 的时候才会触发。而 Full GC 是老年代的空间不足、永久代不足时才会触发。这就导致 StringTable 回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p><h6 id="intern" tabindex="-1"><a class="header-anchor" href="#intern" aria-hidden="true">#</a> intern</h6><ul><li>操作符重载</li></ul><blockquote><p>字面量相加会直接拼接，并将结果放入字符串常量池，<strong>不会把参与拼接的常量放入常量池</strong> 其他会调用StringBuilder拼接</p></blockquote><p>intern 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中</p><ul><li>直接使用双引号声明出来的 String 对象会直接存储在常量池中。</li><li>如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法。intern 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;abc&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>是创建了 2 个对象，第一个对象是”abc” 字符串存储在常量池中，第二个对象在 JAVA Heap 中的 String 对象。</p></blockquote><ul><li>JDK7下变化</li></ul><blockquote><ul><li>将String常量池从 Perm 区移动到了 Java Heap 区</li><li>String#intern方法时，如果存在堆中的对象，会直接保存对象的引用，而不会重新创建对象。</li></ul></blockquote><hr><h4 id="方法区的垃圾回收" tabindex="-1"><a class="header-anchor" href="#方法区的垃圾回收" aria-hidden="true">#</a> 方法区的垃圾回收</h4><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</p><p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近 Java 语言层次的常量概念，如文本字符串、被声明为 final 的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p><ul><li><p>类和接口的全限定名</p></li><li><p>字段的名称和描述符</p></li><li><p>方法的名称和描述符</p></li></ul><p>HotSpot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收</p><p>判定一个类型是否属于 “不再被使用的类”，需要同时满足三个条件：</p><ul><li><p>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例</p></li><li><p>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的重加载等，否则通常很难达成</p></li><li><p>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</p></li></ul><p>​ Java 虚拟机被允许堆满足上述三个条件的无用类进行回收，这里说的仅仅是 “被允许”，而并不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot 虚拟机提供了 -Xnoclassgc 参数进行控制，还可以使用 -verbose:class 以及 -XX:+TraceClassLoading 、-XX:+TraceClassUnLoading 查看类加载和卸载信息。</p><p>​ 在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p><hr><h2 id="垃圾回收" tabindex="-1"><a class="header-anchor" href="#垃圾回收" aria-hidden="true">#</a> 垃圾回收</h2><h3 id="动态绑定" tabindex="-1"><a class="header-anchor" href="#动态绑定" aria-hidden="true">#</a> 动态绑定</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">hr<span class="token punctuation">.</span>test</span><span class="token punctuation">;</span>
<span class="token comment">//被调用的父类</span>
<span class="token keyword">class</span> <span class="token class-name">Father</span><span class="token punctuation">{</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;father-f1()&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;father-f1()  para-int &quot;</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//被调用的子类</span>
<span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span><span class="token punctuation">{</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//覆盖父类的方法</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Son-f1()&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Son-s1() para-char &quot;</span><span class="token operator">+</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">//调用方法</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">hr<span class="token punctuation">.</span>test<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AutoCall</span><span class="token punctuation">{</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token class-name">Father</span> father<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//多态</span>
		father<span class="token punctuation">.</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印结果： Son-f1()</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ 上面的源代码中有三个重要的概念：<strong>多态(polymorphism)</strong> 、<strong>方法覆盖 、方法重载</strong> 。打印的结果大家也都比较清楚，但是JVM是如何知道f.f1()调用的是子类Sun中方法而不是Father中的方法呢？在解释这个问题之前，我们首先简单的讲下JVM管理的一个非常重要的数据结构——<strong>方法表</strong> 。</p><p>​ 在JVM加载类的同时，会在方法区中为这个类存放很多信息。其中就有一个数据结构叫方法表。它以数组的形式记录了当前类及其所有超类的可见方法字节码在内存中的直接地址 。下图是上面源代码中Father和Sun类在方法区中的方法表：</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/v2-4b204520e1f41ecc98aa133c8a69a60f_r.jpg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>​ 上图中的方法表有两个特点：(1) 子类方法表中继承了父类的方法，比如Father extends Object。 (2) 相同的方法(相同的方法签名：方法名和参数列表)在所有类的方法表中的索引相同。比如Father方法表中的f1()和Son方法表中的f1()都位于各自方法表的第11项中。</p><blockquote><p>多态调用的字节码指令代码</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token number">0</span>  <span class="token keyword">new</span> <span class="token class-name"><span class="token namespace">hr<span class="token punctuation">.</span>test<span class="token punctuation">.</span></span>Son</span> <span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span> <span class="token comment">// 在堆中开辟一个Son对象的内存空间，并将对象引用压入操作数栈</span>
<span class="token number">3</span>  dup  
<span class="token number">4</span>  invokespecial #<span class="token number">7</span> <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span> <span class="token comment">// 调用初始化方法来初始化堆中的Son对象 </span>
<span class="token number">7</span>  astore_1 <span class="token comment">// 弹出操作数栈的Son对象引用压入局部变量1中</span>
<span class="token number">8</span>  aload_1 <span class="token comment">// 取出局部变量1中的对象引用压入操作数栈</span>
<span class="token number">9</span>  invokevirtual #<span class="token number">15</span> <span class="token comment">// 调用f1()方法</span>
<span class="token number">12</span>  <span class="token keyword">return</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中invokevirtual指令的详细调用过程是这样的：</p><p>(1) invokevirtual指令中的#15指的是AutoCall类的常量池中第15个常量表的索引项。这个常量表(<strong>CONSTATN_Methodref_info</strong> ) 记录的是方法f1信息的符号引用(包括f1所在的类名，方法名和返回类型)。JVM会首先根据这个符号引用找到调用方法f1的类的全限定名: hr.test.Father。这是因为调用方法f1的类的对象father声明为Father类型。</p><p>(2) 在Father类型的方法表中查找方法f1，如果找到，则将方法f1在方法表中的索引项11(如上图)记录到AutoCall类的常量池中第15个常量表中(<strong>常量池解析</strong> )。这里有一点要注意：如果Father类型方法表中没有方法f1，那么即使Son类型中方法表有，编译的时候也通过不了。因为调用方法f1的类的对象father的声明为Father类型。</p><p>(3) 在调用invokevirtual指令前有一个aload_1指令，它会将开始创建在堆中的Son对象的引用压入操作数栈。然后invokevirtual指令会根据这个Son对象的引用首先找到堆中的Son对象，然后进一步找到Son对象所属类型的方法表。过程如下图所示：</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/v2-64d2c9ff6a4780741706daf8bc85f64c_r.jpg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>(4) 这是通过第(2)步中解析完成的#15常量表中的方法表的索引项11，可以定位到Son类型方法表中的方法f1()，然后通过直接地址找到该方法字节码所在的内存空间。</p><p>​ 很明显，根据对象(father)的声明类型(Father)还不能够确定调用方法f1的位置，必须根据father在堆中实际创建的对象类型Son来确定f1方法所在的位置。这种在程序运行过程中，通过动态创建的对象的方法表来定位方法的方式，我们叫做 <strong>动态绑定机制</strong> 。</p><h3 id="类加载器" tabindex="-1"><a class="header-anchor" href="#类加载器" aria-hidden="true">#</a> 类加载器</h3><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/image-20240106212548135.png" style="zoom:50%;"><ul><li><strong>BootstrapClassLoader</strong>：启动类类加载器，它用来加载<code>&lt;JAVA_HOME&gt;/jre/lib</code>路径,<code>-Xbootclasspath</code>参数指定的路径以<code>&lt;JAVA_HOME&gt;/jre/classes</code>中的类。BootStrapClassLoader是由c++实现的。</li><li><strong>ExtClassLoader</strong>：拓展类类加载器，它用来加载<code>&lt;JAVA_HOME&gt;/jre/lib/ext</code>路径以及<code>java.ext.dirs</code>系统变量指定的类路径下的类。</li><li><strong>AppClassLoader</strong>：应用程序类类加载器，它主要加载应用程序ClassPath下的类（包含jar包中的类）。它是java应用程序默认的类加载器。</li><li><strong>用户自定义类加载器</strong>：用户根据自定义需求，自由的定制加载的逻辑，继承AppClassLoader，仅仅覆盖findClass（）即将继续遵守双亲委派模型。</li><li><strong>ThreadContextClassLoader</strong>：线程上下文加载器，它不是一个新的类型，更像一个类加载器的角色，ThreadContextClassLoader可以是上述类加载器的任意一种，但往往是AppClassLoader</li></ul><h4 id="双亲委派机制" tabindex="-1"><a class="header-anchor" href="#双亲委派机制" aria-hidden="true">#</a> 双亲委派机制</h4><p>​ 所谓双亲委派机制，这里要指出的是，其实双亲委派来源于英文的 ”parents delegate“，仅仅表示的只是”父辈“。类加载的时候，把加载的这个动作递归的委托给父辈，由父辈代劳，只有父辈无法加载时，才会由自己加载。</p><h4 id="tomcat的类加载" tabindex="-1"><a class="header-anchor" href="#tomcat的类加载" aria-hidden="true">#</a> Tomcat的类加载</h4><p>Tomcat 自己实现了自己的类加载器 WebAppClassLoader。</p><p>总结一下加载的步骤：</p><ol><li>先在本地cache查找该类是否已经加载过，看看 Tomcat 有没有加载过这个类。</li><li>如果Tomcat 没有加载过这个类，则从系统类加载器的cache中查找是否加载过。</li><li>如果没有加载过这个类，尝试用ExtClassLoader类加载器类加载，重点来了，这里并没有首先使用 AppClassLoader 来加载类。这个Tomcat 的 WebAPPClassLoader 违背了双亲委派机制，直接使用了 ExtClassLoader来加载类。这里注意 ExtClassLoader 双亲委派依然有效，ExtClassLoader 就会使用 Bootstrap ClassLoader 来对类进行加载，保证了 Jre 里面的核心类不会被重复加载。 比如在 Web 中加载一个 Object 类。WebAppClassLoader → ExtClassLoader → Bootstrap ClassLoader，这个加载链，就保证了 Object 不会被重复加载。</li><li>如果 BoostrapClassLoader，没有加载成功，就会调用自己的 findClass 方法由自己来对类进行加载，findClass 加载类的地址是自己本 web 应用下的 class。</li><li><strong>加载依然失败，才使用 AppClassLoader 继续加载。</strong></li><li>都没有加载成功的话，抛出异常。</li></ol><p>总结一下以上步骤，WebAppClassLoader 加载类的时候，故意打破了JVM 双亲委派机制，绕开了 AppClassLoader，直接先使用 ExtClassLoader 来加载类。</p><ul><li>保证了基础类不会被同时加载。</li><li>由保证了在同一个 Tomcat 下不同 web 之间的 class 是相互隔离的。</li></ul><hr><h2 id="jmm内存模型" tabindex="-1"><a class="header-anchor" href="#jmm内存模型" aria-hidden="true">#</a> JMM内存模型</h2><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/Cgq2xl54fTKALhevAAB_l3axT_o532.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>Java 作为高级语言，屏蔽了 L1 缓存、L2 缓存、L3 缓存，也就是多层缓存的这些底层细节，用 JMM 定义了一套读写数据的规范。我们不再需要关心 L1 缓存、L2 缓存、L3 缓存等多层缓存的问题，我们只需要关心 JMM 抽象出来的主内存和工作内存的概念。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/Ciqah154fUGAS19LAAGap07f1AU762.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>​ 主内存和工作内存与JVM内存结构中的Java堆、栈、方法区等并不是同一个层次的内存划分，无法直接类比。《深入理解Java虚拟机》中认为，如果一定要勉强对应起来的话，从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分。工作内存则对应于虚拟机栈中的部分区域。</p><hr><h2 id="gc-roots" tabindex="-1"><a class="header-anchor" href="#gc-roots" aria-hidden="true">#</a> GC ROOTS</h2><ol><li><p>虚拟机栈中引用的对象 比如：各个线程被调用的方法中使用到的参数、局部变量等。</p></li><li><p>本地方法栈内JNI（通常说的本地方法）引用的对象</p></li><li><p>方法区中类静态属性引用的对象 比如：Java类的引用类型静态变量</p></li><li><p>方法区中常量引用的对象 比如：字符串常量池（string Table） 里的引用</p></li><li><p>所有被同步锁synchronized持有的对象</p></li><li><p>Java虚拟机内部的引用。 基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError） ，系统类加载器。</p></li><li><p>反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</p></li><li><p>除了这些固定的GCRoots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：分代收集和局部回收（Partial GC）。 如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性。</p></li></ol><blockquote><p>​ 具体到分两代的分代式GC来说，如果第0代叫做young gen，第1代叫做old gen，那么如果有minor GC / young GC只收集young gen里的垃圾，则young gen属于“收集部分”，而old gen属于“非收集部分”，那么从old gen指向young gen的引用就必须作为minor GC / young GC的GC roots的一部分。</p><p>​ 继续具体到HotSpot VM里的分两代式GC来说，除了old gen到young gen的引用之外，有些带有弱引用语义的结构，例如说记录所有当前被加载的类的SystemDictionary、记录字符串常量引用的StringTable等，在young GC时必须要作为strong GC roots，而在收集整堆的full GC时则不会被看作strong GC roots。</p><p>​ 换句话说，<strong>young GC比full GC的GC roots还要更大一些</strong>。</p></blockquote><h2 id="三色标记" tabindex="-1"><a class="header-anchor" href="#三色标记" aria-hidden="true">#</a> 三色标记</h2><p>​ 根可达算法，从GCRoots 节点开始，使用「标记-清除」算法去实现，但这种方式有一个很大的缺点：整个过程必须「Stop the World」。这就导致整个应用程序必须停止，不能做任何改变，这是非常不友好的。</p><p>为了解决上面「标记-清除」算法的问题，于是就出现了「三色标记算法」！</p><p>​ 三色标记算法指的是将所有对象分为白色、黑色和灰色三种类型。黑色表示从 GCRoots 开始，已扫描过它全部引用的对象，灰色指的是扫描过对象本身，还没完全扫描过它全部引用的对象，白色指的是还没扫描过的对象。</p><p>但仅仅将对象划分成三个颜色还不够，真正关键的是：<strong>实现根可达算法的时候，将整个过程拆分成了初始标记、并发标记、重新标记、并发清除四个阶段。</strong></p><ul><li>初始标记阶段，指的是标记 GCRoots 直接引用的节点，将它们标记为灰色，这个阶段需要 「Stop the World」。</li><li>并发标记阶段，指的是从灰色节点开始，去扫描整个引用链，然后将它们标记为黑色，这个阶段不需要「Stop the World」。</li><li>重新标记阶段，指的是去校正并发标记阶段的错误，这个阶段需要「Stop the World」。</li><li>并发清除，指的是将已经确定为垃圾的对象清除掉，这个阶段不需要「Stop the World」。</li></ul><p>对比一下「四阶段拆分」和「一段式」的实现方式，我们可以看出：<strong>通过将最耗时的引用链扫描剥离出来作为并发标记阶段，将其与用户线程并发执行，从而极大地降低了 GC 停顿时间。</strong> 但 GC 线程与用户线程并发执行，会带来新的问题：对象引用关系可能会发生变化，有可能发生多标和漏标问题。</p><h3 id="多标与漏标问题" tabindex="-1"><a class="header-anchor" href="#多标与漏标问题" aria-hidden="true">#</a> 多标与漏标问题</h3><p><strong>多标问题指的是原本应该回收的对象，被多余地标记为黑色存活对象，从而导致该垃圾对象没有被回收。</strong> 多标问题会出现，是因为在并发标记阶段，有可能之前已经被标记为存活的对象，其引用被删除，从而变成了不可达对象。例如下图中，假设我们现在遍历到了节点 E，此时应用执行了 <code>objD.fieldE = null;</code>。那么此刻之后，对象 E、F、G 应该是被回收的。但因为节点 E 已经是灰色的，那么 E、F、G 节点都会被标记为存活的黑色状态，并不会被回收。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/16588065077599-20240121124837201.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>多标问题会导致内存产生浮动垃圾，但好在其可以再下次 GC 的时候被回收，因此问题还不算很严重。</p><p><strong>漏标问题指的是原本应该被标记为存活的对象，被遗漏标记为黑色，从而导致该垃圾对象被错误回收。</strong> 例如下图中，假设我们现在遍历到了节点 E，此时应用执行如下代码。这时候因为 E 对象没有引用了 G 对象，因此扫描 E 对象的时候并不会将 G 对象标记为黑色存活状态。但由于用户线程的 D 对象引用了 G 对象，这时候 G 对象应该是存活的，应该标记为黑色。但由于 D 对象已经被扫描过了，不会再次扫描，因此 G 对象就被漏标了。</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">var</span></span> G <span class="token operator">=</span> objE<span class="token punctuation">.</span>fieldG<span class="token punctuation">;</span> 
objE<span class="token punctuation">.</span>fieldG <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token comment">// 灰色E 断开引用 白色G </span>
objD<span class="token punctuation">.</span>fieldG <span class="token operator">=</span> G<span class="token punctuation">;</span>  <span class="token comment">// 黑色D 引用 白色G</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/16588069763846.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>漏标问题就非常严重了，其会导致存活对象被回收，会严重影响程序功能。</p><p>那么我们的垃圾回收器是怎么解决这个问题的呢？</p><p>答案是：<strong>增加一个「重新标记」阶段。无论是在 CMS 回收器还是 G1 回收器，它们都在并发标记阶段之后，新增了一个「重新标记」阶段来校正「并发标记」阶段出现的问题。</strong> 只是对于 CMS 回收器和 G1 回收器来说，它们解决的原理不同罢了。</p><h3 id="漏标解决方案" tabindex="-1"><a class="header-anchor" href="#漏标解决方案" aria-hidden="true">#</a> 漏标解决方案</h3><p>正如前面所说，三色标记算法会造成漏标和多标问题。但多标问题相对不是那么严重，而漏标问题才是最严重的。我们经过分析可以知道，漏标问题要发生需要满足如下两个充要条件：</p><ol><li>有至少一个黑色对象在自己被标记之后指向了这个白色对象</li><li>所有的灰色对象在自己引用扫描完成之前删除了对白色对象的引用</li></ol><p>只有当上面两个条件都满足，三色标记算法才会发生漏标的问题。换言之，如果我们破坏任何一个条件，这个白色对象就不会被漏标。<strong>这其实就产生了两种方式，分别是：增量更新、原始快照。CMS 回收器使用的增量更新方案，G1 采用的是原始快照方案。</strong></p><h4 id="cms-解决方案" tabindex="-1"><a class="header-anchor" href="#cms-解决方案" aria-hidden="true">#</a> CMS 解决方案</h4><p><strong>CMS 回收器采用的是增量更新方案，即破坏第一个条件：「有至少一个黑色对象在自己被标记之后指向了这个白色对象」。</strong></p><p>既然有黑色对象在自己标记后，又重新指向了白色对象。那么我就把这个黑色对象的引用记录下来，在后续「重新标记」阶段再以这个黑色对象为根，对其引用进行重新扫描。通过这种方式，被黑色对象引用的白色对象就会变成灰色，从而变为存活状态。</p><p>这种方式有个缺点，就是会重新扫描新增的这部分黑色对象，会浪费多一些时间。但是这段时间相对于并发标记整个链路的扫描，还是小巫见大巫，毕竟真正发生引用变化的黑色对象是比较少的。</p><h4 id="g1-解决方案" tabindex="-1"><a class="header-anchor" href="#g1-解决方案" aria-hidden="true">#</a> G1 解决方案</h4><p><strong>G1 回收器采用的是原始快照的方案，即破坏第二个条件：「所有的灰色对象在自己引用扫描完成之前删除了对白色对象的引用」。</strong></p><p>既然灰色对象在扫描完成前删除了对白色对象的引用，那么我是否能在灰色对象取消引用之前，先将灰色对象引用的白色对象记录下来。随后在「重新标记」阶段再以白色对象为根，对它的引用进行扫描，从而避免了漏标的问题。通过这种方式，原本漏标的对象就会被重新扫描变成灰色，从而变为存活状态。</p><p><strong>这种方式有个缺点，就是会产生浮动垃圾。</strong> 因为当用户线程取消引用的时候，有可能是真的取消引用，对应的对象是真的要回收掉的。这时候我们通过这种方式，就会把本该回收的对象又复活了，从而导致出现浮动垃圾。但相对于本该存活的对象被回收，这个代价还是可以接受的，毕竟在下次 GC 的时候就可以回收了。</p>`,386),i=[p];function o(l,c){return a(),s("div",null,i)}const u=n(t,[["render",o],["__file","JVM.html.vue"]]);export{u as default};
