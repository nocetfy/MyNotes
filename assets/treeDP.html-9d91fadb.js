import{_ as t,X as o,Y as c,Z as n,a0 as s,a1 as e,$ as a,H as l}from"./framework-1ee2252c.js";const i={},u=a('<h1 id="树形dp" tabindex="-1"><a class="header-anchor" href="#树形dp" aria-hidden="true">#</a> 树形DP</h1><p>[toc]</p><h2 id="思考方法" tabindex="-1"><a class="header-anchor" href="#思考方法" aria-hidden="true">#</a> 思考方法</h2><ol><li>分析父树得到答案需要子树的哪些信息</li><li>把子树信息的全集定义成递归返回值</li><li>通过递归让子树返回全集信息</li><li>整合子树的全集信息得到父树的全集信息并返回</li></ol><blockquote><p>树形DP往往在dfs函数中，答案计算和返回值不同，有一种错位感。答案计算会使用通用公式去+-，而返回值返回的是只考虑这棵子树自己本身的最优解。</p></blockquote><h2 id="题目" tabindex="-1"><a class="header-anchor" href="#题目" aria-hidden="true">#</a> 题目</h2><h3 id="树的直径" tabindex="-1"><a class="header-anchor" href="#树的直径" aria-hidden="true">#</a> 树的直径</h3><p>考虑最大值和次大值，注意点和边的区别。</p>',8),r={id:"_543-二叉树的直径",tabindex:"-1"},k=n("a",{class:"header-anchor",href:"#_543-二叉树的直径","aria-hidden":"true"},"#",-1),d={href:"https://leetcode.cn/problems/diameter-of-binary-tree/",target:"_blank",rel:"noopener noreferrer"},m=a(`<p>给你一棵二叉树的根节点，返回该树的 <strong>直径</strong> 。</p><p>二叉树的 <strong>直径</strong> 是指树中任意两个节点之间最长路径的 <strong>长度</strong> 。这条路径可能经过也可能不经过根节点 <code>root</code> 。</p><p>两节点之间路径的 <strong>长度</strong> 由它们之间边数表示。</p><p><strong>示例 1：</strong></p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/diamtree.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>输入：root <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
输出：<span class="token number">3</span>
解释：<span class="token number">3</span> ，取路径 <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span> 或 <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span> 的长度。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>输入：root <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>
输出：<span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[1, 10^4]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><blockquote><p>思路：</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><hr>`,13),b={id:"_124-二叉树中的最大路径和",tabindex:"-1"},g=n("a",{class:"header-anchor",href:"#_124-二叉树中的最大路径和","aria-hidden":"true"},"#",-1),v={href:"https://leetcode.cn/problems/binary-tree-maximum-path-sum/",target:"_blank",rel:"noopener noreferrer"},h=a(`<p>二叉树中的 <strong>路径</strong> 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p><p><strong>示例 1：</strong></p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/exx1.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>输入：root <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
输出：<span class="token number">6</span>
解释：最优路径是 <span class="token number">2</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token number">3</span> ，路径和为 <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">3</span> <span class="token operator">=</span> <span class="token number">6</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/exx2-20240217011509875.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>输入：root <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span>
输出：<span class="token number">42</span>
解释：最优路径是 <span class="token number">15</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token number">20</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token number">7</span> ，路径和为 <span class="token number">15</span> <span class="token operator">+</span> <span class="token number">20</span> <span class="token operator">+</span> <span class="token number">7</span> <span class="token operator">=</span> <span class="token number">42</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li>树中节点数目范围是 <code>[1, 3 * 104]</code></li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><blockquote><p>思路：</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><hr>`,14),f={id:"_2246-相邻字符不同的最长路径",tabindex:"-1"},y=n("a",{class:"header-anchor",href:"#_2246-相邻字符不同的最长路径","aria-hidden":"true"},"#",-1),_={href:"https://leetcode.cn/problems/longest-path-with-different-adjacent-characters/",target:"_blank",rel:"noopener noreferrer"},x=a(`<p>给你一棵 <strong>树</strong>（即一个连通、无向、无环图），根节点是节点 <code>0</code> ，这棵树由编号从 <code>0</code> 到 <code>n - 1</code> 的 <code>n</code> 个节点组成。用下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的数组 <code>parent</code> 来表示这棵树，其中 <code>parent[i]</code> 是节点 <code>i</code> 的父节点，由于节点 <code>0</code> 是根节点，所以 <code>parent[0] == -1</code> 。</p><p>另给你一个字符串 <code>s</code> ，长度也是 <code>n</code> ，其中 <code>s[i]</code> 表示分配给节点 <code>i</code> 的字符。</p><p>请你找出路径上任意一对相邻节点都没有分配到相同字符的 <strong>最长路径</strong> ，并返回该路径的长度。</p><p><strong>示例 1：</strong></p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/testingdrawio-20240217011709995.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>输入：parent <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> s <span class="token operator">=</span> <span class="token string">&quot;abacbe&quot;</span>
输出：<span class="token number">3</span>
解释：任意一对相邻节点字符都不同的最长路径是：<span class="token number">0</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token number">3</span> 。该路径的长度是 <span class="token number">3</span> ，所以返回 <span class="token number">3</span> 。
可以证明不存在满足上述条件且比 <span class="token number">3</span> 更长的路径。 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/graph2drawio-20240217011700096.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>输入：parent <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> s <span class="token operator">=</span> <span class="token string">&quot;aabc&quot;</span>
输出：<span class="token number">3</span>
解释：任意一对相邻节点字符都不同的最长路径是：<span class="token number">2</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token number">3</span> 。该路径的长度为 <span class="token number">3</span> ，所以返回 <span class="token number">3</span> 。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li><code>n == parent.length == s.length</code></li><li><code>1 &lt;= n &lt;= 10^5</code></li><li>对所有 <code>i &gt;= 1</code> ，<code>0 &lt;= parent[i] &lt;= n - 1</code> 均成立</li><li><code>parent[0] == -1</code></li><li><code>parent</code> 表示一棵有效的树</li><li><code>s</code> 仅由小写英文字母组成</li></ul><blockquote><p>思路：</p><p>​</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><hr>`,14),w={id:"_687-最长同值路径",tabindex:"-1"},j=n("a",{class:"header-anchor",href:"#_687-最长同值路径","aria-hidden":"true"},"#",-1),q={href:"https://leetcode.cn/problems/longest-univalue-path/",target:"_blank",rel:"noopener noreferrer"},z=a(`<p>给定一个二叉树的 <code>root</code> ，返回 <em>最长的路径的长度</em> ，这个路径中的 <em>每个节点具有相同值</em> 。 这条路径可以经过也可以不经过根节点。</p><p><strong>两个节点之间的路径长度</strong> 由它们之间的边数表示。</p><p><strong>示例 1:</strong></p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/ex1-20240217011752208.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>输入：root <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
输出：<span class="token number">2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2:</strong></p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/ex2-20240217011804478.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>输入：root <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
输出：<span class="token number">2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示:</strong></p><ul><li>树的节点数的范围是 <code>[0, 10^4]</code></li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li><li>树的深度将不超过 <code>1000</code></li></ul><blockquote><p>思路：</p><p>​</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><hr>`,13),M={id:"_1617-统计子树中城市之间最大距离",tabindex:"-1"},L=n("a",{class:"header-anchor",href:"#_1617-统计子树中城市之间最大距离","aria-hidden":"true"},"#",-1),N={href:"https://leetcode.cn/problems/count-subtrees-with-max-distance-between-cities/",target:"_blank",rel:"noopener noreferrer"},I=a(`<p>给你 <code>n</code> 个城市，编号为从 <code>1</code> 到 <code>n</code> 。同时给你一个大小为 <code>n-1</code> 的数组 <code>edges</code> ，其中 <code>edges[i] = [ui, vi]</code> 表示城市 <code>ui</code> 和 <code>vi</code> 之间有一条双向边。题目保证任意城市之间只有唯一的一条路径。换句话说，所有城市形成了一棵 <strong>树</strong> 。</p><p>一棵 <strong>子树</strong> 是城市的一个子集，且子集中任意城市之间可以通过子集中的其他城市和边到达。两个子树被认为不一样的条件是至少有一个城市在其中一棵子树中存在，但在另一棵子树中不存在。</p><p>对于 <code>d</code> 从 <code>1</code> 到 <code>n-1</code> ，请你找到城市间 <strong>最大距离</strong> 恰好为 <code>d</code> 的所有子树数目。</p><p>请你返回一个大小为 <code>n-1</code> 的数组，其中第 <code>d</code> 个元素（<strong>下标从 1 开始</strong>）是城市间 <strong>最大距离</strong> 恰好等于 <code>d</code> 的子树数目。</p><p><strong>请注意</strong>，两个城市间距离定义为它们之间需要经过的边的数目。</p><p><strong>示例 1：</strong></p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/p1.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>输入：n <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span> edges <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
输出：<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span>
解释：
子树 <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span> 和 <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">}</span> 最大距离都是 <span class="token number">1</span> 。
子树 <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">}</span> 和 <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">}</span> 最大距离都为 <span class="token number">2</span> 。
不存在城市间最大距离为 <span class="token number">3</span> 的子树。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>输入：n <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> edges <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
输出：<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 3：</strong></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>输入：n <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> edges <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
输出：<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li><code>2 &lt;= n &lt;= 15</code></li><li><code>edges.length == n-1</code></li><li><code>edges[i].length == 2</code></li><li><code>1 &lt;= ui, vi &lt;= n</code></li><li>题目保证 <code>(ui, vi)</code> 所表示的边互不相同。</li></ul><blockquote><p>思路：</p><p>​</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><hr>`,17),P={id:"_2538-最大价值和与最小价值和的差值",tabindex:"-1"},A=n("a",{class:"header-anchor",href:"#_2538-最大价值和与最小价值和的差值","aria-hidden":"true"},"#",-1),C={href:"https://leetcode.cn/problems/difference-between-maximum-and-minimum-price-sum/",target:"_blank",rel:"noopener noreferrer"},T=a(`<p>给你一个 <code>n</code> 个节点的无向无根图，节点编号为 <code>0</code> 到 <code>n - 1</code> 。给你一个整数 <code>n</code> 和一个长度为 <code>n - 1</code> 的二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [ai, bi]</code> 表示树中节点 <code>ai</code> 和 <code>bi</code> 之间有一条边。</p><p>每个节点都有一个价值。给你一个整数数组 <code>price</code> ，其中 <code>price[i]</code> 是第 <code>i</code> 个节点的价值。</p><p>一条路径的 <strong>价值和</strong> 是这条路径上所有节点的价值之和。</p><p>你可以选择树中任意一个节点作为根节点 <code>root</code> 。选择 <code>root</code> 为根的 <strong>开销</strong> 是以 <code>root</code> 为起点的所有路径中，<strong>价值和</strong> 最大的一条路径与最小的一条路径的差值。</p><p>请你返回所有节点作为根节点的选择中，<strong>最大</strong> 的 <strong>开销</strong> 为多少。</p><p><strong>示例 1：</strong></p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/example14.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>输入：n <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">,</span> edges <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> price <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
输出：<span class="token number">24</span>
解释：上图展示了以节点 <span class="token number">2</span> 为根的树。左图（红色的节点）是最大价值和路径，右图（蓝色的节点）是最小价值和路径。
<span class="token operator">-</span> 第一条路径节点为 <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>：价值为 <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">]</span> ，价值和为 <span class="token number">31</span> 。
<span class="token operator">-</span> 第二条路径节点为 <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> ，价值为 <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> 。
最大路径和与最小路径和的差值为 <span class="token number">24</span> 。<span class="token number">24</span> 是所有方案中的最大开销。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/p1_example2.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>输入：n <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> edges <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> price <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
输出：<span class="token number">2</span>
解释：上图展示了以节点 <span class="token number">0</span> 为根的树。左图（红色的节点）是最大价值和路径，右图（蓝色的节点）是最小价值和路径。
<span class="token operator">-</span> 第一条路径包含节点 <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>：价值为 <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span> ，价值和为 <span class="token number">3</span> 。
<span class="token operator">-</span> 第二条路径节点为 <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> ，价值为 <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> 。
最大路径和与最小路径和的差值为 <span class="token number">2</span> 。<span class="token number">2</span> 是所有方案中的最大开销。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>edges.length == n - 1</code></li><li><code>0 &lt;= ai, bi &lt;= n - 1</code></li><li><code>edges</code> 表示一棵符合题面要求的树。</li><li><code>price.length == n</code></li><li><code>1 &lt;= price[i] &lt;= 10^5</code></li></ul><blockquote><p>思路：</p><p>​ 树上dp，求树上最大路径和</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">long</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">maxOutput</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edges<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> price<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edge <span class="token operator">:</span> edges<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            map<span class="token punctuation">.</span><span class="token function">computeIfAbsent</span><span class="token punctuation">(</span>edge<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> t <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>edge<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            map<span class="token punctuation">.</span><span class="token function">computeIfAbsent</span><span class="token punctuation">(</span>edge<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> t <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>edge<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">maxOutput</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> map<span class="token punctuation">,</span> price<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> max<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">long</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">maxOutput</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> from<span class="token punctuation">,</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> price<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token keyword">long</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> list1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">long</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                list2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">long</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">!=</span> from<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">long</span><span class="token punctuation">[</span><span class="token punctuation">]</span> next <span class="token operator">=</span> <span class="token function">maxOutput</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> i<span class="token punctuation">,</span> map<span class="token punctuation">,</span> price<span class="token punctuation">)</span><span class="token punctuation">;</span>
                list1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">long</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> j<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                list2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">long</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>next<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> price<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> j<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        list1<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> o<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list2<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> o<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        max <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span>
                list1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> list2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">?</span> list1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> list2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
                        <span class="token operator">:</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>list1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">(</span>list2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">?</span> list2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                        <span class="token punctuation">(</span>list1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">?</span> list1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> list2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token keyword">long</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>list1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> price<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> list2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>`,16),D={id:"_1466-重新规划路线",tabindex:"-1"},S=n("a",{class:"header-anchor",href:"#_1466-重新规划路线","aria-hidden":"true"},"#",-1),V={href:"https://leetcode.cn/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/",target:"_blank",rel:"noopener noreferrer"},H=a(`<p><code>n</code> 座城市，从 <code>0</code> 到 <code>n-1</code> 编号，其间共有 <code>n-1</code> 条路线。因此，要想在两座不同城市之间旅行只有唯一一条路线可供选择（路线网形成一颗树）。去年，交通运输部决定重新规划路线，以改变交通拥堵的状况。</p><p>路线用 <code>connections</code> 表示，其中 <code>connections[i] = [a, b]</code> 表示从城市 <code>a</code> 到 <code>b</code> 的一条有向路线。</p><p>今年，城市 0 将会举办一场大型比赛，很多游客都想前往城市 0 。</p><p>请你帮助重新规划路线方向，使每个城市都可以访问城市 0 。返回需要变更方向的最小路线数。</p><p>题目数据 <strong>保证</strong> 每个城市在重新规划路线方向后都能到达城市 0 。</p><p><strong>示例 1：</strong></p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/sample_1_1819.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>输入：n <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">,</span> connections <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
输出：<span class="token number">3</span>
解释：更改以红色显示的路线的方向，使每个城市都可以到达城市 <span class="token number">0</span> 。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/sample_2_1819.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>输入：n <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> connections <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
输出：<span class="token number">2</span>
解释：更改以红色显示的路线的方向，使每个城市都可以到达城市 <span class="token number">0</span> 。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 3：</strong></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>输入：n <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> connections <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
输出：<span class="token number">0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li><code>2 &lt;= n &lt;= 5 * 10^4</code></li><li><code>connections.length == n-1</code></li><li><code>connections[i].length == 2</code></li><li><code>0 &lt;= connections[i][0], connections[i][1] &lt;= n-1</code></li><li><code>connections[i][0] != connections[i][1]</code></li></ul><blockquote><p>思路：</p><p>​</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><hr><h3 id="树上最大独立集" tabindex="-1"><a class="header-anchor" href="#树上最大独立集" aria-hidden="true">#</a> 树上最大独立集</h3><blockquote><p>重点在于独立，即父亲选了，儿子不能选。但父亲选了，孙子的最优结果是选/不选均可。不要使用贪心让孙子必须选。</p></blockquote>`,20),O={id:"_337-打家劫舍-iii",tabindex:"-1"},B=n("a",{class:"header-anchor",href:"#_337-打家劫舍-iii","aria-hidden":"true"},"#",-1),U={href:"https://leetcode-cn.com/problems/house-robber-iii/",target:"_blank",rel:"noopener noreferrer"},E=a(`<p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 “根”。 除了 “根” 之外，每栋房子有且只有一个 “父 “房子与之相连。一番侦察之后，聪明的小偷意识到 “这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p><p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p><p><strong>示例 1:</strong></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token literal-property property">输入</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>

     <span class="token number">3</span>
    <span class="token operator">/</span> \\
   <span class="token number">2</span>   <span class="token number">3</span>
    \\   \\ 
     <span class="token number">3</span>   <span class="token number">1</span>

<span class="token literal-property property">输出</span><span class="token operator">:</span> <span class="token number">7</span> 
<span class="token literal-property property">解释</span><span class="token operator">:</span> 小偷一晚能够盗取的最高金额 <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">7.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2:</strong></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token literal-property property">输入</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
     <span class="token number">3</span>
    <span class="token operator">/</span> \\
   <span class="token number">4</span>   <span class="token number">5</span>
  <span class="token operator">/</span> \\   \\ 
 <span class="token number">1</span>   <span class="token number">3</span>   <span class="token number">1</span>
<span class="token literal-property property">输出</span><span class="token operator">:</span> <span class="token number">9</span>
<span class="token literal-property property">解释</span><span class="token operator">:</span> 小偷一晚能够盗取的最高金额 <span class="token operator">=</span> <span class="token number">4</span> <span class="token operator">+</span> <span class="token number">5</span> <span class="token operator">=</span> <span class="token number">9.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>思路：</p><ol><li><strong>数组定义:</strong> dp 数组（dp table）以及下标的含义：下标为 0 记录不偷该节点所得到的的最大金钱，下标为 1 记录偷该节点所得到的的最大金钱。</li><li><strong>递归终止条件与数组初始化:</strong> 在遍历的过程中，如果遇到空节点的话，很明显，无论偷还是不偷都是 0，所以就返回</li><li><strong>遍历顺序:</strong> 后序遍历，因为通过递归函数的返回值来做下一步计算。</li><li><strong>单层递归逻辑:</strong> 当前节点偷或不偷。不偷，则可以偷左右节点，分别取左右节点偷或不偷的最大值。<code>max(left[0],left[1]) + max(right[0],right[1])</code>。如果偷，则左右节点都不可以偷，<code>root.val + left[0] + right[0]</code></li></ol></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">rob</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token function">robbery</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">robbery</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> res<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> left <span class="token operator">=</span> <span class="token function">robbery</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> right <span class="token operator">=</span> <span class="token function">robbery</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>left<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>right<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>right<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        res<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> root<span class="token punctuation">.</span>val <span class="token operator">+</span> left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> right<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>`,9),Y={id:"_1377-t-秒后青蛙的位置",tabindex:"-1"},Z=n("a",{class:"header-anchor",href:"#_1377-t-秒后青蛙的位置","aria-hidden":"true"},"#",-1),G={href:"https://leetcode.cn/problems/frog-position-after-t-seconds/",target:"_blank",rel:"noopener noreferrer"},R=a(`<p>给你一棵由 <code>n</code> 个顶点组成的无向树，顶点编号从 <code>1</code> 到 <code>n</code>。青蛙从 <strong>顶点 1</strong> 开始起跳。规则如下：</p><ul><li>在一秒内，青蛙从它所在的当前顶点跳到另一个 <strong>未访问</strong> 过的顶点（如果它们直接相连）。</li><li>青蛙无法跳回已经访问过的顶点。</li><li>如果青蛙可以跳到多个不同顶点，那么它跳到其中任意一个顶点上的机率都相同。</li><li>如果青蛙不能跳到任何未访问过的顶点上，那么它每次跳跃都会停留在原地。</li></ul><p>无向树的边用数组 <code>edges</code> 描述，其中 <code>edges[i] = [ai, bi]</code> 意味着存在一条直接连通 <code>ai</code> 和 <code>bi</code> 两个顶点的边。</p><p>返回青蛙在 <em><code>t</code></em> 秒后位于目标顶点 <em><code>target</code></em> 上的概率。与实际答案相差不超过 <code>10^-5</code> 的结果将被视为正确答案。</p><p><strong>示例 1：</strong></p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/frog1.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>输入：n <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">,</span> edges <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> t <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> target <span class="token operator">=</span> <span class="token number">4</span>
输出：<span class="token number">0.16666666666666666</span> 
解释：上图显示了青蛙的跳跃路径。青蛙从顶点 <span class="token number">1</span> 起跳，第 <span class="token number">1</span> 秒 有 <span class="token number">1</span><span class="token operator">/</span><span class="token number">3</span> 的概率跳到顶点 <span class="token number">2</span> ，然后第 <span class="token number">2</span> 秒 有 <span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span> 的概率跳到顶点 <span class="token number">4</span>，因此青蛙在 <span class="token number">2</span> 秒后位于顶点 <span class="token number">4</span> 的概率是 <span class="token number">1</span><span class="token operator">/</span><span class="token number">3</span> <span class="token operator">*</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">6</span> <span class="token operator">=</span> <span class="token number">0.16666666666666666</span> 。 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/frog2-20240217074900243.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>输入：n <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">,</span> edges <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> t <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> target <span class="token operator">=</span> <span class="token number">7</span>
输出：<span class="token number">0.3333333333333333</span>
解释：上图显示了青蛙的跳跃路径。青蛙从顶点 <span class="token number">1</span> 起跳，有 <span class="token number">1</span><span class="token operator">/</span><span class="token number">3</span> <span class="token operator">=</span> <span class="token number">0.3333333333333333</span> 的概率能够 <span class="token number">1</span> 秒 后跳到顶点 <span class="token number">7</span> 。 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 100</code></li><li><code>edges.length == n - 1</code></li><li><code>edges[i].length == 2</code></li><li><code>1 &lt;= ai, bi &lt;= n</code></li><li><code>1 &lt;= t &lt;= 50</code></li><li><code>1 &lt;= target &lt;= n</code></li></ul><blockquote><p>思路：</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><hr>`,15),X={id:"_2646-最小化旅行的价格总和",tabindex:"-1"},J=n("a",{class:"header-anchor",href:"#_2646-最小化旅行的价格总和","aria-hidden":"true"},"#",-1),K={href:"https://leetcode.cn/problems/minimize-the-total-price-of-the-trips/",target:"_blank",rel:"noopener noreferrer"},W=a(`<p>现有一棵无向、无根的树，树中有 <code>n</code> 个节点，按从 <code>0</code> 到 <code>n - 1</code> 编号。给你一个整数 <code>n</code> 和一个长度为 <code>n - 1</code> 的二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [ai, bi]</code> 表示树中节点 <code>ai</code> 和 <code>bi</code> 之间存在一条边。</p><p>每个节点都关联一个价格。给你一个整数数组 <code>price</code> ，其中 <code>price[i]</code> 是第 <code>i</code> 个节点的价格。</p><p>给定路径的 <strong>价格总和</strong> 是该路径上所有节点的价格之和。</p><p>另给你一个二维整数数组 <code>trips</code> ，其中 <code>trips[i] = [starti, endi]</code> 表示您从节点 <code>starti</code> 开始第 <code>i</code> 次旅行，并通过任何你喜欢的路径前往节点 <code>endi</code> 。</p><p>在执行第一次旅行之前，你可以选择一些 <strong>非相邻节点</strong> 并将价格减半。</p><p>返回执行所有旅行的最小价格总和。</p><p><strong>示例 1：</strong></p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/diagram2-20240217075057779.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>输入：n <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span> edges <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> price <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span> trips <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
输出：<span class="token number">23</span>
解释：
上图表示将节点 <span class="token number">2</span> 视为根之后的树结构。第一个图表示初始树，第二个图表示选择节点 <span class="token number">0</span> 、<span class="token number">2</span> 和 <span class="token number">3</span> 并使其价格减半后的树。
第 <span class="token number">1</span> 次旅行，选择路径 <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span> 。路径的价格总和为 <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">3</span> <span class="token operator">=</span> <span class="token number">6</span> 。
第 <span class="token number">2</span> 次旅行，选择路径 <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span> 。路径的价格总和为 <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">5</span> <span class="token operator">=</span> <span class="token number">7</span> 。
第 <span class="token number">3</span> 次旅行，选择路径 <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span> 。路径的价格总和为 <span class="token number">5</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">3</span> <span class="token operator">=</span> <span class="token number">10</span> 。
所有旅行的价格总和为 <span class="token number">6</span> <span class="token operator">+</span> <span class="token number">7</span> <span class="token operator">+</span> <span class="token number">10</span> <span class="token operator">=</span> <span class="token number">23</span> 。可以证明，<span class="token number">23</span> 是可以实现的最小答案。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/diagram3.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>输入：n <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> edges <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> price <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> trips <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
输出：<span class="token number">1</span>
解释：
上图表示将节点 <span class="token number">0</span> 视为根之后的树结构。第一个图表示初始树，第二个图表示选择节点 <span class="token number">0</span> 并使其价格减半后的树。 
第 <span class="token number">1</span> 次旅行，选择路径 <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> 。路径的价格总和为 <span class="token number">1</span> 。 
所有旅行的价格总和为 <span class="token number">1</span> 。可以证明，<span class="token number">1</span> 是可以实现的最小答案。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 50</code></li><li><code>edges.length == n - 1</code></li><li><code>0 &lt;= ai, bi &lt;= n - 1</code></li><li><code>edges</code> 表示一棵有效的树</li><li><code>price.length == n</code></li><li><code>price[i]</code> 是一个偶数</li><li><code>1 &lt;= price[i] &lt;= 1000</code></li><li><code>1 &lt;= trips.length &lt;= 100</code></li><li><code>0 &lt;= starti, endi &lt;= n - 1</code></li></ul><blockquote><p>思路：</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><hr>`,17),$={id:"p1352-没有上司的舞会",tabindex:"-1"},F=n("a",{class:"header-anchor",href:"#p1352-没有上司的舞会","aria-hidden":"true"},"#",-1),Q={href:"https://www.luogu.com.cn/problem/P1352",target:"_blank",rel:"noopener noreferrer"},nn=n("p",null,[s("某大学有 "),n("code",null,"n"),s(" 个职员，编号为"),n("code",null,"1……n"),s("。")],-1),sn=n("p",null,"他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。",-1),an=n("p",null,[s("现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数"),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("msub",null,[n("mi",null,"r"),n("mi",null,"i")])]),n("annotation",{encoding:"application/x-tex"},"r_i")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.5806em","vertical-align":"-0.15em"}}),n("span",{class:"mord"},[n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"r"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t vlist-t2"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.3117em"}},[n("span",{style:{top:"-2.55em","margin-left":"-0.0278em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mathnormal mtight"},"i")])])]),n("span",{class:"vlist-s"},"​")]),n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.15em"}},[n("span")])])])])])])])]),s("，但是呢，如果某个职员的直接上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。")],-1),pn=n("p",null,"所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。",-1),en=n("ul",null,[n("li",null,"输入格式")],-1),tn=n("p",null,[s("输入的第一行是一个整数"),n("code",null,"n"),s("。")],-1),on=n("p",null,[s("第 "),n("code",null,"2"),s(" 到第 "),n("code",null,"n+1"),s(" 行，每行一个整数，第"),n("code",null,"(i+1)"),s("行的整数表示 "),n("code",null,"i"),s(" 号职员的快乐指数"),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("msub",null,[n("mi",null,"r"),n("mi",null,"i")])]),n("annotation",{encoding:"application/x-tex"},"r_i")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.5806em","vertical-align":"-0.15em"}}),n("span",{class:"mord"},[n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"r"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t vlist-t2"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.3117em"}},[n("span",{style:{top:"-2.55em","margin-left":"-0.0278em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mathnormal mtight"},"i")])])]),n("span",{class:"vlist-s"},"​")]),n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.15em"}},[n("span")])])])])])])])]),s("。")],-1),cn=a(`<p>第 <code>n+2</code> 到第<code>2n</code> 行，每行输入一对整数<code>l,k</code>，代表<code>k</code>是<code>l</code>的直接上司。</p><ul><li>输出格式</li></ul><p>输出一行一个整数代表最大的快乐指数。</p><ul><li>输入输出样例</li></ul><p><strong>输入 #1</strong></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token number">7</span>
<span class="token number">1</span>
<span class="token number">1</span>
<span class="token number">1</span>
<span class="token number">1</span>
<span class="token number">1</span>
<span class="token number">1</span>
<span class="token number">1</span>
<span class="token number">1</span> <span class="token number">3</span>
<span class="token number">2</span> <span class="token number">3</span>
<span class="token number">6</span> <span class="token number">4</span>
<span class="token number">7</span> <span class="token number">4</span>
<span class="token number">4</span> <span class="token number">5</span>
<span class="token number">3</span> <span class="token number">5</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>输出 #1</strong></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token number">5</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>数据规模与约定</li></ul>`,9),ln=n("p",null,[s("对于 100%的数据，保证"),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mn",null,"1"),n("mo",null,"≤"),n("mi",null,"n"),n("mo",null,"≤"),n("mn",null,"6"),n("mo",null,"×"),n("mn",null,"1"),n("msup",null,[n("mn",null,"0"),n("mn",null,"3")])]),n("annotation",{encoding:"application/x-tex"},"1\\le n \\le6\\times10^3")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.7804em","vertical-align":"-0.136em"}}),n("span",{class:"mord"},"1"),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),n("span",{class:"mrel"},"≤"),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.7719em","vertical-align":"-0.136em"}}),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),n("span",{class:"mrel"},"≤"),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.7278em","vertical-align":"-0.0833em"}}),n("span",{class:"mord"},"6"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),n("span",{class:"mbin"},"×"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.8141em"}}),n("span",{class:"mord"},"1"),n("span",{class:"mord"},[n("span",{class:"mord"},"0"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.8141em"}},[n("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mtight"},"3")])])])])])])])])])]),s("，"),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mo",null,"−"),n("mn",null,"128"),n("mo",null,"≤"),n("msub",null,[n("mi",null,"r"),n("mi",null,"i")]),n("mo",null,"≤"),n("mn",null,"127")]),n("annotation",{encoding:"application/x-tex"},"-128\\le r_i\\le 127")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.7804em","vertical-align":"-0.136em"}}),n("span",{class:"mord"},"−"),n("span",{class:"mord"},"128"),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),n("span",{class:"mrel"},"≤"),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.786em","vertical-align":"-0.15em"}}),n("span",{class:"mord"},[n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"r"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t vlist-t2"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.3117em"}},[n("span",{style:{top:"-2.55em","margin-left":"-0.0278em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mathnormal mtight"},"i")])])]),n("span",{class:"vlist-s"},"​")]),n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.15em"}},[n("span")])])])])]),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),n("span",{class:"mrel"},"≤"),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.6444em"}}),n("span",{class:"mord"},"127")])])]),s("，"),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mn",null,"1"),n("mo",null,"≤"),n("mi",null,"k")]),n("annotation",{encoding:"application/x-tex"},"1\\le k")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.7804em","vertical-align":"-0.136em"}}),n("span",{class:"mord"},"1"),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),n("span",{class:"mrel"},"≤"),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.6944em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.03148em"}},"k")])])]),s("，"),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"k"),n("mo",null,"≤"),n("mi",null,"n")]),n("annotation",{encoding:"application/x-tex"},"k\\le n")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.8304em","vertical-align":"-0.136em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.03148em"}},"k"),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),n("span",{class:"mrel"},"≤"),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.4306em"}}),n("span",{class:"mord mathnormal"},"n")])])]),s("​且给出的关系一定是一棵树。")],-1),un=a(`<blockquote><p>思路：</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><hr><h3 id="树上最小支配集" tabindex="-1"><a class="header-anchor" href="#树上最小支配集" aria-hidden="true">#</a> 树上最小支配集</h3><blockquote><p>监控问题，最终可以转化成3部分：</p><ol><li>我装监控了，那儿子们状态无所谓，最小就可以用儿子树的树根装监控的代价/我辐射的代价/孙子辐射的代价 取最小值</li><li>我父亲装监控了，那我本身被辐射，儿子无法被我辐射，用儿子树的树根装监控的代价/孙子辐射的代价 取最小值</li><li>我儿子装监控了，同样，儿子无法被我辐射。此时需要至少一个儿子装监控。思考发现，和情况2的差别就是，必须至少选一个儿子装监控，则可以计算儿子树的树根装监控的代价 - 孙子辐射的代价的最小值，加到情况2去。如果最小值&lt;=0。则等效于情况2(本身某儿子就会装)</li></ol><p>可以发现，情况1也可以化简，儿子辐射&gt;=父亲辐射。只取后者计算即可。</p></blockquote>`,5),rn={id:"_968-监控二叉树",tabindex:"-1"},kn=n("a",{class:"header-anchor",href:"#_968-监控二叉树","aria-hidden":"true"},"#",-1),dn={href:"https://leetcode-cn.com/problems/binary-tree-cameras/",target:"_blank",rel:"noopener noreferrer"},mn=a(`<p>给定一个二叉树，我们在树的节点上安装摄像头。</p><p>节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象。</strong></p><p>计算监控树的所有节点所需的最小摄像头数量。</p><p><strong>示例 1：</strong></p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/6quszcLDYfmVkr2.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>输入：<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span>
输出：<span class="token number">1</span>
解释：如图所示，一台摄像头足以监控所有节点。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/pcXL7RAbnVTS5hq.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>输入：<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span>
输出：<span class="token number">2</span>
解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>思路：</p><p>​ 三个数字代表三种状态</p><ul><li>0：该节点无覆盖</li><li>1：本节点有摄像头</li><li>2：本节点有覆盖</li></ul></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code> <span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minCameraCover</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 情况4 root无覆盖，需要加1个</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">trval</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> count<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> count<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">trval</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>

        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token function">travl</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 左</span>
        <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token function">travl</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 右</span>

        <span class="token comment">// 情况1</span>
        <span class="token comment">// 左右节点都有覆盖</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token comment">// 情况2</span>
        <span class="token comment">// left == 0 &amp;&amp; right == 0 左右节点无覆盖</span>
        <span class="token comment">// left == 1 &amp;&amp; right == 0 左节点有摄像头，右节点无覆盖</span>
        <span class="token comment">// left == 0 &amp;&amp; right == 1 左节点有无覆盖，右节点摄像头</span>
        <span class="token comment">// left == 0 &amp;&amp; right == 2 左节点无覆盖，右节点覆盖</span>
        <span class="token comment">// left == 2 &amp;&amp; right == 0 左节点覆盖，右节点无覆盖</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> right <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            count<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 情况3</span>
        <span class="token comment">// left == 1 &amp;&amp; right == 2 左节点有摄像头，右节点有覆盖</span>
        <span class="token comment">// left == 2 &amp;&amp; right == 1 左节点有覆盖，右节点有摄像头</span>
        <span class="token comment">// left == 1 &amp;&amp; right == 1 左右节点都有摄像头</span>
        <span class="token comment">// 其他情况前段代码均已覆盖</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> right <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>

        <span class="token comment">// 以上代码我没有使用else，主要是为了把各个分支条件展现出来，这样代码有助于读者理解</span>
        <span class="token comment">// 这个 return -1 逻辑不会走到这里。</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>`,12),bn={id:"p2458-保安站岗",tabindex:"-1"},gn=n("a",{class:"header-anchor",href:"#p2458-保安站岗","aria-hidden":"true"},"#",-1),vn={href:"https://www.luogu.com.cn/problem/P2458",target:"_blank",rel:"noopener noreferrer"},hn=a("<p>五一来临，某地下超市为了便于疏通和指挥密集的人员和车辆，以免造成超市内的混乱和拥挤，准备临时从外单位调用部分保安来维持交通秩序。</p><p>已知整个地下超市的所有通道呈一棵树的形状；某些通道之间可以互相望见。总经理要求所有通道的每个端点（树的顶点）都要有人全天候看守，在不同的通道端点安排保安所需的费用不同。</p><p>一个保安一旦站在某个通道的其中一个端点，那么他除了能看守住他所站的那个端点，也能看到这个通道的另一个端点，所以一个保安可能同时能看守住多个端点（树的结点），因此没有必要在每个通道的端点都安排保安。</p><p>编程任务：</p><p>请你帮助超市经理策划安排，在能看守全部通道端点的前提下，使得花费的经费最少。</p><ul><li>输入格式</li></ul><p>第 <code>1</code> 行 <code>n</code>，表示树中结点的数目。</p>",7),fn=n("p",null,[s("第"),n("code",null,"2"),s(" 行至第 "),n("code",null,"n+1"),s(" 行，每行描述每个通道端点的信息，依次为：该结点标号"),n("code",null,"i"),s("("),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mn",null,"0"),n("mo",null,"<"),n("mi",null,"i"),n("mo",null,"≤"),n("mi",null,"n")]),n("annotation",{encoding:"application/x-tex"},"0\\lt i\\le n")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.6835em","vertical-align":"-0.0391em"}}),n("span",{class:"mord"},"0"),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),n("span",{class:"mrel"},"<"),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.7955em","vertical-align":"-0.136em"}}),n("span",{class:"mord mathnormal"},"i"),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),n("span",{class:"mrel"},"≤"),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.4306em"}}),n("span",{class:"mord mathnormal"},"n")])])]),s(")，在该结点安置保安所需的经费"),n("code",null,"k"),s("(≤10000），该边的儿子数"),n("code",null,"m"),s("，接下来"),n("code",null,"m"),s("个数，分别是这个节点的"),n("code",null,"m"),s("个儿子的标号"),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("msub",null,[n("mi",null,"r"),n("mn",null,"1")]),n("mo",{separator:"true"},","),n("msub",null,[n("mi",null,"r"),n("mn",null,"2")]),n("mo",{separator:"true"},","),n("mi",{mathvariant:"normal"},"."),n("mi",{mathvariant:"normal"},"."),n("mi",{mathvariant:"normal"},"."),n("mo",{separator:"true"},","),n("msub",null,[n("mi",null,"r"),n("mi",null,"m")])]),n("annotation",{encoding:"application/x-tex"},"r_1,r_2,...,r_m")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.625em","vertical-align":"-0.1944em"}}),n("span",{class:"mord"},[n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"r"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t vlist-t2"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.3011em"}},[n("span",{style:{top:"-2.55em","margin-left":"-0.0278em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mtight"},"1")])])]),n("span",{class:"vlist-s"},"​")]),n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.15em"}},[n("span")])])])])]),n("span",{class:"mpunct"},","),n("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),n("span",{class:"mord"},[n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"r"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t vlist-t2"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.3011em"}},[n("span",{style:{top:"-2.55em","margin-left":"-0.0278em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mtight"},"2")])])]),n("span",{class:"vlist-s"},"​")]),n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.15em"}},[n("span")])])])])]),n("span",{class:"mpunct"},","),n("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),n("span",{class:"mord"},"..."),n("span",{class:"mpunct"},","),n("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),n("span",{class:"mord"},[n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"r"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t vlist-t2"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.1514em"}},[n("span",{style:{top:"-2.55em","margin-left":"-0.0278em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mathnormal mtight"},"m")])])]),n("span",{class:"vlist-s"},"​")]),n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.15em"}},[n("span")])])])])])])])]),s("。")],-1),yn=n("p",null,[s("对于一个 "),n("code",null,"n"),s(" ("),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mn",null,"0"),n("mo",null,"<"),n("mi",null,"n"),n("mo",null,"≤"),n("mn",null,"1500")]),n("annotation",{encoding:"application/x-tex"},"0\\lt n\\le1500")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.6835em","vertical-align":"-0.0391em"}}),n("span",{class:"mord"},"0"),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),n("span",{class:"mrel"},"<"),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.7719em","vertical-align":"-0.136em"}}),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),n("span",{class:"mrel"},"≤"),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.6444em"}}),n("span",{class:"mord"},"1500")])])]),s(")个结点的树，结点标号在 "),n("code",null,"1"),s(" 到"),n("code",null,"n"),s("之间，且标号不重复。")],-1),_n=a(`<ul><li>输出格式</li></ul><p>输出一行一个整数，表示最少的经费。</p><ul><li>输入输出样例</li></ul><p><strong>输入 #1</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>6
1 30 3 2 3 4
2 16 2 5 6
3 5 0
4 4 0
5 11 0
6 5 0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>输出 #1</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>25
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/g013tlmh.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在结点 2，3，4 安置3个保安能看守所有的 6 个结点，需要的经费最小：25。</p><blockquote><p>思路：</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><hr>`,12),xn={id:"lcp-34-二叉树染色",tabindex:"-1"},wn=n("a",{class:"header-anchor",href:"#lcp-34-二叉树染色","aria-hidden":"true"},"#",-1),jn={href:"https://leetcode.cn/problems/er-cha-shu-ran-se-UGC/",target:"_blank",rel:"noopener noreferrer"},qn=a(`<p>小扣有一个根结点为 <code>root</code> 的二叉树模型，初始所有结点均为白色，可以用蓝色染料给模型结点染色，模型的每个结点有一个 <code>val</code> 价值。小扣出于美观考虑，希望最后二叉树上每个蓝色相连部分的结点个数不能超过 <code>k</code> 个，求所有染成蓝色的结点价值总和最大是多少？</p><p><strong>示例 1：</strong></p><blockquote><p>输入：<code>root = [5,2,3,4], k = 2</code></p><p>输出：<code>12</code></p><p>解释：<code>结点 5、3、4 染成蓝色，获得最大的价值 5+3+4=12</code><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/1616126267-BqaCRj-image.png" alt="" loading="lazy"></p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：<code>root = [4,1,3,9,null,null,2], k = 2</code></p><p>输出：<code>16</code></p><p>解释：结点 4、3、9 染成蓝色，获得最大的价值 4+3+9=16<img src="https://raw.githubusercontent.com/nocetfy/image/main/img/1616126301-gJbhba-image-20240217080704447.png" alt="" loading="lazy"></p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= k &lt;= 10</code></li><li><code>1 &lt;= val &lt;= 10000</code></li><li><code>1 &lt;= 结点数量 &lt;= 10000</code></li></ul><blockquote><p>思路：</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><hr>`,10),zn={id:"lcp-64-二叉树灯饰",tabindex:"-1"},Mn=n("a",{class:"header-anchor",href:"#lcp-64-二叉树灯饰","aria-hidden":"true"},"#",-1),Ln={href:"https://leetcode.cn/problems/U7WvvU/",target:"_blank",rel:"noopener noreferrer"},Nn=a(`<p>「力扣嘉年华」的中心广场放置了一个巨型的二叉树形状的装饰树。每个节点上均有一盏灯和三个开关。节点值为 <code>0</code> 表示灯处于「关闭」状态，节点值为 <code>1</code> 表示灯处于「开启」状态。每个节点上的三个开关各自功能如下：</p><ul><li>开关 <code>1</code>：切换当前节点的灯的状态；</li><li>开关 <code>2</code>：切换 <strong>以当前节点为根</strong> 的子树中，所有节点上的灯的状态；</li><li>开关 <code>3</code>：切换 <strong>当前节点及其左右子节点</strong>（若存在的话） 上的灯的状态；</li></ul><p>给定该装饰的初始状态 <code>root</code>，请返回最少需要操作多少次开关，可以关闭所有节点的灯。</p><p><strong>示例 1：</strong></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>输入：root <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
输出：<span class="token number">2</span>
解释：以下是最佳的方案之一，如图所示
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/1629357030-GSbzpY-b71b95bf405e3b223e00b2820a062ba4.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>示例 2：</strong></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>输入：root <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
输出：<span class="token number">1</span>
解释：以下是最佳的方案，如图所示
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/1629356950-HZsKZC-a4091b6448a0089b4d9e8f0390ff9ac6.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>示例 3：</strong></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>输入：root <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span>
输出：<span class="token number">0</span>
解释：无需操作开关，当前所有节点上的灯均已关闭
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li><code>1 &lt;= 节点个数 &lt;= 10^5</code></li><li><code>0 &lt;= Node.val &lt;= 1</code></li></ul><blockquote><p>思路：</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><hr><h3 id="其他题目" tabindex="-1"><a class="header-anchor" href="#其他题目" aria-hidden="true">#</a> 其他题目</h3>`,17),In={id:"_2458-移除子树后的二叉树高度",tabindex:"-1"},Pn=n("a",{class:"header-anchor",href:"#_2458-移除子树后的二叉树高度","aria-hidden":"true"},"#",-1),An={href:"https://leetcode.cn/problems/height-of-binary-tree-after-subtree-removal-queries/",target:"_blank",rel:"noopener noreferrer"},Cn=a(`<p>给你一棵 <strong>二叉树</strong> 的根节点 <code>root</code> ，树中有 <code>n</code> 个节点。每个节点都可以被分配一个从 <code>1</code> 到 <code>n</code> 且互不相同的值。另给你一个长度为 <code>m</code> 的数组 <code>queries</code> 。</p><p>你必须在树上执行 <code>m</code> 个 <strong>独立</strong> 的查询，其中第 <code>i</code> 个查询你需要执行以下操作：</p><ul><li>从树中 <strong>移除</strong> 以 <code>queries[i]</code> 的值作为根节点的子树。题目所用测试用例保证 <code>queries[i]</code> <strong>不</strong> 等于根节点的值。</li></ul><p>返回一个长度为 <code>m</code> 的数组 <code>answer</code> ，其中 <code>answer[i]</code> 是执行第 <code>i</code> 个查询后树的高度。</p><p><strong>注意：</strong></p><ul><li>查询之间是独立的，所以在每个查询执行后，树会回到其 <strong>初始</strong> 状态。</li><li>树的高度是从根到树中某个节点的 <strong>最长简单路径中的边数</strong> 。</li></ul><p><strong>示例 1：</strong></p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/binaryytreeedrawio-1-20240217095758516.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>输入：root <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span> queries <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span>
输出：<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>
解释：上图展示了从树中移除以 <span class="token number">4</span> 为根节点的子树。
树的高度是 <span class="token number">2</span>（路径为 <span class="token number">1</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token number">3</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token number">2</span>）。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/binaryytreeedrawio-2.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>输入：root <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span> queries <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">]</span>
输出：<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>
解释：执行下述查询：
<span class="token operator">-</span> 移除以 <span class="token number">3</span> 为根节点的子树。树的高度变为 <span class="token number">3</span>（路径为 <span class="token number">5</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token number">8</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token number">2</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token number">4</span>）。
<span class="token operator">-</span> 移除以 <span class="token number">2</span> 为根节点的子树。树的高度变为 <span class="token number">2</span>（路径为 <span class="token number">5</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token number">8</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token number">1</span>）。
<span class="token operator">-</span> 移除以 <span class="token number">4</span> 为根节点的子树。树的高度变为 <span class="token number">3</span>（路径为 <span class="token number">5</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token number">8</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token number">2</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token number">6</span>）。
<span class="token operator">-</span> 移除以 <span class="token number">8</span> 为根节点的子树。树的高度变为 <span class="token number">2</span>（路径为 <span class="token number">5</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token number">9</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token number">3</span>）。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li>树中节点的数目是 <code>n</code></li><li><code>2 &lt;= n &lt;= 10^5</code></li><li><code>1 &lt;= Node.val &lt;= n</code></li><li>树中的所有值 <strong>互不相同</strong></li><li><code>m == queries.length</code></li><li><code>1 &lt;= m &lt;= min(n, 10^4)</code></li><li><code>1 &lt;= queries[i] &lt;= n</code></li><li><code>queries[i] != root.val</code></li></ul><blockquote><p>思路：</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><hr>`,17),Tn={id:"_2920-收集所有金币可获得的最大积分",tabindex:"-1"},Dn=n("a",{class:"header-anchor",href:"#_2920-收集所有金币可获得的最大积分","aria-hidden":"true"},"#",-1),Sn={href:"https://leetcode.cn/problems/maximum-points-after-collecting-coins-from-all-nodes/",target:"_blank",rel:"noopener noreferrer"},Vn=a(`<p>有一棵由 <code>n</code> 个节点组成的无向树，以 <code>0</code> 为根节点，节点编号从 <code>0</code> 到 <code>n - 1</code> 。给你一个长度为 <code>n - 1</code> 的二维 <strong>整数</strong> 数组 <code>edges</code> ，其中 <code>edges[i] = [ai, bi]</code> 表示在树上的节点 <code>ai</code> 和 <code>bi</code> 之间存在一条边。另给你一个下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的数组 <code>coins</code> 和一个整数 <code>k</code> ，其中 <code>coins[i]</code> 表示节点 <code>i</code> 处的金币数量。</p><p>从根节点开始，你必须收集所有金币。要想收集节点上的金币，必须先收集该节点的祖先节点上的金币。</p><p>节点 <code>i</code> 上的金币可以用下述方法之一进行收集：</p><ul><li>收集所有金币，得到共计 <code>coins[i] - k</code> 点积分。如果 <code>coins[i] - k</code> 是负数，你将会失去 <code>abs(coins[i] - k)</code> 点积分。</li><li>收集所有金币，得到共计 <code>floor(coins[i] / 2)</code> 点积分。如果采用这种方法，节点 <code>i</code> 子树中所有节点 <code>j</code> 的金币数 <code>coins[j]</code> 将会减少至 <code>floor(coins[j] / 2)</code> 。</li></ul><p>返回收集 <strong>所有</strong> 树节点的金币之后可以获得的最大积分。</p><p><strong>示例 1：</strong></p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/ex1-copy.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>输入：edges <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> coins <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">5</span>
输出：<span class="token number">11</span>                        
解释：
使用第一种方法收集节点 <span class="token number">0</span> 上的所有金币。总积分 <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">-</span> <span class="token number">5</span> <span class="token operator">=</span> <span class="token number">5</span> 。
使用第一种方法收集节点 <span class="token number">1</span> 上的所有金币。总积分 <span class="token operator">=</span> <span class="token number">5</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">-</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">10</span> 。
使用第二种方法收集节点 <span class="token number">2</span> 上的所有金币。所以节点 <span class="token number">3</span> 上的金币将会变为 <span class="token function">floor</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span> ，总积分 <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token function">floor</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">11</span> 。
使用第二种方法收集节点 <span class="token number">3</span> 上的所有金币。总积分 <span class="token operator">=</span>  <span class="token number">11</span> <span class="token operator">+</span> <span class="token function">floor</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">11.</span>
可以证明收集所有节点上的金币能获得的最大积分是 <span class="token number">11</span> 。 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/ex2.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>输入：edges <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> coins <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">0</span>
输出：<span class="token number">16</span>
解释：
使用第一种方法收集所有节点上的金币，因此，总积分 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">8</span> <span class="token operator">-</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">-</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">-</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">16</span> 。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li><code>n == coins.length</code></li><li><code>2 &lt;= n &lt;= 10^5</code></li><li><code>0 &lt;= coins[i] &lt;= 10^4</code></li><li><code>edges.length == n - 1</code></li><li><code>0 &lt;= edges[i][0], edges[i][1] &lt; n</code></li><li><code>0 &lt;= k &lt;= 10^4</code></li></ul><blockquote><p>思路：</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><hr>`,16),Hn={id:"_2925-在树上执行操作以后得到的最大分数",tabindex:"-1"},On=n("a",{class:"header-anchor",href:"#_2925-在树上执行操作以后得到的最大分数","aria-hidden":"true"},"#",-1),Bn={href:"https://leetcode.cn/problems/maximum-score-after-applying-operations-on-a-tree/",target:"_blank",rel:"noopener noreferrer"},Un=a(`<p>有一棵 <code>n</code> 个节点的无向树，节点编号为 <code>0</code> 到 <code>n - 1</code> ，根节点编号为 <code>0</code> 。给你一个长度为 <code>n - 1</code> 的二维整数数组 <code>edges</code> 表示这棵树，其中 <code>edges[i] = [ai, bi]</code> 表示树中节点 <code>ai</code> 和 <code>bi</code> 有一条边。</p><p>同时给你一个长度为 <code>n</code> 下标从 <strong>0</strong> 开始的整数数组 <code>values</code> ，其中 <code>values[i]</code> 表示第 <code>i</code> 个节点的值。</p><p>一开始你的分数为 <code>0</code> ，每次操作中，你将执行：</p><ul><li>选择节点 <code>i</code> 。</li><li>将 <code>values[i]</code> 加入你的分数。</li><li>将 <code>values[i]</code> 变为 <code>0</code> 。</li></ul><p>如果从根节点出发，到任意叶子节点经过的路径上的节点值之和都不等于 0 ，那么我们称这棵树是 <strong>健康的</strong> 。</p><p>你可以对这棵树执行任意次操作，但要求执行完所有操作以后树是 <strong>健康的</strong> ，请你返回你可以获得的 <strong>最大分数</strong> 。</p><p><strong>示例 1：</strong></p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/graph-13-1-20240217100507207.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>输入：edges <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> values <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
输出：<span class="token number">11</span>
解释：我们可以选择节点 <span class="token number">1</span> ，<span class="token number">2</span> ，<span class="token number">3</span> ，<span class="token number">4</span> 和 <span class="token number">5</span> 。根节点的值是非 <span class="token number">0</span> 的。所以从根出发到任意叶子节点路径上节点值之和都不为 <span class="token number">0</span> 。所以树是健康的。你的得分之和为 values<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> values<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> values<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">+</span> values<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">+</span> values<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">11</span> 。
<span class="token number">11</span> 是你对树执行任意次操作以后可以获得的最大得分之和。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/graph-14-2.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>输入：edges <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> values <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
输出：<span class="token number">40</span>
解释：我们选择节点 <span class="token number">0</span> ，<span class="token number">2</span> ，<span class="token number">3</span> 和 <span class="token number">4</span> 。
<span class="token operator">-</span> 从 <span class="token number">0</span> 到 <span class="token number">4</span> 的节点值之和为 <span class="token number">10</span> 。
<span class="token operator">-</span> 从 <span class="token number">0</span> 到 <span class="token number">3</span> 的节点值之和为 <span class="token number">10</span> 。
<span class="token operator">-</span> 从 <span class="token number">0</span> 到 <span class="token number">5</span> 的节点值之和为 <span class="token number">3</span> 。
<span class="token operator">-</span> 从 <span class="token number">0</span> 到 <span class="token number">6</span> 的节点值之和为 <span class="token number">5</span> 。
所以树是健康的。你的得分之和为 values<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> values<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> values<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">+</span> values<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">40</span> 。
<span class="token number">40</span> 是你对树执行任意次操作以后可以获得的最大得分之和。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li><code>2 &lt;= n &lt;= 2 * 10^4</code></li><li><code>edges.length == n - 1</code></li><li><code>edges[i].length == 2</code></li><li><code>0 &lt;= ai, bi &lt; n</code></li><li><code>values.length == n</code></li><li><code>1 &lt;= values[i] &lt;= 10^9</code></li><li>输入保证 <code>edges</code> 构成一棵合法的树。</li></ul><blockquote><p>思路：</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><hr>`,17);function En(Yn,Zn){const p=l("ExternalLinkIcon");return o(),c("div",null,[u,n("h4",r,[k,s(),n("a",d,[s("543. 二叉树的直径"),e(p)])]),m,n("h4",b,[g,s(),n("a",v,[s("124. 二叉树中的最大路径和"),e(p)])]),h,n("h4",f,[y,s(),n("a",_,[s("2246. 相邻字符不同的最长路径"),e(p)])]),x,n("h4",w,[j,s(),n("a",q,[s("687. 最长同值路径"),e(p)])]),z,n("h4",M,[L,s(),n("a",N,[s("1617. 统计子树中城市之间最大距离"),e(p)])]),I,n("h4",P,[A,s(),n("a",C,[s("2538. 最大价值和与最小价值和的差值"),e(p)])]),T,n("h4",D,[S,s(),n("a",V,[s("1466. 重新规划路线"),e(p)])]),H,n("h4",O,[B,s(),n("a",U,[s("337. 打家劫舍 III"),e(p)])]),E,n("h4",Y,[Z,s(),n("a",G,[s("1377. T 秒后青蛙的位置"),e(p)])]),R,n("h4",X,[J,s(),n("a",K,[s("2646. 最小化旅行的价格总和"),e(p)])]),W,n("h4",$,[F,s(),n("a",Q,[s("P1352 没有上司的舞会"),e(p)])]),nn,sn,an,pn,en,tn,on,cn,ln,un,n("h4",rn,[kn,s(),n("a",dn,[s("968. 监控二叉树"),e(p)])]),mn,n("h4",bn,[gn,s(),n("a",vn,[s("P2458 保安站岗"),e(p)])]),hn,fn,yn,_n,n("h4",xn,[wn,s(),n("a",jn,[s("LCP 34. 二叉树染色"),e(p)])]),qn,n("h4",zn,[Mn,s(),n("a",Ln,[s("LCP 64. 二叉树灯饰"),e(p)])]),Nn,n("h4",In,[Pn,s(),n("a",An,[s("2458. 移除子树后的二叉树高度"),e(p)])]),Cn,n("h4",Tn,[Dn,s(),n("a",Sn,[s("2920. 收集所有金币可获得的最大积分"),e(p)])]),Vn,n("h4",Hn,[On,s(),n("a",Bn,[s("2925. 在树上执行操作以后得到的最大分数"),e(p)])]),Un])}const Rn=t(i,[["render",En],["__file","treeDP.html.vue"]]);export{Rn as default};
