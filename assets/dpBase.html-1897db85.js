const e=JSON.parse('{"key":"v-4f5ae4da","path":"/leetcode/dp/dpBase.html","title":"动态规划","lang":"zh-CN","frontmatter":{"description":"动态规划 [TOC] 解决问题 求方案总数 求可行性 求最优值 动态规划原理 能用动态规划解决的问题，需要满足三个条件：最优子结构，无后效性和子问题重叠。 最优子结构 具有最优子结构也可能是适合用贪心的方法求解。 注意要确保我们考察了最优解中用到的所有子问题。 证明问题最优解的第一个组成部分是做出一个选择； 对于一个给定问题，在其可能的第一步选择中，假定你已经知道哪种选择才会得到最优解。你现在并不关心这种选择具体是如何得到的，只是假定已经知道了这种选择； 给定可获得的最优解的选择后，确定这次选择会产生哪些子问题，以及如何最好地刻画子问题空间； 证明作为构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解。方法是反证法，考虑加入某个子问题的解不是其自身的最优解，那么就可以从原问题的解中用该子问题的最优解替换掉当前的非最优解，从而得到原问题的一个更优的解，从而与原问题最优解的假设矛盾。","head":[["meta",{"property":"og:url","content":"https://newzone.top/MyNotes/leetcode/dp/dpBase.html"}],["meta",{"property":"og:site_name","content":"nocetfy"}],["meta",{"property":"og:title","content":"动态规划"}],["meta",{"property":"og:description","content":"动态规划 [TOC] 解决问题 求方案总数 求可行性 求最优值 动态规划原理 能用动态规划解决的问题，需要满足三个条件：最优子结构，无后效性和子问题重叠。 最优子结构 具有最优子结构也可能是适合用贪心的方法求解。 注意要确保我们考察了最优解中用到的所有子问题。 证明问题最优解的第一个组成部分是做出一个选择； 对于一个给定问题，在其可能的第一步选择中，假定你已经知道哪种选择才会得到最优解。你现在并不关心这种选择具体是如何得到的，只是假定已经知道了这种选择； 给定可获得的最优解的选择后，确定这次选择会产生哪些子问题，以及如何最好地刻画子问题空间； 证明作为构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解。方法是反证法，考虑加入某个子问题的解不是其自身的最优解，那么就可以从原问题的解中用该子问题的最优解替换掉当前的非最优解，从而得到原问题的一个更优的解，从而与原问题最优解的假设矛盾。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"动态规划\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[]}"]]},"headers":[{"level":2,"title":"解决问题","slug":"解决问题","link":"#解决问题","children":[]},{"level":2,"title":"动态规划原理","slug":"动态规划原理","link":"#动态规划原理","children":[{"level":3,"title":"最优子结构","slug":"最优子结构","link":"#最优子结构","children":[]},{"level":3,"title":"无后效性","slug":"无后效性","link":"#无后效性","children":[]},{"level":3,"title":"子问题重叠","slug":"子问题重叠","link":"#子问题重叠","children":[]},{"level":3,"title":"基本思路","slug":"基本思路","link":"#基本思路","children":[]}]},{"level":2,"title":"记忆化搜索翻译为递推","slug":"记忆化搜索翻译为递推","link":"#记忆化搜索翻译为递推","children":[]},{"level":2,"title":"基础问题","slug":"基础问题","link":"#基础问题","children":[]},{"level":2,"title":"打家截舍","slug":"打家截舍","link":"#打家截舍","children":[]}],"git":{},"readingTime":{"minutes":18.31,"words":5494},"filePathRelative":"leetcode/dp/dpBase.md","excerpt":"<h1> 动态规划</h1>\\n<p>[TOC]</p>\\n<h2> 解决问题</h2>\\n<ol>\\n<li>求方案总数</li>\\n<li>求可行性</li>\\n<li>求最优值</li>\\n</ol>\\n<h2> 动态规划原理</h2>\\n<p>能用动态规划解决的问题，需要满足三个条件：最优子结构，无后效性和子问题重叠。</p>\\n<h3> 最优子结构</h3>\\n<p>具有最优子结构也可能是适合用贪心的方法求解。</p>\\n<p>注意要确保我们考察了最优解中用到的所有子问题。</p>\\n<ol>\\n<li>证明问题最优解的第一个组成部分是做出一个选择；</li>\\n<li>对于一个给定问题，在其可能的第一步选择中，假定你已经知道哪种选择才会得到最优解。你现在并不关心这种选择具体是如何得到的，只是假定已经知道了这种选择；</li>\\n<li>给定可获得的最优解的选择后，确定这次选择会产生哪些子问题，以及如何最好地刻画子问题空间；</li>\\n<li>证明作为构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解。方法是反证法，考虑加入某个子问题的解不是其自身的最优解，那么就可以从原问题的解中用该子问题的最优解替换掉当前的非最优解，从而得到原问题的一个更优的解，从而与原问题最优解的假设矛盾。</li>\\n</ol>","autoDesc":true}');export{e as data};
