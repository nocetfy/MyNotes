import{_ as d,H as i,X as t,Y as a,Z as e,a0 as o,a1 as c,$ as n}from"./framework-47f15ee6.js";const l={},h=n('<h1 id="aop" tabindex="-1"><a class="header-anchor" href="#aop" aria-hidden="true">#</a> AOP</h1><p>[toc]</p><h3 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h3><p>​ AOP（Aspect-OrientedProgramming，面向方面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。实现AOP的技术，主要分为两大类：一是采用动态代理技术（<strong>典型代表为Spring AOP</strong>），利用截取消息的方式（<strong>典型代表为AspectJ-AOP</strong>），对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。</p><h3 id="概念" tabindex="-1"><a class="header-anchor" href="#概念" aria-hidden="true">#</a> 概念</h3><ul><li>切面（Aspect）：一个关注点的模块化，这个关注点实现可能另外横切多个对象。事务管理是J2EE应用中一个很好的横切关注点例子。切面用spring的<code>Advisor</code>或拦截器实现。</li><li>连接点（Joinpoint）: 程序执行过程中明确的点，如方法的调用或特定的异常被抛出。</li><li>通知（Advice）: 在特定的连接点，AOP框架执行的动作。各种类型的通知包括“around”、“before”和“throws”通知。通知类型将在下面讨论。许多AOP框架包括Spring都是以拦截器做通知模型，维护一个“围绕”连接点的拦截器链。Spring中定义了四个<code>advice</code>: <code>BeforeAdvice</code>, <code>AfterAdvice</code>, <code>ThrowAdvice</code>和<code>DynamicIntroductionAdvice</code></li><li>切入点（Pointcut）: 指定一个通知将被引发的一系列连接点的集合。AOP框架必须允许开发者指定切入点：例如，使用正则表达式。 Spring定义了<code>Pointcut</code>接口，用来组合<code>MethodMatcher</code>和<code>ClassFilter</code>，可以通过名字很清楚的理解， <code>MethodMatcher</code>是用来检查目标类的方法是否可以被应用此通知，而<code>ClassFilter</code>是用来检查Pointcut是否应该应用到目标类上</li><li>引入（Introduction）: 添加方法或字段到被通知的类。 Spring允许引入新的接口到任何被通知的对象。例如，你可以使用一个引入使任何对象实现 <code>IsModified</code>接口，来简化缓存。Spring中要使用<code>Introduction</code>, 可有通过<code>DelegatingIntroductionInterceptor</code>来实现通知，通过<code>DefaultIntroductionAdvisor</code>来配置Advice和代理类要实现的接口（使用较少）</li><li>目标对象（Target Object）: 包含连接点的对象。也被称作被通知或被代理对象POJO</li><li>AOP代理（AOP Proxy）: AOP框架创建的对象，包含通知。 在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。</li><li>织入（Weaving）: 组装方面来创建一个被通知对象。这可以在编译时完成（例如使用AspectJ编译器），也可以在运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。</li></ul><h3 id="aop实现使用" tabindex="-1"><a class="header-anchor" href="#aop实现使用" aria-hidden="true">#</a> AOP实现使用</h3><h4 id="使用-aspect注解方式" tabindex="-1"><a class="header-anchor" href="#使用-aspect注解方式" aria-hidden="true">#</a> 使用@Aspect注解方式</h4><ul><li><code>Aspect</code>：标注切面</li><li><code>Pointcut</code>：标注切点</li><li><code>Before</code>：前置通知</li><li><code>After</code>：后置通知</li><li><code>Around</code>：环绕通知</li><li><code>AfterReturning</code>：方法返回后通知</li><li><code>AfterThrowing</code>：方法抛出异常后通知</li></ul><p>原理如下：</p><p>引入自动代理创建器。如：<code>AbstractAutoProxyCreator</code>的所有子类，实现有多种。(<code>EnableAspectJAutoProxy</code>注解驱动原理就是它)</p><ol><li>前置通知：org.springframework.aop.MethodBeforeAdvice</li><li>后置通知：org.springframework.aop.AfterReturningAdvice</li><li>异常通知：org.springframework.aop.ThrowsAdvice</li><li>环绕通知：org.aopalliance.intercept.MethodInterceptor （注意这个是<code>aopalliance</code>包下的接口，Spring提供实现类非常之多，比如：<code>MethodBeforeAdviceInterceptor</code>(包装了<code>MethodBeforeAdvice</code>)，<code>CacheInterceptor</code>等等非常多）</li></ol><p>​ AspectJ在AOP的实现方式上依赖于特殊编译器(ajc编译器)，因此Spring很机智回避了这点，转向采用动态代理技术的实现原理来构建Spring AOP的内部机制。spring直接使用AspectJ的注解功能，<strong>注意只是使用了它的注解功能而已</strong>。</p><h3 id="aop原理" tabindex="-1"><a class="header-anchor" href="#aop原理" aria-hidden="true">#</a> AOP原理</h3><hr><h3 id="异步" tabindex="-1"><a class="header-anchor" href="#异步" aria-hidden="true">#</a> 异步</h3><hr><h3 id="事务" tabindex="-1"><a class="header-anchor" href="#事务" aria-hidden="true">#</a> 事务</h3><ul><li>事务失效场景</li></ul>',19),s={href:"https://www.cnblogs.com/dennyzhangdd/p/9602673.html",target:"_blank",rel:"noopener noreferrer"},p=e("h3",{id:"循环依赖与aop",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#循环依赖与aop","aria-hidden":"true"},"#"),o(" 循环依赖与AOP")],-1),A={href:"https://cloud.tencent.com/developer/article/1497692",target:"_blank",rel:"noopener noreferrer"};function g(u,f){const r=i("ExternalLinkIcon");return t(),a("div",null,[h,e("p",null,[e("a",s,[o("https://www.cnblogs.com/dennyzhangdd/p/9602673.html"),c(r)])]),p,e("p",null,[e("a",A,[o("https://cloud.tencent.com/developer/article/1497692"),c(r)])])])}const O=d(l,[["render",g],["__file","Spring AOP.html.vue"]]);export{O as default};
