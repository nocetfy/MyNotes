import{_ as a,X as s,Y as i,Z as e,a0 as r,a1 as n,$ as t,H as l}from"./framework-1ee2252c.js";const d={},c=t('<h1 id="运维" tabindex="-1"><a class="header-anchor" href="#运维" aria-hidden="true">#</a> 运维</h1><p>[toc]</p><h2 id="容器" tabindex="-1"><a class="header-anchor" href="#容器" aria-hidden="true">#</a> 容器</h2><h3 id="docker容器之间怎么隔离" tabindex="-1"><a class="header-anchor" href="#docker容器之间怎么隔离" aria-hidden="true">#</a> docker容器之间怎么隔离?</h3><p>​ Linux中的PID、IPC、网络等资源是全局的，而Linux的NameSpace机制是一种资源隔离方案，在该机制下这些资源就不再是全局的了，而是属于某个特定的NameSpace，各个NameSpace下的资源互不干扰。</p><p>​ <strong>Namespace实际上修改了应用进程看待整个计算机“视图”，即它的“视线”被操作系统做了限制，只能“看到”某些指定的内容</strong>。对于宿主机来说，这些被“隔离”了的进程跟其他进程并没有区别。</p><p>​ 虽然有了NameSpace技术可以实现资源隔离，但进程还是可以不受控的访问系统资源，比如CPU、内存、磁盘、网络等，为了控制容器中进程对资源的访问，Docker采用control groups技术(也就是cgroup)，有了cgroup就可以控制容器中进程对系统资源的消耗了，比如你可以限制某个容器使用内存的上限、可以在哪些CPU上运行等等。</p><p>​ 有了这两项技术，容器看起来就真的像是独立的操作系统了。</p><hr><h2 id="k8s" tabindex="-1"><a class="header-anchor" href="#k8s" aria-hidden="true">#</a> k8s</h2><p>用于自动部署、扩展和管理“容器化（containerized）应用程序”的开源系统.</p><h3 id="作用" tabindex="-1"><a class="header-anchor" href="#作用" aria-hidden="true">#</a> 作用</h3><p><strong>自动完成服务的部署、更新、卸载和扩容、缩容呢</strong>，<strong>自动化运维管理容器化程序</strong></p><h3 id="架构" tabindex="-1"><a class="header-anchor" href="#架构" aria-hidden="true">#</a> 架构</h3><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/bVRhq.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>K8S 是属于<strong>主从设备模型（Master-Slave 架构）</strong>，即有 Master 节点负责核心的调度、管理和运维，Slave 节点则在执行用户的程序。但是在 K8S 中，主节点一般被称为<strong>Master Node 或者 Head Node</strong>，而从节点则被称为<strong>Worker Node 或者 Node</strong></p><p>Master Node 和 Worker Node 是分别安装了 K8S 的 Master 和 Woker 组件的实体服务器，每个 Node 都对应了一台实体服务器。<strong>所有 Master Node 和 Worker Node 组成了 K8S 集群</strong>，同一个集群可能存在多个 Master Node 和 Worker Node。</p><h4 id="master-node" tabindex="-1"><a class="header-anchor" href="#master-node" aria-hidden="true">#</a> Master Node</h4>',18),h=e("li",null,[e("strong",null,"API Server"),r("。"),e("strong",null,"K8S 的请求入口服务"),r("。API Server 负责接收 K8S 所有请求（来自 UI 界面或者 CLI 命令行工具），然后，API Server 根据用户的具体请求，去通知其他组件干活。")],-1),u=e("li",null,[e("strong",null,"Scheduler"),r("。"),e("strong",null,"K8S 所有 Worker Node 的调度器"),r("。当用户要部署服务时，Scheduler 会选择最合适的 Worker Node（服务器）来部署。")],-1),g=e("strong",null,"Controller Manager",-1),p=e("strong",null,"K8S 所有 Worker Node 的监控器",-1),f={href:"https://aijishu.com/link?target=https%3A%2F%2Fmedium.com%2F@kumargaurav1247%2Fcomponents-of-kubernetes-architecture-6feea4d5c712",target:"_blank",rel:"noopener noreferrer"},k=e("strong",null,"etcd",-1),_=e("strong",null,"K8S 的存储服务",-1),N={href:"https://aijishu.com/link?target=https%3A%2F%2Fthenewstack.io%2Fhow-does-kubernetes-work%2F",target:"_blank",rel:"noopener noreferrer"},m=t('<h4 id="work-node" tabindex="-1"><a class="header-anchor" href="#work-node" aria-hidden="true">#</a> Work Node</h4><ul><li><strong>Kubelet</strong>。<strong>Worker Node 的监视器，以及与 Master Node 的通讯器</strong>。Kubelet 是 Master Node 安插在 Worker Node 上的“眼线”，它会定期向 Worker Node 汇报自己 Node 上运行的服务的状态，并接受来自 Master Node 的指示采取调整措施。</li><li><strong>Kube-Proxy</strong>。<strong>K8S 的网络代理</strong>。私以为称呼为 Network-Proxy 可能更适合？Kube-Proxy 负责 Node 在 K8S 的网络通讯、以及对外部网络流量的负载均衡。</li><li><strong>Container Runtime</strong>。<strong>Worker Node 的运行环境</strong>。即安装了容器化所需的软件环境确保容器化程序能够跑起来，比如 Docker Engine。大白话就是帮忙装好了 Docker 运行环境。</li><li><strong>Logging Layer</strong>。<strong>K8S 的监控状态收集器</strong>。私以为称呼为 Monitor 可能更合适？Logging Layer 负责采集 Node 上所有服务的 CPU、内存、磁盘、网络等监控项信息。</li><li><strong>Add-Ons</strong>。<strong>K8S 管理运维 Worker Node 的插件组件</strong>。有些文章认为 Worker Node 只有三大组件，不包含 Add-On，但笔者认为 K8S 系统提供了 Add-On 机制，让用户可以扩展更多定制化功能，是很不错的亮点。</li></ul><h2 id="命令" tabindex="-1"><a class="header-anchor" href="#命令" aria-hidden="true">#</a> 命令</h2><h3 id="top" tabindex="-1"><a class="header-anchor" href="#top" aria-hidden="true">#</a> top</h3><h4 id="load" tabindex="-1"><a class="header-anchor" href="#load" aria-hidden="true">#</a> load</h4><p>​ <code>uptime</code>也有该数据，该数据来源是计算CPU的内核态线程量（等价用户态进程量），<code>不仅包括了nr_running状态，还包括了nr_uninterruptible状态的线程，后者是会被I/O、内存资源关联影响的。</code></p><ul><li>什么是nr_running、nr_uninterruptible状态？</li></ul><blockquote><p>这是用户态进程状态，有7种状态。running的状态好理解，就是正常运行的进程；而uninterruptible是一种特殊状态，表示的是一个等待硬件资源睡眠且无法被中断的进程，出现该状态的进程一般是因为在等待IO，例如磁盘IO、网络IO等。<code>也就是说，I/O和内存的不足，也会造成load average增加。</code></p></blockquote><p><strong>不是平均值，每个cpu核都会计算在内</strong>，所以只要负载不超过核数，就是比较安全的。</p><p>总结一下load高常见的、可能的一些原因：</p><ul><li>死循环或者不合理的大量循环操作，如果不是循环操作，按照现代cpu的处理速度来说处理一大段代码也就一会会儿的事，基本对能力无消耗</li><li>频繁的YoungGC</li><li>频繁的FullGC</li><li>高磁盘IO</li><li>高网络IO</li></ul><p>线上遇到问题的时候首先不要慌，因为大部分load高的问题都集中在以上几个点里面，以下分析问题的步骤或许能帮你整理思路：</p><ul><li>top先查看用户us与空闲us（id）的cpu占比，目的是确认load高是否高cpu起的</li><li>如果是高cpu引起的，那么确认一下是否gc引起的，jstat命令 + gc日志基本就能确认</li><li>gc引起的高cpu直接dump，非gc引起的分析线程堆栈</li><li>如果不是高cpu引起的，查看磁盘io占比（wa），如果是，那么打线程堆栈分析是否有大量的文件io</li><li>如果不是高cpu引起的，且不是磁盘io导致的，检查各依赖子系统的调用耗时，高耗时的网络调用很可能是罪魁祸首</li></ul><h4 id="cache与buffer" tabindex="-1"><a class="header-anchor" href="#cache与buffer" aria-hidden="true">#</a> cache与buffer</h4><p>1、<strong>Buffer</strong>（缓冲区）是系统两端处理<strong>速度平衡</strong>（从长时间尺度上看）时使用的。它的引入是为了减小短期内突发I/O的影响，起到<strong>流量整形</strong>的作用。比如生产者——消费者问题，他们产生和消耗资源的速度大体接近，加一个buffer可以抵消掉资源刚产生/消耗时的突然变化。 2、<strong>Cache</strong>（缓存/<strong>快取</strong>）则是系统两端处理<strong>速度不匹配</strong>时的一种<strong>折衷策略</strong>。因为CPU和memory之间的速度差异越来越大，所以人们充分利用数据的局部性（locality）特征，通过使用存储系统分级（memory hierarchy）的策略来减小这种差异带来的影响。</p><p>Buffer 与 Cache 的用途有所不一定：</p><ol><li>Buffer 的主要目的是在不同应用、线程、进程之间共享字节数据，例如为了让不同速度的设备能够进行数据同步，就会使用共享 Buffer；</li><li>Cache 的主要目的是提高字节数据的读取/写入速度，例如根据时间局部性、地址局部性操作系统提供 page cache 机制；</li></ol><p>当然，在很多场合下 Buffer 与 Cache 有着相同的语义，因此我们可以认为缓冲区既用于提高读写速度，又用于数据共享与同步。</p><hr>',19);function b(S,x){const o=l("ExternalLinkIcon");return s(),i("div",null,[c,e("ul",null,[h,u,e("li",null,[g,r("。"),p,r("。Controller Manager 有很多具体的 Controller，在文章"),e("a",f,[r("Components of Kubernetes Architecture"),n(o)]),r("中提到的有 Node Controller、Service Controller、Volume Controller 等。Controller 负责监控和调整在 Worker Node 上部署的服务的状态，比如用户要求 A 服务部署 2 个副本，那么当其中一个服务挂了的时候，Controller 会马上调整，让 Scheduler 再选择一个 Worker Node 重新部署服务。")]),e("li",null,[k,r("。"),_,r("。etcd 存储了 K8S 的关键配置和用户配置，K8S 中仅 API Server 才具备读写权限，其他组件必须通过 API Server 的接口才能读写数据（见"),e("a",N,[r("Kubernetes Works Like an Operating System"),n(o)]),r("）。")])]),m])}const K=a(d,[["render",b],["__file","容器.html.vue"]]);export{K as default};
