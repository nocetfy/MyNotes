import{_ as a,X as n,Y as e,$ as t}from"./framework-1ee2252c.js";const i={},s=t(`<h1 id="rabbitmq" tabindex="-1"><a class="header-anchor" href="#rabbitmq" aria-hidden="true">#</a> RabbitMQ</h1><p>[toc]</p><h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><p>RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。</p><p>AMQP ：Advanced Message Queue，高级消息队列协议。它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。</p><p>RabbitMQ 最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。具体特点包括：</p><ol><li><p>可靠性: RabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认、发布确认。</p></li><li><p>消息集群: 多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker 。</p></li><li><p>高可用: 队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。</p></li><li><p>多种协议: RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT 等等。</p></li><li><p>多语言客户端: RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、Ruby 等等。</p></li><li><p>管理界面: RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方面。</p></li><li><p>插件机制: RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件。</p></li></ol><p>RabbitMQ 内部结构如下：</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/1620871746013-bbb077d5-a5c1-4c8b-b4ab-4554e360707b-20230226021846352.png" alt="1.png" tabindex="0" loading="lazy"><figcaption>1.png</figcaption></figure><ol><li><p>Publisher 消息的生产者，也是一个向交换器发布消息的客户端应用程序。</p></li><li><p>Consumer 消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。</p></li><li><p>Broker 表示消息队列服务器实体。</p></li><li><p>Message 消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括 routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。</p></li><li><p>Virtual Host 虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 。</p></li><li><p>Exchange 交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。</p></li><li><p>Binding 绑定，用于消息队列和交换器或者交换器与交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</p></li><li><p>Queue 消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里，等待消费者连接到这个队列将其取走。多个消费者可以订阅同一个队列，队列中的消息会被平均分摊给多个消费者处理，而不是每个消费者都会收到所有消息并处理。</p></li><li><p>Connection 网络连接，比如一个 TCP 连接。</p></li><li><p>Channel 信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的 TCP 连接内地虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。</p></li></ol><p>RocketMQ架构</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/1621490595642-e45632be-0b42-4748-9d7d-7fa6b3169658-20230226021843506.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>RocketMQ 的架构整体有四部分组成：NameServer、Broker、Producer、Consumer，其中每一个模块都可以进行水平扩展。</p><p>NameServer</p><p>NameServer 提供轻量级的服务发现和路由。每个 NameServer 记录完整的路由信息，提供相应的读写服务，并支持快速的存储扩展。</p><p>Broker</p><p>Broker 通过提供轻量级的 TOPIC 和 QUEUE 机制来存储消息。包含容错机制（2 个或 3 个副本），并提供强大的峰值填充功能和按原始时间顺序累积数千亿条消息的能力。此外，Broker 还提供灾难恢复，丰富的指标统计信息和警报机制，而这是传统消息中间件所没有的。</p><p>Producer</p><p>Producer 支持分布式部署。分布式生产者通过多种负载平衡模式将消息发送到 Broker 集群。发送过程支持快速失败并且延迟低。</p><p>Consumer</p><p>消费者支持分布式部署。还支持消息广播、实时消息订阅机制，可以满足大多数消费者的需求。</p><h2 id="amqp-中的消息路由" tabindex="-1"><a class="header-anchor" href="#amqp-中的消息路由" aria-hidden="true">#</a> AMQP 中的消息路由</h2><p>​ AMQP 中消息的路由过程和 Java 开发者熟悉的 JMS 存在一些差别，AMQP 中增加了 Exchange 和 Binding 的角色。生产者把消息发布到 Exchange 上，消息最终到达队列并被消费者接收，而 Binding 决定交换器的消息应该发送到那个队列。</p><h3 id="exchange-类型" tabindex="-1"><a class="header-anchor" href="#exchange-类型" aria-hidden="true">#</a> Exchange 类型</h3><p>​ Exchange 分发消息时根据类型的不同分发策略有区别，目前主要共四种类型：direct、fanout、topic、headers 。headers 匹配 AMQP 消息的 header 而不是路由键，此外 headers 交换器和 direct 交换器完全一致，但性能差很多，目前几乎用不到了，所以直接看另外三种类型：</p><h4 id="direct" tabindex="-1"><a class="header-anchor" href="#direct" aria-hidden="true">#</a> direct</h4><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/1620875542511-b60f2039-e308-4fbc-9cd0-e13232d5fd42-20230226021839846.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>​ 消息中的路由键（routing key）如果和 Binding 中的 binding key 一致， 交换器就将消息发到对应的队列中。路由键与队列名完全匹配，如果一个队列绑定到交换机要求路由键为 “info”，则只转发 routing key 标记为 “info” 的消息，不会转发 “debug”，也不会转发 “info.temp” 等等。它是完全匹配、单播的模式。</p><h4 id="fanout" tabindex="-1"><a class="header-anchor" href="#fanout" aria-hidden="true">#</a> fanout</h4><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/1620875691779-947db524-76a4-48d9-8066-5b1b4b53e157-20230226021837657.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>每个发到 fanout 类型交换器的消息都会分到所有绑定的队列上去。fanout 交换器不处理路由键，只是简单的将队列绑定到交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。fanout 类型转发消息是最快的。</p><h4 id="topic" tabindex="-1"><a class="header-anchor" href="#topic" aria-hidden="true">#</a> topic</h4><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/1620875759299-6fff3f55-c410-4847-af24-777fd13a047a-20230226021855840-20230226022005417.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>​ topic 交换器通过模式匹配分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词，这些单词之间用点隔开。它同样也会识别两个通配符用于模糊匹配：符号 “#” 和符号 “*”。# 匹配 0 个或多个单词，* 匹配一个单词。</p><h2 id="rabbitmq-常见的五种模式" tabindex="-1"><a class="header-anchor" href="#rabbitmq-常见的五种模式" aria-hidden="true">#</a> RabbitMQ 常见的五种模式</h2><p>在 RabbitMQ 中，常见的五种模式如下</p><ol><li>Direct 模式</li></ol><p>最简单的模式，只会有一个 Producer 负责发送 message 到 Queue 里、而也只有一个 Consumer 去 Queue 里消费 message。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/1620138455212-c1e09012-428c-4369-953d-3b759be8aea6-20230226022002062.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="2"><li>Worker 模式</li></ol><p>跟 Direct 模式很像，但是差别是 Worker 模式中会同时有多个 Consumer 会去消费 Queue 里的 message，增加 message 消费的速度。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/1620138459087-6bd73225-4979-4a8b-93d5-672eff1ad38a-20230226022000315.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="3"><li>Publish/Subscribe 模式</li></ol><p>​ 从这个模式之后，在 Producer、Queue、Consumer 之间开始使用交换器Exchange，Producer 不再是直接把 message 投递到 Queue 里，而是让 Producer 把 message 投递 Exchange，再交由 Exchange 去决定要把这个 message 投递给哪个 Queue</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/1620138456180-2648f090-fb09-4caf-9ce6-4ed6a1fea606-20230226021958221.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>​ 在 Publish/Subscribe 模式中，使用的是 Exchange 的 fanout type，当 Producer 把 message 投递给 Exchange 时，Exchange 会把这个 message 投递到它绑定的所有 Queue 上。</p><p>​ Publish/Subscribe 模式也是一个常用的模式，通常是用在需要订阅的情况下。</p><p>​ 比如当订单服务有了一笔新订单之后就要去通知短信服务、商品服务… 等，那如果是用前面提到RabbitMQ 中的 Direct 模式，在订单服务就要自己指定要把message 投递到哪个 Queue 上，如果又有新的服务要来订阅这个 message 的话，需要更新代码。</p><p>​ 但是使用 Publish/Subscribe 模式的话，订单服务就可以直接将message 投递 Exchange，而我们只要把新的服务使用的 Queue 和 Exchange 绑定，Exchange 就可以自动把 message 也投递到新的 Queue 里了。</p><ol start="4"><li>Routing 模式</li></ol><p>​ Routing 模式也是一个用到了 Exchange 的模式，这个模式使用的是 Exchange 的 direct type</p><p>​ 当 Producer 把 message 投递 Exchange 时，同时要在这个message 上面带上一个routing key，而 Exchange 就会根据这个 routing key，将 message 投递到指定的 Queue 上</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/1620138456972-177d23f2-304a-4d5b-b93b-db9c07fd732c-20230226021955285.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>Routing 模式不同于发布/订阅模式的地方在于它会把消息根据routing key进行分发，到匹配需要的队列中去，而不是分发到所有的队列。</p><ol start="5"><li>Topics 模式</li></ol><p>用到了 Exchange 的 topic type，用法基本上跟 Routing 模式一样，只是 routing key 提供了模糊匹配的规则</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/1620138460595-7025c703-7c95-4071-a96a-ea784d80da90-20230226021953718.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="rabbitmq-消费模式" tabindex="-1"><a class="header-anchor" href="#rabbitmq-消费模式" aria-hidden="true">#</a> RabbitMQ 消费模式</h2><p>RabbitMQ的消费模式分为两种：推(Push)模式和拉(Pull)模式。</p><ol><li>推模式</li></ol><p>推模式使用持续持续订阅的方式来消费消息。</p><ol start="2"><li>拉模式</li></ol><p>拉模式请求channel获得单条消息。</p><h2 id="rabbitmq-死信队列" tabindex="-1"><a class="header-anchor" href="#rabbitmq-死信队列" aria-hidden="true">#</a> RabbitMQ 死信队列</h2><p>“死信” 是 RabbitMQ 中的一种消息机制，当消费消息时，如果队列里的消息出现以下情况：</p><ul><li><p>消息被否定确认，使用 channel.basicNack或 channel.basicReject ，并且此时 requeue 属性被设置为 false。</p></li><li><p>消息在队列的存活时间超过设置的 TTL 时间。</p></li><li><p>消息队列的消息数量已经超过最大队列长度。</p></li></ul><p>那么该消息将成为 “死信”。</p><p>​ “死信” 消息会被 RabbitMQ 进行特殊处理，如果配置了死信交换器信息，那么该消息将会被投递到死信交换器中，如果没有配置，则该消息将会被丢弃，死信常用于延迟队列的实现。</p><p>Message的Header 中会包含一些死信的属性：</p><table><thead><tr><th>字段名</th><th>含义</th></tr></thead><tbody><tr><td>x-first-death-exchange</td><td>第一次被抛入的死信交换机的名称</td></tr><tr><td>x-first-death-reason</td><td>第一次成为死信的原因， rejected：消息在重新进入队列时被队列拒绝，由于 default-requeue-rejected参数被设置为false。 expired：消息过期。 maxlen： 队列内消息数量超过队列最大容量</td></tr><tr><td>x-first-death-queue</td><td>第一次成为死信前所在队列名称</td></tr><tr><td>x-death</td><td>历次被投入死信交换机的信息列表，同一个消息每次进入一个死信交换机，这个数组的信息就会被更</td></tr></tbody></table><h2 id="rabbitmq-延迟队列" tabindex="-1"><a class="header-anchor" href="#rabbitmq-延迟队列" aria-hidden="true">#</a> RabbitMQ 延迟队列</h2><ol><li>设置TTL</li></ol><p>TTL，Time to Live的缩写，即过期时间，RabbitMQ可以为队列和消息设置单独的过期时间。如果为队列设置过期时间，队列中的所有消息都会有相同的过期时间。也可以为消息设置过期时间，每个消息的过期时间可以不同。如果同时进行了设置，会以两者间小的那个为准。一旦超过设置的TTL值时，消息就会变成死信(Dead Message)</p><ol start="2"><li>设置DLX</li></ol><p>即Dead-letter-exchange，死信交换器，当一个队列中的消息过期后，它可以被投递到死信交换器中去，然后通过死信交换器投递到队列中。</p><p>通过设置队列TTL和DLX的方式，可以实现RabbitMQ的延迟队列功能</p><figure><img src="https://cdn.nlark.com/yuque/0/2021/png/21500944/1620877589762-f16914a4-53c0-4bae-8f84-cc18c51ddecf.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>​ 如图为队列设置TTL，队列中的消息具有过期时间，消息过期后投递到队列的DLX中，DLX根据routing key投递到正常队列中去，消费者从正常队列中消费从而达到延迟队列的功能。</p><figure><img src="https://cdn.nlark.com/yuque/0/2021/png/21500944/1620882805716-55ff6629-2310-4bf7-83ae-a0ae6ee247bf.png" alt="延迟队列.png" tabindex="0" loading="lazy"><figcaption>延迟队列.png</figcaption></figure><p>延迟队列没有消费者，消息在过期后会投递到设置的x-dead-letter-exchange交换器中去。</p><h2 id="rabbitmq集群" tabindex="-1"><a class="header-anchor" href="#rabbitmq集群" aria-hidden="true">#</a> RabbitMQ集群</h2><h3 id="普通集群" tabindex="-1"><a class="header-anchor" href="#普通集群" aria-hidden="true">#</a> 普通集群</h3><p>​ 集成方式: 多台服务器单独部署节点，每个节点保存着 Queue 的元数据，同一条消息只存在与其中一个节点上，当访问一个仅含有Queue 元数据的节点时，则会从具有实例的节点拉取数据。</p><p>优点：可以访问多台MQ实例去消费，提高吞吐量。</p><p>缺点：可能在RabbitMQ集群内产生大量的消息传输；无高可用保障，某节点宕机，会导致节点上的Queue数据丢失，不是高可用的。</p><figure><img src="https://cdn.nlark.com/yuque/0/2021/svg/21500944/1621921995838-f3ffa603-9d04-4ea4-8b46-3d35265b9574.svg" alt="普通集群.svg" tabindex="0" loading="lazy"><figcaption>普通集群.svg</figcaption></figure><h3 id="镜像集群" tabindex="-1"><a class="header-anchor" href="#镜像集群" aria-hidden="true">#</a> 镜像集群</h3><p>集成方式: 多台服务器单独部署节点，一个节点会向其他节点同步数据，每个节点都持有所有的消息数据。</p><p>优点：高可用，每个节点都含有Queue的全部数据，元数据与消息数据都会包含，任一节点宕机，其余节点都有全量数据，不影响消费者消息。</p><p>缺点：同步消息数据，性能开销大。</p><figure><img src="https://cdn.nlark.com/yuque/0/2021/svg/21500944/1621922441691-ac9ccefb-7a54-4572-a61d-3118d2c6539f.svg" alt="镜像集群.svg" tabindex="0" loading="lazy"><figcaption>镜像集群.svg</figcaption></figure><h4 id="镜像集群负载均衡" tabindex="-1"><a class="header-anchor" href="#镜像集群负载均衡" aria-hidden="true">#</a> 镜像集群负载均衡</h4><p>镜像集群本身没有提供负载均衡功能，使用HAproxy来做 RabbitMQ 集群负载均衡，用 Keepalived 来保证 HAproxy 的高可用，整体架构图如下：</p><figure><img src="https://cdn.nlark.com/yuque/0/2021/webp/21500944/1621582515815-63b975fc-23c9-412d-934b-c65bf4bff005.webp?x-oss-process=image%2Fresize%2Cw_662%2Climit_0" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>​ 如果只采用一台HAProxy，那么它就存在明显的单点故障的问题，所以至少需要两台HAProxy，同时这两台HAProxy 之间需要能够自动进行故障转移，通常的解决方案就是 KeepAlived 。KeepAlived 采用VRRP来解决单点失效的问题，它通常由一组一备两个节点组成，同一时间内只有主节点会提供对外服务，并同时提供一个虚拟的 IP 地址。如果主节点故障，那么备份节点会自动接管 VIP 并成为新的主节点，直到原有的主节点恢复。</p><h2 id="消息队列常见问题" tabindex="-1"><a class="header-anchor" href="#消息队列常见问题" aria-hidden="true">#</a> 消息队列常见问题</h2><h3 id="多消费者订阅同一队列" tabindex="-1"><a class="header-anchor" href="#多消费者订阅同一队列" aria-hidden="true">#</a> 多消费者订阅同一队列</h3><p>使用两个消费者订阅同一队列</p><figure><img src="https://cdn.nlark.com/yuque/0/2021/png/21500944/1621585237698-f59543ed-ab68-443c-a1e2-c457c537144d.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/1621585248408-bcfcdf78-ae45-4ebf-94e5-f40c7e6eaa86-20230226022319111.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>管理后台可以看到队列有两个消费者</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/1621584754908-c25e6205-bf31-4b3f-b2c4-ad094aaf5190-20230226022311930.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>发送消息到队列中，只会有一个消费者收到消息，在RabbitMQ中多消费者订阅同一队列不会分发到所有消费者中，会采取轮询的方式只发送到一个消费者。</p><figure><img src="https://cdn.nlark.com/yuque/0/2021/png/21500944/1621585480151-ec1a3247-937d-4eeb-a2d3-af37a4fccffe.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><hr><h3 id="消息可靠传输" tabindex="-1"><a class="header-anchor" href="#消息可靠传输" aria-hidden="true">#</a> 消息可靠传输</h3><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/1621384080051-88f71839-1ec5-46f5-8a23-06c5086d2a66-20230226022309955.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><ol><li>生产者保证</li></ol><ul><li>开启事务</li></ul><p>​ 此时可以选择用 RabbitMQ 提供的事务功能，就是生产者发送数据之前开启 RabbitMQ 事务channel.txSelect，然后发送消息，如果消息没有成功被 RabbitMQ 接收到，那么生产者会收到异常报错，此时就可以回滚事务channel.txRollback，然后重试发送消息；如果收到了消息，那么可以提交事务channel.txCommit。</p><p>​ 事务可以解决发送方与RabbitMQ之间消息确认的问题，只有消息被RabbitMQ接收，事务才能提交成功，否则可在捕获异常后进行回滚，同时重发消息，但是使用事务会同步阻塞队列，降低性能。</p><ul><li>生产者确认</li></ul><p>​ 生产者将信道设为confirm模式，每次写的消息都会分配一个唯一的 id，然后如果消息写入了 RabbitMQ 中，RabbitMQ 会回传一个 ack 消息，告诉你说这个消息 ok 了。如果 RabbitMQ 没能处理这个消息，会回调一个 nack 接口，告诉发送方消息接收失败，可以重试。可以结合这个机制在内存里维护每个消息 id 的状态，如果超过一定时间还没接收到这个消息的回调，可以重发。</p><p>​ 事务机制和 confirm 机制是互斥的，最大的不同在于，事务机制是同步的，提交一个事务之后会阻塞，但是 confirm 机制是异步的，发送个消息之后就可以发送下一个消息，然后消息 RabbitMQ 接收了之后会异步回调接口通知这个消息接收到了。</p><ol start="2"><li>队列保证</li></ol><p>开启 RabbitMQ 的持久化，就是消息写入之后会持久化到磁盘，哪怕是 RabbitMQ 自己挂了，恢复之后会自动读取之前存储的数据，</p><p>设置持久化有两个步骤：</p><ul><li>创建 queue 的时候将其设置为持久化 这样就可以保证 RabbitMQ 持久化 queue 的元数据，但是它不会持久化 queue 里的数据。</li></ul><figure><img src="https://cdn.nlark.com/yuque/0/2021/png/21500944/1621997922344-baba677a-de50-4daf-806c-2dbb05117dfa.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><ul><li>第二个是发送消息的时候将消息的 deliveryMode 设置为 2 就是将消息设置为持久化的，此时 RabbitMQ 就会将消息持久化到磁盘上去。</li></ul><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/1621998066716-2dd5f8e5-3ac5-4da3-aff0-7ee6264e2109-20230226022346082.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>必须要同时设置这两个持久化才行，RabbitMQ 哪怕是挂了，再次重启，也会从磁盘上重启恢复 queue，恢复这个 queue 里的数据。</p><ol start="3"><li>消费端的确认与拒绝</li></ol><p>确认</p><p>为了保证消息队列可靠的达到消费者，RabbitMQ 提供了消息确认机制（message acknowledgement）。消费者在订阅队列时，可以指定 autoAck 参数，</p><ul><li><p>当为 false 时：RabbitMQ 会等待消费者显式回复确认信号后才从内存（或磁盘）中移除消息（先打上删除标记，之后再删除）</p></li><li><p>当为 true 时：RabbitMQ 会自动把发送出去的消息设置为确认，然后从删除，而不管消费者是否真正消费到了这些消息</p></li></ul><p>当 autoAck 参数设置为 false 时，对于 RabbitMQ 服务器而言，队列中的消息分成了两个部分：</p><ul><li><p>等待投递给消费者的消息</p></li><li><p>已经投递给消费者，但还没有收到消费者确认信号的消息</p></li></ul><p>​ 如果一直没有收到消费者的确认信号，并且消费者此消息的消费者已经断开连接，则会安排该消息重新进入队列。RabbitMQ 不会为未确认的消息设置过期时间，是否要重新投递给消费者的唯一依据是：消费者未确认并且已经断开链接，这允许消费者消费一条消息的时间可以很久很久。</p><hr><h3 id="spring中提供的确认模式" tabindex="-1"><a class="header-anchor" href="#spring中提供的确认模式" aria-hidden="true">#</a> Spring中提供的确认模式</h3><p>Spring对RabbitMQ提供了三种确认模式，对这三种模式的测试用例如下，消费者在消费消息时会抛出异常：</p><figure><img src="https://cdn.nlark.com/yuque/0/2021/png/21500944/1621494624192-00dfbd5a-c62a-4bc7-86ed-be331883ff34.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h4 id="none" tabindex="-1"><a class="header-anchor" href="#none" aria-hidden="true">#</a> None</h4><p>队列投递给消息者即视为成功，会发送ack给队列。</p><ol><li>设置确认模式为none</li></ol><figure><img src="https://cdn.nlark.com/yuque/0/2021/png/21500944/1621494330457-eac6086d-5488-475e-8d53-222992beb34f.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><ol start="2"><li>消息消费异常</li></ol><figure><img src="https://cdn.nlark.com/yuque/0/2021/png/21500944/1621495156035-5457984f-59a1-486c-acac-cad5f1dfef2e.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><ol start="3"><li>但队列认为消费已成功</li></ol><figure><img src="https://cdn.nlark.com/yuque/0/2021/png/21500944/1621495177362-7004b319-7a7f-4299-b4fa-af6ede3cff9c.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h4 id="auto" tabindex="-1"><a class="header-anchor" href="#auto" aria-hidden="true">#</a> Auto</h4><p>Spring 根据执行情况自动判断，无异常执行结束后发送ack，出现amqp重复消费异常拒绝，出现其他异常会重新投递入队，而且会在队列头。</p><ol><li>设置模式</li></ol><figure><img src="https://cdn.nlark.com/yuque/0/2021/png/21500944/1621494359412-ba433712-5c20-4a43-a885-d075923f6651.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><ol start="2"><li>消息被重复投递给消费者，称为死循环，不停刷异常日志</li></ol><figure><img src="https://cdn.nlark.com/yuque/0/2021/png/21500944/1621502284250-c754a0a2-92e9-42c7-98bd-82205c7aa64e.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><ol start="3"><li>队列中消息为未确认状态，且会重新入队，不断地被投递给消费者。</li></ol><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/1621502575488-3cec72d1-8c27-4a71-88ab-09c17aad5192-20230226022538651.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><ol start="4"><li>添加spring重试配置，设置每条消息重试最多三次，每次间隔3秒。</li></ol><figure><img src="https://cdn.nlark.com/yuque/0/2021/png/21500944/1621502761299-26685d7c-5489-4481-b312-c69cf98b849a.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><ol start="5"><li>消息消费三次后提示重试次数已用尽，消息被拒绝</li></ol><figure><img src="https://cdn.nlark.com/yuque/0/2021/png/21500944/1621502977268-20d8ec58-639d-4b41-83b9-a820a9dc1356.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><ol start="6"><li>队列中消息已不存在</li></ol><figure><img src="https://cdn.nlark.com/yuque/0/2021/png/21500944/1621503023090-6fa23d38-2de8-42be-bf9f-723e7d5aea96.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><ol start="7"><li>重新设置重试策略，消费失败后投递到死信交换器中</li></ol><figure><img src="https://cdn.nlark.com/yuque/0/2021/png/21500944/1621907947653-84525cde-2b11-4af5-b43f-cc6fac106e95.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><ol start="8"><li>达到重试次数后投递到了死信队列</li></ol><figure><img src="https://cdn.nlark.com/yuque/0/2021/png/21500944/1621907762576-bc9e06d4-7d47-474b-ae67-bbc71f4b4466.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><figure><img src="https://cdn.nlark.com/yuque/0/2021/png/21500944/1621907904712-764f0175-2779-43e5-a278-535570ab7591.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h4 id="manual" tabindex="-1"><a class="header-anchor" href="#manual" aria-hidden="true">#</a> Manual</h4><p>根据执行情况手动确认，执行结束后需要手动ack或者nack。</p><ol><li>设置确认状态为手动确认</li></ol><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/1621494375003-a23a79b2-d5f4-48cf-93cc-ba82f8f8b04c-20230226022615505.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><ol start="2"><li>无论是抛出异常还是正常消费，都需要做手动确认。</li></ol><figure><img src="https://cdn.nlark.com/yuque/0/2021/png/21500944/1621495263426-7a041ef9-8893-4680-adf6-2af90af992d5.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><ol start="3"><li>未进行手动确认，RabbitMQ认为消息仍在消费中，如下图有unack状态的一条消息。</li></ol><figure><img src="https://cdn.nlark.com/yuque/0/2021/png/21500944/1621495452110-624c2a99-a838-4330-a1f8-cb846ce9d5b8.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><ol start="4"><li>未设置消息TTL的情况下，等消费者断开连接后，消息重新入队变成ready状态，有新的消费者连接后投递给它，断开消费者连接后情况入下图：</li></ol><figure><img src="https://cdn.nlark.com/yuque/0/2021/png/21500944/1621495600862-12ba94c8-b462-4e65-8240-eeb27b4e918c.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><hr><h3 id="消息积压" tabindex="-1"><a class="header-anchor" href="#消息积压" aria-hidden="true">#</a> 消息积压</h3><p>出现这种情况，先紧急处理现场的情况， 将RabbitMQ服务中堆积的阻塞的消息消费掉，目前能尽快处理的方案可以如下操作:</p><ul><li><p>一般只有比较重要的业务消息才会存储在磁盘中进行持久化（这样做主要是为了提高rabbitMQ的性能，消息全部持久化的话，对RabbitMQ的性能损耗是很高的）</p></li><li><p>可以通过新增多个消费者来监听业务队列来提高消息的消费速度</p></li><li><p>或者通过设置并发提高消息的消费速度</p></li></ul><p>消息阻塞常见的有两种情况：</p><ul><li><p>消息生产的速度大于消息消费的速度</p></li><li><p>架构设计有问题，对于消费失败的消息没有采取措施，导致消费失败的消息不断被RabbitMQ重新发送给消费者，导致消息阻塞</p></li></ul><p>针对上面两种情况，我们分别进行处理</p><ul><li><p>消息生产的速度大于消息消费的速度，我们可以设置channel.basicQos(n)来限制RabbitMQ队列中最大的未确认的消息数量，超过这个数量，RabbitMQ就不在接收生产者生产的消息，这个也是RabbitMQ的优点：削峰填谷</p></li><li><p>针对第二个，需要修改架构设计，我们一方面可以通过给队列设置死信队列，同时消费端进行业务控制，如果同一个消息被消费端同时消费几次数量以上将该消息手动拒绝，这样消息就会进入死信队列，然后由死信队列进行消息的持久化，或者其他的处理。</p></li></ul><h3 id="消息幂等" tabindex="-1"><a class="header-anchor" href="#消息幂等" aria-hidden="true">#</a> 消息幂等</h3><p>RabbitMQ保证消息的&quot;At Least Once&quot; 或 “At Most Once” , 实际使用中多采用至少一次的模式，可能导致重复消费的问题，这时候就需要保证消息处理的幂等。</p><p>一般来说会采取两种方式，涉及到金融对账等场景的使用数据库做强校验，其他场景可以使用Redis做弱检验。</p><h4 id="数据库强校验" tabindex="-1"><a class="header-anchor" href="#数据库强校验" aria-hidden="true">#</a> 数据库强校验</h4><p>首先我们需要为消息生成一个全局唯一ID，将ID作为数据库主键，就可以进行去重。即在消费消息前，执行insert操作，如果抛出主键冲突异常就代表已经被消费了，消息可以丢弃。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>	 <span class="token class-name">EventLog</span> eventLog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EventLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isNotEmpty</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getMessageProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMessageId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
           	eventLog<span class="token punctuation">.</span><span class="token function">setEventId</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getMessageProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMessageId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        eventLog<span class="token punctuation">.</span><span class="token function">setEventCode</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getMessageProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getReceivedRoutingKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        eventLog<span class="token punctuation">.</span><span class="token function">setCreateTime</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        eventLog<span class="token punctuation">.</span><span class="token function">setSend</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getMessageProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAppId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        eventLog<span class="token punctuation">.</span><span class="token function">setCustomNum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        eventLog<span class="token punctuation">.</span><span class="token function">setPublictTime</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getMessageProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTimestamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            eventLog<span class="token punctuation">.</span><span class="token function">setMessage</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Charset</span><span class="token punctuation">.</span><span class="token function">defaultCharset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">UnsupportedEncodingException</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">try</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>eventLog<span class="token punctuation">.</span><span class="token function">getEventId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                eventLog<span class="token punctuation">.</span><span class="token function">setEventId</span><span class="token punctuation">(</span><span class="token class-name">SequenceUtil</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token class-name">TableIdCode</span><span class="token punctuation">.</span><span class="token constant">ID_EVENT_LOG</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            eventLogMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>eventLog<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">DuplicateKeyException</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>
            eventLog <span class="token operator">=</span> eventLogInnerService<span class="token punctuation">.</span><span class="token function">queryByKey</span><span class="token punctuation">(</span>eventLog<span class="token punctuation">.</span><span class="token function">getEventId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            eventLog<span class="token punctuation">.</span><span class="token function">setCustomNum</span><span class="token punctuation">(</span>eventLog<span class="token punctuation">.</span><span class="token function">getCustomNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            eventLogMapper<span class="token punctuation">.</span><span class="token function">updateByKey</span><span class="token punctuation">(</span>eventLog<span class="token punctuation">)</span><span class="token punctuation">;</span>
            logger<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">&quot;消息重复消费……………………,{}&quot;</span><span class="token punctuation">,</span>e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="使用-redis做弱校验" tabindex="-1"><a class="header-anchor" href="#使用-redis做弱校验" aria-hidden="true">#</a> 使用 Redis做弱校验</h4><p>使用Redis 的原子性的命令，比如 set 命令，在接收到消息后将消息 ID 作为 key 去执行 set 命令，如果执行成功则表示没有执行过这条消息，可以进行消费。</p><h3 id="消息顺序" tabindex="-1"><a class="header-anchor" href="#消息顺序" aria-hidden="true">#</a> 消息顺序</h3><p>​ 消息队列可以保证消息将按顺序使用，但是它们不能提供处理顺序上的任何保证。这里的主要区别是消息处理的某些方面在消耗时间无法确定，例如：处理一条消息要比另一条消息花费更长的时间。因此，如果消息 1 的处理时间比另一条消息花费的时间更长，那么消息2和3可能会先处理完成。</p><p>​ 如果要确保处理顺序，需要确保队列只有 1 个消费者实例，前一条消息确认后再消费后续的消息。</p><h3 id="提高吞吐量" tabindex="-1"><a class="header-anchor" href="#提高吞吐量" aria-hidden="true">#</a> 提高吞吐量</h3><p>主要方法有增加消费者、提高 Prefetch count、多线程处理、批量 Ack 等。</p><ol><li>增加消费者</li></ol><p>多个消费者来消费同一队列，提高消费速度，不过有以下问题：</p><ul><li><p>后端处理能力：比如多个消费者都要操作数据库，那么数据库连接的并发数和读写吞吐量就是后端处理能力，如果达到了数据库的最大处理能力，增加再多的消费者也没有用，甚至会因为数据库拥塞导致整体消费速度的下降。</p></li><li><p>并发冲突：可以由数据库写入事务来处理并发冲突，或者使用分布式锁，对于具体的某个业务同时只能有一个消费者来处理。</p></li><li><p>处理顺序：如果消息需要被顺序处理，那么各个消费者之间还需要增加一个同步机制。</p></li></ul><p>可以使用消费者多节点或者单节点中增加消费数。</p><p>单节点增加消费数的配置如下：</p><figure><img src="https://cdn.nlark.com/yuque/0/2021/png/21500944/1621996272209-45b28dab-6f2a-4e7a-afba-1ce3b7aa85a0.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><ol start="2"><li>多线程处理</li></ol><p>​ 多线程处理不需要建立多个到 RabbitMQ 的连接，它在收到队列消息后将其放入不同的线程中进行处理，这样进程中就会有多个消息同时处理，增加了消费吞吐量，从而提升了消费速度。</p><ol start="3"><li>提高 Prefetch count</li></ol><p>​ 消息消费速度主要受到发送消息时间、消费者处理时间、消息 Ack 时间这几个时间的影响，如果一个消息走完这个流程再发送另一个的话，效率将会非常低。可以让消息在这几个时间内恰当的分配，让消息总是连续不断的被消费者接收处理，就可以提升消费者的消费速度。</p><p>​ 根据如上描述，有些消息可能正在被消费者处理，有些可能在等待消费者处理，有的消息可能还在网络传输中，而如果不限制传输的数量，消费者端可能因处理能力补足会堆积大量的消息，首先内存使用将不可控制，其次此时也无法将这些消息再分配给别的消费者。因此才有了 Prefetch count，用于控制消息发送给消费者的速度；这个方案需要配合 Ack 使用，消费者回复消息 Ack 后，RabbitMQ 才会继续发送同等数量的消息到消费者。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/1621996427949-f07f9aff-a857-4850-aab1-16725f625327-20230226023013811.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><ol start="4"><li>批量 Ack</li></ol><p>​ 这种方式有效的原理是：每条消息分别 Ack 的情况下，RabbitMQ 收到一个 Ack 才发送一条消息，这中间就会有很多的时间在等待 Ack 回来，通过批量 Ack 的方式，减少了很多 Ack 传输的时间。注意这里隐含的方式是 RabbitMQ 通过设置的 Prefetch count 连续向消费者发送多条消息，否则这个批量就没意义了。</p><h3 id="削峰" tabindex="-1"><a class="header-anchor" href="#削峰" aria-hidden="true">#</a> 削峰</h3><p>​ 如果完全不配置QoS，这样Rabbit会尽可能快速地发送队列中的所有消息到客户端。consumer在本地缓存所有的message，从而极有可能导致OOM或者导致服务器内存不足影响其它进程的正常运行。我们需要通过设置Qos的prefetch count来控制consumer的流量。</p><p>通过Qos设置消费者每次获取的消息数，spring-amqp 1.0 下默认值是1，spring-amqp 2.0下默认值是250。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/1622008890349-e86009ff-acc3-4fac-8fad-8fbe2823b4f7-20230226023031384.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>例子如下：</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/1622008271830-18745610-5d1d-4fc6-8ea6-62f1d3fbcd06-20230226023036880.svg" alt="调用.svg" tabindex="0" loading="lazy"><figcaption>调用.svg</figcaption></figure><p>在生产者产生大量消息的情况下，配置消费者Qos限制每次获取到的消息数，平稳消费消息，达到削峰的效果。</p><h2 id="rabbitmq-与spring的集成" tabindex="-1"><a class="header-anchor" href="#rabbitmq-与spring的集成" aria-hidden="true">#</a> RabbitMQ 与Spring的集成</h2><h3 id="与springboot的集成" tabindex="-1"><a class="header-anchor" href="#与springboot的集成" aria-hidden="true">#</a> 与Springboot的集成</h3><p>添加amqp的starter</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/1620884044889-63010f4c-6dc0-435b-a756-7100eef2bf44-20230226023119932.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>将交换器，队列，绑定关系注册为bean进行初始化</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/1620884084682-9e9d54b6-c980-4e92-ac47-a369c43dee5c-20230226023110483.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>使用rabbitTemplate发送消息</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/1620884255822-33798b99-3f8c-43ae-ad06-fe3127716931-20230226023105821.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>消费者指定队列与消费消息体进行消息，RabbitMQ会将消息投递给消费者</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/1620884368631-71595213-2bb0-4712-a268-37745150ed48-20230226023103319.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><hr>`,223),p=[s];function c(o,l){return n(),e("div",null,p)}const g=a(i,[["render",c],["__file","RabbitMQ.html.vue"]]);export{g as default};
