const e=JSON.parse('{"key":"v-0380b219","path":"/interview/Redis/Redis.html","title":"Redis","lang":"zh-CN","frontmatter":{"description":"Redis [toc] 概述 Redis为什么快 Redis是纯内存数据库，一般都是简单的存取操作，线程占用的时间很多，时间的花费主要集中在IO上，所以读取速度快。 Redis使用的是非阻塞IO、IO多路复用，使用了单线程来轮询描述符，将数据库的开、关、读、写都转换成了事件，减少了线程切换时上下文的切换和竞争。 Redis采用了单线程的模型，保证了每个操作的原子性，也减少了线程的上下文切换和竞争。 Redis避免了多线程的锁的消耗。 Redis采用自己实现的事件分离器，效率比较高，内部采用非阻塞的执行方式，吞吐能力比较大。","head":[["meta",{"property":"og:url","content":"https://newzone.top/MyNotes/interview/Redis/Redis.html"}],["meta",{"property":"og:site_name","content":"nocetfy"}],["meta",{"property":"og:title","content":"Redis"}],["meta",{"property":"og:description","content":"Redis [toc] 概述 Redis为什么快 Redis是纯内存数据库，一般都是简单的存取操作，线程占用的时间很多，时间的花费主要集中在IO上，所以读取速度快。 Redis使用的是非阻塞IO、IO多路复用，使用了单线程来轮询描述符，将数据库的开、关、读、写都转换成了事件，减少了线程切换时上下文的切换和竞争。 Redis采用了单线程的模型，保证了每个操作的原子性，也减少了线程的上下文切换和竞争。 Redis避免了多线程的锁的消耗。 Redis采用自己实现的事件分离器，效率比较高，内部采用非阻塞的执行方式，吞吐能力比较大。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[]}"]]},"headers":[{"level":2,"title":"概述","slug":"概述","link":"#概述","children":[{"level":3,"title":"Redis为什么快","slug":"redis为什么快","link":"#redis为什么快","children":[]},{"level":3,"title":"应用场景","slug":"应用场景","link":"#应用场景","children":[]}]},{"level":2,"title":"线程模型","slug":"线程模型","link":"#线程模型","children":[{"level":3,"title":"单线程","slug":"单线程","link":"#单线程","children":[]},{"level":3,"title":"事件驱动模型","slug":"事件驱动模型","link":"#事件驱动模型","children":[]},{"level":3,"title":"多线程使用","slug":"多线程使用","link":"#多线程使用","children":[]}]},{"level":2,"title":"数据结构与实现","slug":"数据结构与实现","link":"#数据结构与实现","children":[{"level":3,"title":"基本数据类型","slug":"基本数据类型","link":"#基本数据类型","children":[]},{"level":3,"title":"Hash（哈希）","slug":"hash-哈希","link":"#hash-哈希","children":[]},{"level":3,"title":"List（列表）","slug":"list-列表","link":"#list-列表","children":[]},{"level":3,"title":"Set（集合）","slug":"set-集合","link":"#set-集合","children":[]},{"level":3,"title":"ZSet（Sorted Set 有序集合）","slug":"zset-sorted-set-有序集合","link":"#zset-sorted-set-有序集合","children":[]},{"level":3,"title":"压缩","slug":"压缩","link":"#压缩","children":[]},{"level":3,"title":"key规范","slug":"key规范","link":"#key规范","children":[]}]},{"level":2,"title":"过期删除策略与内存淘汰策略","slug":"过期删除策略与内存淘汰策略","link":"#过期删除策略与内存淘汰策略","children":[{"level":3,"title":"过期删除策略","slug":"过期删除策略","link":"#过期删除策略","children":[]},{"level":3,"title":"内存淘汰策略","slug":"内存淘汰策略","link":"#内存淘汰策略","children":[]}]},{"level":2,"title":"事务","slug":"事务","link":"#事务","children":[]},{"level":2,"title":"Pipeline","slug":"pipeline","link":"#pipeline","children":[{"level":3,"title":"与事务(multi)的区别","slug":"与事务-multi-的区别","link":"#与事务-multi-的区别","children":[]}]},{"level":2,"title":"持久化","slug":"持久化","link":"#持久化","children":[{"level":3,"title":"RDB","slug":"rdb","link":"#rdb","children":[]},{"level":3,"title":"AOF","slug":"aof","link":"#aof","children":[]}]},{"level":2,"title":"主从复制","slug":"主从复制","link":"#主从复制","children":[{"level":3,"title":"主从复制的作用","slug":"主从复制的作用","link":"#主从复制的作用","children":[]},{"level":3,"title":"主从复制原理","slug":"主从复制原理","link":"#主从复制原理","children":[]},{"level":3,"title":"为什么主从全量复制使用RDB而不使用AOF？","slug":"为什么主从全量复制使用rdb而不使用aof","link":"#为什么主从全量复制使用rdb而不使用aof","children":[]}]},{"level":2,"title":"高可用","slug":"高可用","link":"#高可用","children":[{"level":3,"title":"主从模型","slug":"主从模型","link":"#主从模型","children":[]},{"level":3,"title":"哨兵机制(Sentinel)","slug":"哨兵机制-sentinel","link":"#哨兵机制-sentinel","children":[]},{"level":3,"title":"集群","slug":"集群","link":"#集群","children":[]},{"level":3,"title":"Redis Cluster","slug":"redis-cluster","link":"#redis-cluster","children":[]}]},{"level":2,"title":"常见问题","slug":"常见问题","link":"#常见问题","children":[{"level":3,"title":"缓存穿透","slug":"缓存穿透","link":"#缓存穿透","children":[]},{"level":3,"title":"缓存击穿","slug":"缓存击穿","link":"#缓存击穿","children":[]},{"level":3,"title":"缓存雪崩","slug":"缓存雪崩","link":"#缓存雪崩","children":[]},{"level":3,"title":"保证缓存与数据库一致性","slug":"保证缓存与数据库一致性","link":"#保证缓存与数据库一致性","children":[]},{"level":3,"title":"redis keys执行了会怎么样","slug":"redis-keys执行了会怎么样","link":"#redis-keys执行了会怎么样","children":[]},{"level":3,"title":"热key","slug":"热key","link":"#热key","children":[]},{"level":3,"title":"大key","slug":"大key","link":"#大key","children":[]}]},{"level":2,"title":"性能优化","slug":"性能优化","link":"#性能优化","children":[{"level":3,"title":"线上性能","slug":"线上性能","link":"#线上性能","children":[]}]},{"level":2,"title":"命令执行过程","slug":"命令执行过程","link":"#命令执行过程","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":60.46,"words":18139},"filePathRelative":"interview/Redis/Redis.md","excerpt":"<h1> Redis</h1>\\n<p>[toc]</p>\\n<h2> 概述</h2>\\n<h3> Redis为什么快</h3>\\n<ol>\\n<li>Redis是纯内存数据库，一般都是简单的存取操作，线程占用的时间很多，时间的花费主要集中在IO上，所以读取速度快。</li>\\n<li>Redis使用的是非阻塞IO、IO多路复用，使用了单线程来轮询描述符，将数据库的开、关、读、写都转换成了事件，减少了线程切换时上下文的切换和竞争。</li>\\n<li>Redis采用了单线程的模型，保证了每个操作的原子性，也减少了线程的上下文切换和竞争。</li>\\n<li>Redis避免了多线程的锁的消耗。</li>\\n<li>Redis采用自己实现的事件分离器，效率比较高，内部采用非阻塞的执行方式，吞吐能力比较大。</li>\\n</ol>","autoDesc":true}');export{e as data};
