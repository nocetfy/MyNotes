import{_ as d,H as r,X as n,Y as c,Z as a,a0 as e,a1 as o,$ as t}from"./framework-47f15ee6.js";const h={},l=t('<h1 id="网络" tabindex="-1"><a class="header-anchor" href="#网络" aria-hidden="true">#</a> 网络</h1><p>[toc]</p><h2 id="基础" tabindex="-1"><a class="header-anchor" href="#基础" aria-hidden="true">#</a> 基础</h2><h3 id="tcp-ip-4层网络模型" tabindex="-1"><a class="header-anchor" href="#tcp-ip-4层网络模型" aria-hidden="true">#</a> TCP/IP 4层网络模型</h3><p>TCP/IP 网络通常是由上到下分成 4 层，分别是<strong>应用层，传输层，网络层和网络接口层</strong>。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/tcpip参考模型.drawio.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/封装.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>​ 网络接口层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。</p><hr><h3 id="linux-怎么收发网络包的" tabindex="-1"><a class="header-anchor" href="#linux-怎么收发网络包的" aria-hidden="true">#</a> Linux 怎么收发网络包的</h3><p>​ 电脑与电脑之间通常都是通过网卡、交换机、路由器等网络设备连接到一起，那由于网络设备的异构性，国际标准化组织定义了一个七层的 OSI 网络模型，但是这个模型由于比较复杂，实际应用中并没有采用，而是采用了更为简化的 TCP/IP 模型，Linux 网络协议栈就是按照了该模型来实现的。</p><p>​ TCP/IP 模型主要分为应用层、传输层、网络层、网络接口层四层，每一层负责的职责都不同，这也是 Linux 网络协议栈主要构成部分。</p><p>​ 当应用程序通过 Socket 接口发送数据包，数据包会被网络协议栈从上到下进行逐层处理后，才会被送到网卡队列中，随后由网卡将网络包发送出去。</p><p>​ 而在接收网络包时，同样也要先经过网络协议栈从下到上的逐层处理，最后才会被送到应用程序。</p><p>​ 网卡是计算机里的一个硬件，专门负责接收和发送网络包，当网卡接收到一个网络包后，会通过 DMA 技术，将网络包写入到指定的内存地址，也就是写入到 Ring Buffer ，这个是一个环形缓冲区，接着就会告诉操作系统这个网络包已经到达。那应该怎么告诉操作系统这个网络包已经到达了呢？最简单的一种方式就是触发中断，也就是每当网卡收到一个网络包，就触发一个中断告诉操作系统。</p><p>为了解决频繁中断带来的性能开销，Linux 内核在 2.6 版本中引入了 <strong>NAPI 机制</strong>，它是混合「中断和轮询」的方式来接收网络包，它的核心概念就是<strong>不采用中断的方式读取数据</strong>，而是首先采用中断唤醒数据接收的服务程序，然后 <code>poll</code> 的方法来轮询数据。</p><p>因此，当有网络包到达时，会通过 DMA 技术，将网络包写入到指定的内存地址，接着网卡向 CPU 发起硬件中断，当 CPU 收到硬件中断请求后，根据中断表，调用已经注册的中断处理函数。</p><p>硬件中断处理函数会做如下的事情：</p><ul><li>需要先「暂时屏蔽中断」，表示已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知 CPU 了，这样可以提高效率，避免 CPU 不停的被中断。</li><li>接着，发起「软中断」，然后恢复刚才屏蔽的中断。</li></ul><p>至此，硬件中断处理函数的工作就已经完成。</p><p>硬件中断处理函数做的事情很少，主要耗时的工作都交给软中断处理函数了。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/收发流程.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h3 id="路由器" tabindex="-1"><a class="header-anchor" href="#路由器" aria-hidden="true">#</a> 路由器</h3>',24),s={href:"https://www.cloudflare-cn.com/learning/network-layer/what-is-a-packet/",target:"_blank",rel:"noopener noreferrer"},p={href:"https://www.cloudflare-cn.com/learning/dns/glossary/what-is-my-ip-address/",target:"_blank",rel:"noopener noreferrer"},P={href:"https://www.cloudflare-cn.com/learning/network-layer/what-is-a-lan/",target:"_blank",rel:"noopener noreferrer"},T={href:"https://www.cloudflare-cn.com/learning/network-layer/what-is-a-wan/",target:"_blank",rel:"noopener noreferrer"},u=t('<p>​ 与之相反，WAN 是一个分布在广大地理区域的大型网络。例如，在全国各地多个地点运营的大型组织和公司将需要为每个地点建立单独的 LAN，然后与其他 LAN 连接，形成一个 WAN。由于 WAN 分布在一个大的区域内，它通常需要多个路由器和交换机。</p><h3 id="浏览器输入一个链接到返回的全过程" tabindex="-1"><a class="header-anchor" href="#浏览器输入一个链接到返回的全过程" aria-hidden="true">#</a> 浏览器输入一个链接到返回的全过程</h3><ol><li>解析URL</li><li>发送HTTP请求信息</li><li>DNS解析查询真实IP地址</li><li>协议栈解析</li><li>TCP建立可靠传输</li><li>网络包生成IP头，远程定位</li><li>网络包生成MAC头，两点传输</li><li>网卡发送数据</li><li>交换机进行转发到路由器</li><li>路由器转发到服务端</li><li>服务端进行网络包拆解，解析数据。</li></ol><hr><h3 id="应用层协议" tabindex="-1"><a class="header-anchor" href="#应用层协议" aria-hidden="true">#</a> 应用层协议</h3><h4 id="底层基于udp的协议" tabindex="-1"><a class="header-anchor" href="#底层基于udp的协议" aria-hidden="true">#</a> 底层基于UDP的协议</h4><ul><li>DNS（域名系统）</li><li>TFTP（简单文件传输协议）</li><li>SNMP（简单网络管理协议）</li><li>RIP（路由信息协议）</li><li>QUIC（快速 UDP 互联网连接 ）</li><li>UDT（基于UDP的数据传输协议）</li></ul><h4 id="底层基于tcp的协议" tabindex="-1"><a class="header-anchor" href="#底层基于tcp的协议" aria-hidden="true">#</a> 底层基于TCP的协议</h4><ul><li>HTTP 超文本传输协议</li><li>WebSocket 全双工通信协议</li><li>SMTP 简单邮件传输协议</li><li>IMAP 邮件接收协议</li><li>FTP 文件传输协议</li><li>SSH 安全网络传输协议</li></ul><hr><h2 id="tcp" tabindex="-1"><a class="header-anchor" href="#tcp" aria-hidden="true">#</a> TCP</h2><h3 id="tcp为什么要三次握手" tabindex="-1"><a class="header-anchor" href="#tcp为什么要三次握手" aria-hidden="true">#</a> TCP为什么要三次握手</h3>',12),g={href:"https://tools.ietf.org/html/rfc793",target:"_blank",rel:"noopener noreferrer"},f=t('<ul><li>通过三次握手才能阻止重复历史连接的初始化；</li><li>通过三次握手才能对通信双方的初始序列号进行初始化；</li></ul><p>序列号在 TCP 连接中有着非常重要的作用，初始序列号作为 TCP 连接的一部分也需要在三次握手期间进行初始化，由于 TCP 连接通信的双方都需要获得初始序列号，所以它们其实需要向对方发送 <code>SYN</code> 控制消息并携带自己期望的初始化序列号 <code>SEQ</code>，对方在收到 <code>SYN</code> 消息之后会通过 <code>ACK</code> 控制消息以及 <code>SEQ+1</code> 来进行确认。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/basic-4-way-handshake.png" alt="basic-4-way-handshake" tabindex="0" loading="lazy"><figcaption>basic-4-way-handshake</figcaption></figure><p>如上图所示，通信双方的两个 <code>TCP A/B</code> 分别向对方发送 <code>SYN</code> 和 <code>ACK</code> 控制消息，等待通信双方都获取到了自己期望的初始化序列号之后就可以开始通信了，由于 TCP 消息头的设计，我们可以将中间的两次通信合成一个，<code>TCP B</code> 可以向 <code>TCP A</code> 同时发送 <code>ACK</code> 和 <code>SYN</code> 控制消息，这也就帮助我们将四次通信减少至三次。</p><p>如果通信双方的通信次数只有两次，那么发送方一旦发出建立连接的请求之后它就没有办法撤回这一次请求，如果在网络状况复杂或者较差的网络中，发送方连续发送多次建立连接的请求，如果 TCP 建立连接只能通信两次，那么接收方只能选择接受或者拒绝发送方发起的请求，它并不清楚这一次请求是不是由于网络拥堵而早早过期的连接。</p><p>所以，TCP 选择使用三次握手来建立连接并在连接引入了 <code>RST</code> 这一控制消息，接收方当收到请求时会将发送方发来的 <code>SEQ+1</code> 发送给对方，这时由发送方来判断当前连接是否是历史连接：</p><ul><li>如果当前连接是历史连接，即 <code>SEQ</code> 过期或者超时，那么发送方就会直接发送 <code>RST</code> 控制消息中止这一次连接；</li><li>如果当前连接不是历史连接，那么发送方就会发送 <code>ACK</code> 控制消息，通信双方就会成功建立连接；</li></ul><p>使用三次握手和 <code>RST</code> 控制消息将是否建立连接的最终控制权交给了发送方，因为只有发送方有足够的上下文来判断当前连接是否是错误的或者过期的，这也是 TCP 使用三次握手建立连接的最主要原因。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/tcp-recovery-from-old-duplicate-syn.png" alt="tcp-recovery-from-old-duplicate-syn" tabindex="0" loading="lazy"><figcaption>tcp-recovery-from-old-duplicate-syn</figcaption></figure><p>TCP 建立连接时通过三次握手可以有效地避免历史错误连接的建立，减少通信双方不必要的资源消耗，三次握手能够帮助通信双方获取初始化序列号，它们能够保证数据包传输的不重不丢，还能保证它们的传输顺序，不会因为网络传输的问题发生混乱，到这里不使用『两次握手』和『四次握手』的原因已经非常清楚了：</p><ul><li>『两次握手』：无法避免历史错误连接的初始化，浪费接收方的资源；</li><li>『四次握手』：TCP 协议的设计可以让我们同时传递 <code>ACK</code> 和 <code>SYN</code> 两个控制信息，减少了通信次数，所以不需要使用更多的通信次数传输相同的信息。</li></ul><h3 id="四次挥手" tabindex="-1"><a class="header-anchor" href="#四次挥手" aria-hidden="true">#</a> 四次挥手</h3><p>建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的半关闭（half-close）造成的。</p><p>所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p><p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。</p><h4 id="第一种回答" tabindex="-1"><a class="header-anchor" href="#第一种回答" aria-hidden="true">#</a> 第一种回答</h4><p>刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。</p><p>四次挥手的过程如下：</p><h5 id="第一次挥手" tabindex="-1"><a class="header-anchor" href="#第一次挥手" aria-hidden="true">#</a> 第一次挥手</h5><p>客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。 即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。</p><h5 id="第二次挥手" tabindex="-1"><a class="header-anchor" href="#第二次挥手" aria-hidden="true">#</a> 第二次挥手</h5><p>服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。 即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。</p><h5 id="第三次挥手" tabindex="-1"><a class="header-anchor" href="#第三次挥手" aria-hidden="true">#</a> 第三次挥手</h5><p>如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。 即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。</p><h5 id="第四次挥手" tabindex="-1"><a class="header-anchor" href="#第四次挥手" aria-hidden="true">#</a> 第四次挥手</h5><p>客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的确认号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。 即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。</p><p>收到一个FIN只意味着在这一方向上没有数据流动。客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。</p><p>在socket编程中，任何一方执行close()操作即可产生挥手操作。</p><h4 id="第二种回答" tabindex="-1"><a class="header-anchor" href="#第二种回答" aria-hidden="true">#</a> 第二种回答</h4><h5 id="初始化状态" tabindex="-1"><a class="header-anchor" href="#初始化状态" aria-hidden="true">#</a> 初始化状态</h5><p>客户端和服务端都在连接状态，接下来开始进行四次分手断开连接操作。</p><h5 id="第一次挥手-1" tabindex="-1"><a class="header-anchor" href="#第一次挥手-1" aria-hidden="true">#</a> 第一次挥手</h5><p>第一次分手无论是客户端还是服务端都可以发起，因为 TCP 是全双工的。 假如客户端发送的数据已经发送完毕，发送FIN = 1 告诉服务端，客户端所有数据已经全发完了，服务端你可以关闭接收了，但是如果你们服务端有数据要发给客户端，客户端照样可以接收的。此时客户端处于FIN = 1等待服务端确认释放连接状态。</p><h5 id="第二次挥手-1" tabindex="-1"><a class="header-anchor" href="#第二次挥手-1" aria-hidden="true">#</a> 第二次挥手</h5><p>服务端接收到客户端的释放请求连接之后，知道客户端没有数据要发给自己了，然后服务端发送ACK = 1告诉客户端收到你发给我的信息，此时服务端处于 CLOSE_WAIT 等待关闭状态。（服务端先回应给客户端一声，我知道了，但服务端的发送数据能力即将等待关闭，于是接下来第三次就来了。）</p><h5 id="第三次挥手-1" tabindex="-1"><a class="header-anchor" href="#第三次挥手-1" aria-hidden="true">#</a> 第三次挥手</h5><p>此时服务端向客户端把所有的数据发送完了，然后发送一个FIN = 1，用于告诉客户端，服务端的所有数据发送完毕，客户端你也可以关闭接收数据连接了。此时服务端状态处于LAST_ACK状态，来等待确认客户端是否收到了自己的请求。（服务端等客户端回复是否收到呢，不收到的话，服务端不知道客户端是不是挂掉了还是咋回事呢，所以服务端不敢关闭自己的接收能力，于是第四次就来了。）</p><h5 id="第四次挥手-1" tabindex="-1"><a class="header-anchor" href="#第四次挥手-1" aria-hidden="true">#</a> 第四次挥手</h5><p>此时如果客户端收到了服务端发送完的信息之后，就发送ACK = 1，告诉服务端，客户端已经收到了你的信息，有一个 2 MSL 的延迟等待。</p><h2 id="udp" tabindex="-1"><a class="header-anchor" href="#udp" aria-hidden="true">#</a> UDP</h2><h3 id="udp原理" tabindex="-1"><a class="header-anchor" href="#udp原理" aria-hidden="true">#</a> UDP原理</h3><p>​ UDP(User Datagram Protocol)即用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP用来支持那些需要在计算机之间传输数据的网络应用。包括网络视频会议系统在内的众多的客户/服务器模式的网络应用都需要使用UDP协议。UDP协议从问世至今已经被使用了很多年，虽然其最初的光彩已经被一些类似协议所掩盖，但是即使是在今天UDP仍然不失为一项非常实用和可行的网络传输层协议。UDP报文没有可靠性保证、顺序保证和流量控制字段等，可靠性较差。但是正因为UDP协议的控制选项较少，在数据传输过程中延迟小、数据传输效率高，适合对可靠性要求不高的应用程序，或者可以保障可靠性的应用程序，如DNS、TFTP、SNMP等。</p><h4 id="特点" tabindex="-1"><a class="header-anchor" href="#特点" aria-hidden="true">#</a> 特点</h4><p><code>UDP</code>提供不可靠服务，具有<code>TCP</code>所没有的优势：</p><ul><li><p><code>UDP</code><strong>无连接</strong>，时间上不存在建立连接需要的时延。空间上，<code>TCP</code>需要在端系统中维护连接状态，需要一定的开销。此连接装入包括接收和发送缓存，拥塞控制参数和序号与确认号的参数。<code>UCP</code>不维护连接状态，也不跟踪这些参数，开销小。空间和时间上都具有优势。</p><blockquote><p><code>DNS</code>如果运行在<code>TCP</code>之上而不是<code>UDP</code>，那么<code>DNS</code>的速度将会慢很多。 <code>HTTP</code>使用<code>TCP</code>而不是<code>UDP</code>，是因为对于基于文本数据的Web网页来说，可靠性很重要。 同一种专用应用服务器在支持<code>UDP</code>时，一定能支持更多的活动客户机。</p></blockquote></li><li><p><strong>分组首部开销小</strong>，<code>TCP</code>首部20字节，<code>UDP</code>首部8字节。</p></li><li><p><code>UDP</code><strong>没有拥塞控制</strong>，应用层能够更好的控制要发送的数据和发送时间，网络中的拥塞控制也不会影响主机的发送速率。某些实时应用要求以稳定的速度发送，能容忍一些数据的丢失，但是不能允许有较大的时延（比如实时视频，直播等）。</p></li><li><p><code>UDP</code>提供尽<strong>最大努力的交付，不保证可靠交付</strong>。所有维护传输可靠性的工作需要用户在应用层来完成。没有<code>TCP</code>的确认机制、重传机制。如果因为网络原因没有传送到对端，<code>UDP</code>也不会给应用层返回错误信息。</p></li><li><p><code>UDP</code>是<strong>面向报文的</strong>，对应用层交下来的报文，添加首部后直接乡下交付为IP层，既不合并，也不拆分，保留这些报文的边界。对IP层交上来<code>UDP</code>用户数据报，在去除首部后就原封不动地交付给上层应用进程，报文不可分割，是<code>UDP</code>数据报处理的最小单位。</p></li><li><blockquote><p>​ 正是因为这样，<code>UDP</code>显得不够灵活，不能控制读写数据的次数和数量。比如我们要发送100个字节的报文，我们调用一次<code>sendto</code>函数就会发送100字节，对端也需要用<code>recvfrom</code>函数一次性接收100字节，不能使用循环每次获取10个字节，获取十次这样的做法。</p></blockquote></li><li><p><code>UDP</code>常用一次性传输比较少量数据的网络应用，如<code>DNS</code>，<code>SNMP</code>等，因为对于这些应用，若是采用<code>TCP</code>，连接的创建，维护和拆除带来不小的开销。<code>UDP</code>也常用于多媒体应用（如IP电话，实时视频会议，流媒体等）数据的可靠传输对他们而言并不重要，<code>TCP</code>的拥塞控制会使他们有较大的延迟，也是不可容忍的。</p></li><li><p>UDP支持一对一、一对多、多对一和多对多。</p></li></ul><table><thead><tr><th style="text-align:center;">UDP(User Datagram Protocol)</th><th style="text-align:center;">TCP(Transmission Control Protocol)</th></tr></thead><tbody><tr><td style="text-align:center;">无连接</td><td style="text-align:center;">面向连接</td></tr><tr><td style="text-align:center;">支持一对一、一对多、多对一和多对多交互通信</td><td style="text-align:center;">每一条<code>TCP</code>连接只能有两个端点<code>EP</code>，只能一对一通信</td></tr><tr><td style="text-align:center;">对应用层交付的报文直接打包</td><td style="text-align:center;">面向字节流</td></tr><tr><td style="text-align:center;">尽最大努力交付，也就是不可靠；不使用流量控制和拥塞控制</td><td style="text-align:center;">可靠传输，使用流量控制和拥塞控制</td></tr><tr><td style="text-align:center;">首部开销小，仅8字节</td><td style="text-align:center;">首部最小20字节，最大60字节</td></tr></tbody></table><hr><h2 id="http" tabindex="-1"><a class="header-anchor" href="#http" aria-hidden="true">#</a> HTTP</h2><h3 id="https为什么是安全的" tabindex="-1"><a class="header-anchor" href="#https为什么是安全的" aria-hidden="true">#</a> HTTPS为什么是安全的</h3><p>​ HTTPS可以理解为 HTTP + SSL/TLS，通过SSL证书来验证服务器的身份，并且在浏览器和服务器之间的通信进行混合加密。TLS在传输加密中使用了混合加密，即同时使用对称加密和非对称加密；理由是非对称加密虽然更安全，但加解密速度和效率很低，而使用对称加密又需要解决密钥交换的问题，所以混合加密是使用非对称加密的方式解决对称加密的密钥交换问题。客户端用随机数产生对称算法使用的“会话密钥”（session key）后再使用公钥进行加密，服务端拿到密文后再用私钥解密，拿到session key作为后续对称加密使用的密钥。</p><p>浏览器验证证书的过程如下：</p><ul><li><p>浏览器从服务器拿到证书（证书内包含：服务器公钥、证书有效期、CA机构信息、数字签名等）</p></li><li><p>通过证书有效期、公钥等信息，再依据证书上给出的hash算法，进行hash得到一个值</p></li><li><p>通过本地预装的CA公钥列表(Windows上可以使用certlm.msc查看本地证书)，使用颁发者的公钥对签名进行解密，得到第二个hash值（也就是digest消息摘要）</p></li><li><p>比对两个hash值，如果值相同，则浏览器从服务器拿到的证书可信赖</p></li></ul><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/image-20230223002949110.png" alt="image-20230223002949110" align="left" style="zoom:50%;"><h3 id="http方法" tabindex="-1"><a class="header-anchor" href="#http方法" aria-hidden="true">#</a> http方法</h3><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/webp-20240120123121181" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="get与post区别" tabindex="-1"><a class="header-anchor" href="#get与post区别" aria-hidden="true">#</a> get与post区别</h3><p>GET在浏览器回退时是无害的，而POST会再次提交请求。 GET产生的URL地址可以被Bookmark，而POST不可以。 GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求在URL中传送的参数是有长度限制的，而POST么有。 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 GET参数通过URL传递，POST放在Request body中。</p><h3 id="http幂等性" tabindex="-1"><a class="header-anchor" href="#http幂等性" aria-hidden="true">#</a> http幂等性</h3><ul><li><p>GET用于获取资源，不管调用多少次接口，结果都不会改变，所以是幂等的。</p></li><li><p>PUT方法直接把实体部分数据替换到了服务器的资源，但我们多次调用它时，只会产生一次影响，即有相同结果的HTTP方法，所有满足幂等性</p></li><li><p>DELETE方法用于删除资源，会将资源删除，但调用一次和调用多次的影响是相同的，因此也满足幂等性</p></li><li><p>POST是一个非幂等方法，它会对资源本身产生影响，每次调用都会有新的资源产生，因此不满足幂等性</p></li><li><p>PATCH方法是非幂等的，因为它提供的实体需要根据程序或其他协议的定义，解析后在服务器上执行，以此来修改服务器上的资源。也就是若反复提交，程序可能执行多次，对服务器资源可能造成额外影响。</p></li></ul><hr><h3 id="cookie、session区别" tabindex="-1"><a class="header-anchor" href="#cookie、session区别" aria-hidden="true">#</a> Cookie、Session区别</h3><h4 id="概念" tabindex="-1"><a class="header-anchor" href="#概念" aria-hidden="true">#</a> 概念</h4><p>​ Cookie是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。</p><p>​ Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。</p><h4 id="区别" tabindex="-1"><a class="header-anchor" href="#区别" aria-hidden="true">#</a> 区别</h4><ul><li>作用范围不同，Cookie 保存在客户端（浏览器），Session 保存在服务器端。</li><li>存取方式的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。</li><li>有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。</li><li>隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。</li><li>存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。</li></ul><h4 id="联系" tabindex="-1"><a class="header-anchor" href="#联系" aria-hidden="true">#</a> 联系</h4><p>​ 用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建创建对应的 Session ，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。</p><h4 id="禁用cookie" tabindex="-1"><a class="header-anchor" href="#禁用cookie" aria-hidden="true">#</a> 禁用cookie</h4><p>​ Token 机制。Token 机制多用于 App 客户端和服务器交互的模式，也可以用于 Web 端做用户状态管理。</p><p>​ Token 的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。Token 机制和 Cookie 和 Session 的使用机制比较类似。当用户第一次登录后，服务器根据提交的用户信息生成一个 Token，响应时将 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次登录验证。</p><hr><h2 id="ip" tabindex="-1"><a class="header-anchor" href="#ip" aria-hidden="true">#</a> IP</h2>',73);function C(S,b){const i=r("ExternalLinkIcon");return n(),c("div",null,[l,a("p",null,[e("​ 路由器是连接两个或多个分组交换网络或子网络的设备。它有两个主要功能：通过将"),a("a",s,[e("数据包"),o(i)]),e("转发到其预定的 "),a("a",p,[e("IP 地址"),o(i)]),e("从而管理这些网络之间的流量，以及允许多个设备使用同一互联网连接。")]),a("p",null,[e("​ 路由器分为几种类型，但大多数路由器在 "),a("a",P,[e("LAN（局域网）"),o(i)]),e("和 "),a("a",T,[e("WAN（广域网）"),o(i)]),e("之间传递数据。LAN 是一组限制在特定地理区域的连接设备。一个 LAN 通常只需要一个路由器。")]),u,a("p",null,[a("a",g,[e("Transmission Control Protocol"),o(i)]),e(" 文档中非常清楚地定义了 TCP 中的连接是什么，我们简单总结一下：用于保证可靠性和流控制机制的信息，包括 Socket、序列号以及窗口大小叫做连接。")]),f])}const m=d(h,[["render",C],["__file","计算机网络.html.vue"]]);export{m as default};
