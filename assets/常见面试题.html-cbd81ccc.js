import{_ as a,X as e,Y as i,$ as l}from"./framework-47f15ee6.js";const r={},n=l('<h1 id="题目" tabindex="-1"><a class="header-anchor" href="#题目" aria-hidden="true">#</a> 题目</h1><p>[toc]</p><p>rr级别同一事务的修改为什么能读到。通过读视图readview校验到最新版本的事务id等于当前事务id时，可以读取。</p><h2 id="基础" tabindex="-1"><a class="header-anchor" href="#基础" aria-hidden="true">#</a> 基础</h2><h3 id="查询语句" tabindex="-1"><a class="header-anchor" href="#查询语句" aria-hidden="true">#</a> 查询语句</h3><h4 id="执行一条select语句-发生了什么" tabindex="-1"><a class="header-anchor" href="#执行一条select语句-发生了什么" aria-hidden="true">#</a> 执行一条select语句，发生了什么</h4><ol><li><p>连接器</p></li><li><p>查询缓存</p></li><li><p>解析SQL</p><ul><li>解析器</li></ul></li><li><p>执行SQL</p><ul><li>预处理器</li></ul><blockquote><ul><li>检查 SQL 查询语句中的表或者字段是否存在；</li><li>将 <code>select *</code> 中的 <code>*</code> 符号，扩展为表上的所有列；</li></ul></blockquote><ul><li>优化器</li></ul><blockquote><p>优化器主要负责将 SQL 查询语句的执行方案确定下来</p></blockquote><ul><li>执行器</li></ul><blockquote><p>三种执行过程</p><ul><li>主键索引查询</li><li>全表扫描</li><li>索引下推</li></ul></blockquote></li></ol><p>总结：</p><blockquote><ul><li>连接器：建立连接，管理连接、校验用户身份；</li><li>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</li><li>解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</li><li>执行 SQL：执行 SQL 共有三个阶段： <ul><li>预处理阶段：检查表或字段是否存在；将 <code>select *</code> 中的 <code>*</code> 符号扩展为表上的所有列。</li><li>优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；</li><li>执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li></ul></li></ul></blockquote><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/image-20240127223250758.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="记录存储" tabindex="-1"><a class="header-anchor" href="#记录存储" aria-hidden="true">#</a> 记录存储</h3><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/COMPACT.drawio.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h4 id="mysql-的-null-值是怎么存放的" tabindex="-1"><a class="header-anchor" href="#mysql-的-null-值是怎么存放的" aria-hidden="true">#</a> MySQL 的 NULL 值是怎么存放的？</h4><p>​ MySQL 的 Compact 行格式中会用「<strong>NULL值列表</strong>」来标记值为 NULL 的列，NULL 值并不会存储在行格式中的真实数据部分。NULL值列表会占用 1 字节空间，当表中所有字段都定义成 NOT NULL，行格式中就不会有 NULL值列表，这样可节省 1 字节的空间。「NULL 值列表」的空间不是固定 1 字节的。当一条记录有 9 个字段值都是 NULL，那么就会创建 2 字节空间的「NULL 值列表」，以此类推。</p><h4 id="mysql-怎么知道-varchar-n-实际占用数据的大小" tabindex="-1"><a class="header-anchor" href="#mysql-怎么知道-varchar-n-实际占用数据的大小" aria-hidden="true">#</a> MySQL 怎么知道 varchar(n) 实际占用数据的大小？</h4><p>​ MySQL 的 Compact 行格式中会用「变长字段长度列表」存储变长字段实际占用的数据大小。</p><h4 id="varchar-n-中-n-最大取值为多少" tabindex="-1"><a class="header-anchor" href="#varchar-n-中-n-最大取值为多少" aria-hidden="true">#</a> varchar(n) 中 n 最大取值为多少？</h4><p>​ 一行记录最大能存储 65535 字节的数据，但是这个是包含「变长字段字节数列表所占用的字节数」和「NULL值列表所占用的字节数」。所以， 我们在算 varchar(n) 中 n 最大值时，需要减去这两个列表所占用的字节数。</p><p>如果一张表只有一个 varchar(n) 字段，且允许为 NULL，字符集为 ascii。varchar(n) 中 n 最大取值为 65532。</p><p>计算公式：65535 - 变长字段字节数列表所占用的字节数 - NULL值列表所占用的字节数 = 65535 - 2 - 1 = 65532。</p><p>如果有多个字段的话，要保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 &lt;= 65535。</p><h4 id="行溢出后-mysql-是怎么处理的" tabindex="-1"><a class="header-anchor" href="#行溢出后-mysql-是怎么处理的" aria-hidden="true">#</a> 行溢出后，MySQL 是怎么处理的？</h4><p>如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。</p><p>Compact 行格式针对行溢出的处理是这样的：当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。</p><p>Compressed 和 Dynamic 这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中。</p><hr><h2 id="索引" tabindex="-1"><a class="header-anchor" href="#索引" aria-hidden="true">#</a> 索引</h2><h4 id="索引分类" tabindex="-1"><a class="header-anchor" href="#索引分类" aria-hidden="true">#</a> 索引分类</h4><ul><li>按「数据结构」分类：<strong>B+tree索引、Hash索引、Full-text索引</strong>。</li><li>按「物理存储」分类：<strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong>。</li><li>按「字段特性」分类：<strong>主键索引、唯一索引、普通索引、前缀索引</strong>。</li><li>按「字段个数」分类：<strong>单列索引、联合索引</strong>。</li></ul><h2 id="事务" tabindex="-1"><a class="header-anchor" href="#事务" aria-hidden="true">#</a> 事务</h2><h4 id="只读事务有什么用" tabindex="-1"><a class="header-anchor" href="#只读事务有什么用" aria-hidden="true">#</a> 只读事务有什么用</h4><p>​ 如果你一次执行单条查询语句，则没有必要启用事务支持，数据库默认支持SQL执行期间的读一致性； 如果你一次执行多条查询语句，例如统计查询，报表查询，在这种场景下，多条查询SQL必须保证整体的读一致性，否则，在前条SQL查询之后，后条SQL查询之前，数据被其他用户改变，则该次整体的统计查询将会出现读数据不一致的状态，此时，应该启用事务支持。 【注意是一次执行多次查询来统计某些信息，这时为了保证数据整体的一致性，要用只读事务】</p><p>很明显，<code>@Transactional(readOnly = true)</code>有很多优点。</p><ul><li>性能改进：只读实体不进行脏检查</li><li>节省内存：不维护持久状态的快照</li><li>数据一致性：只读实体的更改不会持久化</li><li>当我们使用主从或读写副本集（或集群）时，<code>@Transactional(readOnly = true)</code>使我们能够连接到只读数据库。在将事务设置成只读后，相当于将数据库设置成只读数据库，此时若要进行写的操作，会出现错误。</li></ul><p>但是，您还应该记住，<code>@Transactional(readOnly = true)</code>在服务层的方法中可能会导致数据库死锁、性能低下和数据库连接匮乏！</p><p>当您需要将只读查询仅仅作为一个事务执行时，请毫不犹豫选择的在服务层的方法中使用<code>@Transactional(readOnly = true)</code>，如果你的服务层的方法中有大量其他逻辑方法时，就要做取舍了！</p>',36),t=[n];function c(d,h){return e(),i("div",null,t)}const s=a(r,[["render",c],["__file","常见面试题.html.vue"]]);export{s as default};
