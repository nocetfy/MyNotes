import{_ as n,X as s,Y as a,$ as e}from"./framework-47f15ee6.js";const t={},p=e(`<h1 id="java-io" tabindex="-1"><a class="header-anchor" href="#java-io" aria-hidden="true">#</a> Java IO</h1><h3 id="阻塞io" tabindex="-1"><a class="header-anchor" href="#阻塞io" aria-hidden="true">#</a> 阻塞IO</h3><h4 id="本地io" tabindex="-1"><a class="header-anchor" href="#本地io" aria-hidden="true">#</a> 本地IO</h4><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/image-20230604224850936.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>大致可以概括为如下几个过程：</p><ul><li><code>in.read(buf)</code>执行时，程序向内核发起 <code>read()</code>系统调用；</li><li>操作系统发生上下文切换，由用户态(User mode)切换到内核态(Kernel mode)，把数据读取到内核缓冲区 （buffer）中；</li><li>内核把数据从内核空间拷贝到用户空间，同时由内核态转为用户态；</li><li>继续执行 <code>out.write(buf)</code>；</li><li>再次发生上下文切换，将数据从用户空间buffer拷贝到内核空间buffer中，由内核把数据写入文件。</li></ul><h4 id="网络io" tabindex="-1"><a class="header-anchor" href="#网络io" aria-hidden="true">#</a> 网络IO</h4><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/640.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li>客户端调用<code>connect()</code>函数，开始3次握手，首先发送一个<code>SYN X</code>的报文（<code>X</code>是个数字，下同）；</li><li>服务端收到来自客户端的<code>SYN</code>，然后在监听socket对应的半连接队列中创建一个新的socket，然后对客户端发回响应<code>SYN Y</code>，捎带手对客户端的报文给个<code>ACK</code>；</li><li>直到客户端完成第3次握手，刚才新创建的socket就会被转移到已连接队列；</li><li><strong>当进程调用<code>accept()</code>时，会将已连接队列头部的socket返回；如果已连接队列为空，那么进程将被睡眠，直到已连接队列中有新的socket，进程才会被唤醒，将这个socket返回</strong>。</li></ol><p>拿Server端的BIO来说明这个问题，阻塞在了<code>serverSocket.accept()</code>以及<code>bufferedReader.readLine()</code>这两个地方。有什么办法可以证明阻塞吗？</p><p>​ 简单的很！你在<code>serverSocket.accept();</code> 的下一行打个断点，然后debug模式运行<code>BIOServerSocket</code>，在没有客户端连接的情况下，这个断点绝不会触发！同样，在<code>bufferedReader.readLine();</code>下一行打个断点，在已连接的客户端发送数据之前，这个断点绝不会触发！</p><p><code> readLine()</code>的阻塞还带来一个非常严重的问题，如果已经连接的客户端一直不发送消息，<code>readLine()</code>进程就会一直阻塞（处于睡眠状态），结果就是代码不会再次运行到<code>accept()</code>，这个<code>ServerSocket</code>没办法接受新的客户端连接。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/image-20230603234401468.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>​ BIO之所以是BIO，是因为系统底层调用是阻塞的，上图中的进程调用<code>recv</code>，其系统调用直到数据包准备好并且被复制到应用程序的缓冲区或者发生错误为止才会返回，在此整个期间，进程是被阻塞的，啥也干不了。(每一个客户端连接都对应一个服务器线程)。</p><hr><h3 id="非阻塞io" tabindex="-1"><a class="header-anchor" href="#非阻塞io" aria-hidden="true">#</a> 非阻塞IO</h3><p>服务器只提供一个线程处理所有请求，一个线程对应多个客户端的连接。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/image-20230603234959997.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>系统调用向内核要数据时，内核的动作分成两步：</p><ol><li>等待数据（从网卡缓冲区拷贝到内核缓冲区）</li><li>拷贝数据（数据从内核缓冲区拷贝到用户空间）</li></ol><p>只有在第1步时，系统调用是非阻塞的，第2步进程依然需要等待这个拷贝过程，然后才能返回，这一步是阻塞的。</p><p>​ 非阻塞IO模型仅用一个线程就能处理所有操作，对比BIO的一个客户端需要一个线程而言进步还是巨大的。但是他的致命问题在于会不停地进行系统调用，不停的进行<code>accept()</code>，不停地对连接socket进行<code>read()</code>操作，即使大部分时间都是白忙活。要知道，系统调用涉及到用户空间和内核空间的多次转换，会严重影响整体性能。</p><hr><h3 id="io多路复用" tabindex="-1"><a class="header-anchor" href="#io多路复用" aria-hidden="true">#</a> IO多路复用</h3><p>​ 非阻塞IO使用一个线程就可以处理所有socket，但是付出的代价是必须频繁调用系统调用来轮询每一个socket的数据，这种轮询太耗费性能，而且大部分轮询都是空轮询。我们希望有个组件能同时监控多个socket，并在socket把数据准备好的时候告诉进程哪些socket已<strong>就绪</strong>，然后进程只对就绪的socket进行数据读写。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/image-20230604203812252.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NIOServer</span> <span class="token punctuation">{</span>

    <span class="token keyword">static</span> <span class="token class-name">Selector</span> selector<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// 获得selector多路复用器</span>
            selector <span class="token operator">=</span> <span class="token class-name">Selector</span><span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token class-name">ServerSocketChannel</span> serverSocketChannel <span class="token operator">=</span> <span class="token class-name">ServerSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 监听socket的accept将不会阻塞</span>
            serverSocketChannel<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            serverSocketChannel<span class="token punctuation">.</span><span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span><span class="token number">8099</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// 需要把监听socket注册到多路复用器上，并告诉selector，需要关注监听socket的OP_ACCEPT事件</span>
            serverSocketChannel<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> <span class="token class-name">SelectionKey</span><span class="token punctuation">.</span><span class="token constant">OP_ACCEPT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 该方法会阻塞</span>
                selector<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token comment">// 得到所有就绪的事件，事件被封装成了SelectionKey</span>
                <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SelectionKey</span><span class="token punctuation">&gt;</span></span> selectionKeys <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">selectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SelectionKey</span><span class="token punctuation">&gt;</span></span> iterator <span class="token operator">=</span> selectionKeys<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token class-name">SelectionKey</span> key <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    iterator<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isAcceptable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token function">handleAccept</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isReadable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token function">handleRead</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isWritable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token comment">//发送数据</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
	
    <span class="token comment">// 处理「读」事件的业务逻辑</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">handleRead</span><span class="token punctuation">(</span><span class="token class-name">SelectionKey</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">SocketChannel</span> socketChannel <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">SocketChannel</span><span class="token punctuation">)</span> key<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ByteBuffer</span> allocate <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            socketChannel<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>allocate<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;From Client:&quot;</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>allocate<span class="token punctuation">.</span><span class="token function">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

  	<span class="token comment">// 处理「连接」事件的业务逻辑</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">handleAccept</span><span class="token punctuation">(</span><span class="token class-name">SelectionKey</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ServerSocketChannel</span> serverSocketChannel <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ServerSocketChannel</span><span class="token punctuation">)</span> key<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// socketChannel一定是非空，并且这里不会阻塞</span>
            <span class="token class-name">SocketChannel</span> socketChannel <span class="token operator">=</span> serverSocketChannel<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 将连接socket的读写设置为非阻塞</span>
            socketChannel<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            socketChannel<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">wrap</span><span class="token punctuation">(</span><span class="token string">&quot;Hello Client， I am Server！&quot;</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 注册连接socket的「读事件」</span>
            socketChannel<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> <span class="token class-name">SelectionKey</span><span class="token punctuation">.</span><span class="token constant">OP_READ</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ 我们首先使用<code>Selector.open();</code>得到了<code>selector</code>这个多路复用对象；然后在服务端创建了监听socket，并将其设置为<strong>非阻塞</strong>，最后将监听socket注册到<code>selector</code>多路复用器上，并告诉<code>selector</code>，如果监听socket有<code>OP_ACCEPT</code>事件发生的话就要告诉我们。</p><p>​ 我们在while循环中调用<code>selector.select();</code>方法，进程将会阻塞在该方法上，直到注册在<code>selector</code>上的任意一个socket有事件发生为止，才会返回。如果不信的话可以在<code>selector.select();</code>的下一行打个断点，debug模式运行后，在没有客户端连接的情况下断点不会被触发。</p><p>​ 当<code>select()</code>返回，意味着有一个或多个socket已经处于就绪状态，我们使用<code>Set&lt;SelectionKey&gt;</code>来保存所有事件，<code>SelectionKey</code>封装了就绪的事件，我们循环每个事件，根据不同的事件类型进行不同的业务逻辑处理。</p><p><code> OP_READ</code>事件就绪的话，我们就准备一个缓冲空间，将数据从内核空间读到缓冲中；如果是<code>OP_ACCEPT</code>就绪，那就调用监听socket的<code>accept()</code>方法得到连接socket，并且<code>accept()</code>不会阻塞，因为在最开始的时候我们已经将监听socket设置为非阻塞了。得到的连接socket同样需要设置为非阻塞，这样连接socket的读写操作就是非阻塞的，最后将连接socket注册到<code>selector</code>多路复用器上，并告诉<code>selector</code>，如果连接socket有<code>OP_READ</code>事件发生的话就要告诉我们。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/2023-01-02-150949.gif" alt="多路复用" tabindex="0" loading="lazy"><figcaption>多路复用</figcaption></figure><p>​ 多路复用本质上就是同时监听多个socket的请求，当我们订阅的socket上有我们感兴趣的事件发生的时候，多路复用函数会返回，然后我们的用户程序根据返回结果继续处理这些就绪状态的socket。</p><p>但是，不同的多路复用模型在具体的实现上有所不同，主要体现在三个方面：</p><ol><li>多路复用模型最多可以同时监听多少个socket？</li><li>多路复用模型会监听socket上哪些事件？</li><li>当socket就绪时，多路复用模型如何找到就绪的socket？</li></ol><p>多路复用主要有3种，分别是<code>select</code>、<code>poll</code>和<code>epoll</code></p><h4 id="select" tabindex="-1"><a class="header-anchor" href="#select" aria-hidden="true">#</a> select</h4><p>​ 我们可以通过<code>select</code>告诉内核，我们对哪些描述符（这些描述符可以表示标准输入、监听socket或者连接socket等）的哪些事件（可读、可写、发生异常）感兴趣，或者某个超时时间之后直接返回。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// 返回：若有就绪描述符则为其数目，若超时则为0，若出错则为-1</span>
<span class="token keyword">int</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token keyword">int</span> nfds<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>readfds<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>writefds<span class="token punctuation">,</span>
                  fd_set <span class="token operator">*</span>exceptfds<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">timeval</span> <span class="token operator">*</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ <code>nfds</code>参数用来告诉<code>select</code>需要检查的描述符的个数，取值为我们感兴趣的最大描述符 + 1。<code>readfds</code>里保存的是我们对<strong>读就绪事件</strong>感兴趣的描述符，<code>writefds</code>保存的是我们对<strong>写就绪事件</strong>感兴趣的描述符，<code>exceptfds</code>保存的是我们对<strong>发生异常</strong>这种事件感兴趣的描述符。这三个参数会告诉内核，分别需要在哪些描述符上检测数据可读、可写以及发生异常。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// file: /usr/include/sys/select.h</span>
<span class="token comment">/* __fd_mask 是 long int 类型的别名  */</span>
<span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">int</span> __fd_mask<span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__NFDBITS</span>	<span class="token expression"><span class="token punctuation">(</span><span class="token number">8</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token keyword">sizeof</span> <span class="token punctuation">(</span>__fd_mask<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span>  <span class="token punctuation">{</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
   __fd_mask fds_bits<span class="token punctuation">[</span>__FD_SETSIZE <span class="token operator">/</span> __NFDBITS<span class="token punctuation">]</span><span class="token punctuation">;</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span> fd_set<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ 因此，<code>fd_set</code>的定义，其实就是<code>long int</code>类型的数组，元素个数为<code>__FD_SETSIZE / __NFDBITS</code>。该数组中一共有16个元素（1024 / 64 = 16），每个元素为long int类型，占64位。数组的第<code>1</code>个元素用于表示描述符<code>0～63</code>，第<code>2</code>个元素用于表示描述符<code>64～127</code>，以此类推，每1个bit位用<code>0</code>、<code>1</code>两种状态表示是否检测当前描述符的事件。</p><p>​ 假设我们对<code>{1, 4, 7}</code>号描述符的读就绪事件感兴趣，那么<code>readfds</code>参数的数组第1个元素的二进制表示就如下图所示，第1、4、7位分别被标记为1，实际存储的10进制数字为146。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/2023-01-11-015644.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>既然<code>fd_set</code>底层用的是数组，那就一定有长度限制，也就是说<strong>select同时监听的socket数量是有限的</strong>，长度为<code>1024</code>。</p><h5 id="阻塞" tabindex="-1"><a class="header-anchor" href="#阻塞" aria-hidden="true">#</a> 阻塞</h5><p>​ 当用户线程发起一个阻塞式的read系统调用，数据未就绪时，线程就会阻塞。阻塞其实是调用线程被投入睡眠，直到内核在某个时机唤醒线程，阻塞也就结束。内核会为每一个进程创建一个名为<code>task_struct</code>的数据结构，这个数据结构本身是分配在内核空间的，其中保存了当前进程的进程号、socket信息、CPU的运行上下文以及其他信息，Linux内核维护了一个<strong>执行队列</strong>，里边放的都是处于<code>TASK_RUNNING</code>状态的进程的<code>task_struct</code>，这些进程以双向链表的方式排队等待CPU极短时间的临幸。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/2023-01-12-014945.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>​ 阻塞的本质就是将进程的<code>task_struct</code>移出执行队列，让出CPU的调度，将进程的状态的置为<code>TASK_UNINTERRUPTIBLE</code>或者<code>TASK_INTERRUPTIBLE</code>，然后添加到<strong>等待队列</strong>中，直到被唤醒。那这个等待队列在哪儿呢？比如我们对一个socket发起一个阻塞式的 <code>read</code> 调用，用户进程肯定是需要和这个socket进行绑定的，要不然socket就绪之后都不知道该唤醒谁。这个等待队列其实就是保存在socket数据结构中。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">socket</span> <span class="token punctuation">{</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token comment">// 这个在epoll中会提到</span>
	<span class="token keyword">struct</span> <span class="token class-name">file</span>	<span class="token operator">*</span>file<span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token comment">// struct sock - network layer representation of sockets</span>
	<span class="token keyword">struct</span> <span class="token class-name">sock</span>	<span class="token operator">*</span>sk<span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token comment">// incoming packets</span>
	<span class="token keyword">struct</span> <span class="token class-name">sk_buff_head</span>	sk_receive_queue<span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token comment">// Packet sending queue</span>
	<span class="token keyword">struct</span> <span class="token class-name">sk_buff_head</span>	sk_write_queue<span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token comment">// socket的等待队列，wq的意思就是wait_queue</span>
  <span class="token keyword">struct</span> <span class="token class-name">socket_wq</span> __rcu	<span class="token operator">*</span>sk_wq<span class="token punctuation">;</span>
	
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/2023-01-28-081300.png" alt="socket数据结构" tabindex="0" loading="lazy"><figcaption>socket数据结构</figcaption></figure><p>socket自己维护了一个等待队列<code>sk_wq</code>，这个队列中每个元素保存的是：</p><ul><li>阻塞在当前socket上的进程描述符</li><li>进程被唤醒之后应该调用的回调函数</li></ul><p>​ 这个回调函数是进程在加入等待队列的时候设置的一个函数指针（行话叫，向内核注册了一个回调函数），告诉内核：我正等着这个socket上的数据呢，先睡一会儿，等有数据了你就执行这个回调函数吧，里边有把我唤醒的逻辑。就这样，经过网卡接收数据、硬中断以及软中断再到内核调用回调函数唤醒进程，把进程的<code>task_struct</code>从等待队列移动到执行队列，进程再次得到CPU的临幸，函数返回结果，阻塞结束。</p><p>​ 用户进程会阻塞在<code>select</code>之上，由于<code>select</code>会同时监听多个socket，因此当前进程会被添加到每个被监听的socket的等待队列中，每次唤醒还需要从每个socket等待队列中移除。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/2023-01-12-044606.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><code>select</code>的唤醒也有个问题，调用<code>select</code>的进程被唤醒之后是一脸懵啊，内核直接扔给他一个整数，进程不知道哪些socket收到数据了，还必须遍历一下才能知道。</p><h5 id="多路复用" tabindex="-1"><a class="header-anchor" href="#多路复用" aria-hidden="true">#</a> 多路复用</h5><p><code> select</code>在超时时间内会被阻塞，直到我们感兴趣的socket读就绪、写就绪或者有异常事件发生，然后<code>select</code>会返回已就绪的描述符数。</p><p>用户进程拿到这个整数说明了两件事情：</p><ol><li>我们上文讲的所有<code>select</code>操作都是在内核态运行的，<code>select</code>返回之后，权限交还到了用户空间；</li><li>用户进程拿到这个整数，需要对<code>select</code>监听的描述符逐个进行检测，判断二进制位是否被设置为1，进而进行相关的逻辑处理。可是问题是，内核把“就绪”的这个状态保存在了哪里呢？换句话说，用户进程该遍历谁？</li></ol><p>​ <code>select</code>的<code>readfds</code>、<code>writefds</code>、<code>exceptfds</code> 3个参数都是指针类型，用户进程传递这3个参数告诉内核对哪些socket的哪些事件感兴趣，执行完毕之后反过来内核会将就绪的描述符状态也放在这三个参数变量中，这种参数称为<strong>值-结果</strong>参数。</p><p>用户进程通过调用<code>FD_ISSET(int fd, fd_set *fdset)</code>对描述符集进行判断即可，看个整体流程的动图。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/2023-01-11-120008.gif" alt="select动图" tabindex="0" loading="lazy"><figcaption>select动图</figcaption></figure><ul><li>用户进程设置<code>fd_set</code>参数，调用<code>select()</code>函数，并将描述符集合拷贝到内核空间；</li><li>为了提高效率，内核通过<code>nfds</code>参数避免检测那些总为<code>0</code>的位，遍历的过程发生在内核空间，不存在系统调用切换上下文的开销；</li><li><code>select</code>函数修改由指针<code>readset</code>、<code>writeset</code>以及<code>exceptset</code>所指向的描述符集，函数返回时，描述符集中只有之前我们标记过的并且处于就绪状态的描述符对应的二进制位才是1，其余都会被重置为0（因此每次重新调用<code>select</code>时，我们必须把所有描述符集中感兴趣的位再次设置为1）；</li><li>进程根据<code>select()</code>返回的结果判断操作是否正常，如果为<code>0</code>表示超时，<code>-1</code>表示出错，大于<code>0</code>表示有相应数量的描述符就绪了，进而利用<code>FD_ISSET</code>遍历检查所有相应类型的<code>fd_set</code>中的所有描述符，如果为<code>1</code>，则进行业务逻辑处理即可。</li></ul><p>​ <code>select</code>是阻塞的，进程会阻塞在<code>select</code>之上，而不是阻塞在真正的I/O系统调用上，模型示意图见下图：</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/2023-01-02-020526.png" alt="I/O多路复用模型" tabindex="0" loading="lazy"><figcaption>I/O多路复用模型</figcaption></figure><p>​ 我们从头到尾都是使用一个用户线程来处理所有socket，同时又避免了非阻塞IO的那种无效轮询，为此付出的代价是一次<code>select</code>系统调用的阻塞，外加N次就绪文件描述符的系统调用。</p><hr><h4 id="poll" tabindex="-1"><a class="header-anchor" href="#poll" aria-hidden="true">#</a> poll</h4><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// 返回：若有就绪描述符则为其数目，若超时则为0，若出错则为-1</span>
<span class="token keyword">int</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pollfd</span> <span class="token operator">*</span>fds<span class="token punctuation">,</span> <span class="token class-name">nfds_t</span> nfds<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>函数有3个参数，第一个参数是一个<code>pollfd</code>类型的数组，其中<code>pollfd</code>结构如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">pollfd</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span>    fd<span class="token punctuation">;</span>       <span class="token comment">/* file descriptor */</span>
    <span class="token keyword">short</span>  events<span class="token punctuation">;</span>   <span class="token comment">/* events to look for */</span>
    <span class="token keyword">short</span>  revents<span class="token punctuation">;</span>  <span class="token comment">/* events returned */</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ <code>pollfd</code>由3部分组成，首先是描述符<code>fd</code>，其次<code>events</code>表示描述符<code>fd</code>上待检测的事件类型，一个<code>short</code>类型的数字用来表示多种事件，自然可以想到用的是二进制掩码的方式来进行位操作。源码中我们可以找到所有事件的定义，顺序做了一定调整，如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// file: /usr/include/bits/poll.h</span>
<span class="token comment">/* 第一类：可读事件  */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">POLLIN</span>	<span class="token expression"><span class="token number">0x001</span>	</span><span class="token comment">/* There is data to read.  */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">POLLPRI</span>	<span class="token expression"><span class="token number">0x002</span>	</span><span class="token comment">/* There is urgent data to read.  */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">POLLRDNORM</span>	<span class="token expression"><span class="token number">0x040</span>	</span><span class="token comment">/* Normal data may be read.  */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">POLLRDBAND</span>	<span class="token expression"><span class="token number">0x080</span>	</span><span class="token comment">/* Priority data may be read.  */</span></span>


<span class="token comment">/* 第二类：可写事件  */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">POLLOUT</span>	<span class="token expression"><span class="token number">0x004</span>	</span><span class="token comment">/* Writing now will not block.  */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">POLLWRNORM</span>	<span class="token expression"><span class="token number">0x100</span>	</span><span class="token comment">/* Writing now will not block.  */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">POLLWRBAND</span>	<span class="token expression"><span class="token number">0x200</span>	</span><span class="token comment">/* Priority data may be written.  */</span></span>


<span class="token comment">/* 第三类：错误事件 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">POLLERR</span>	<span class="token expression"><span class="token number">0x008</span>	</span><span class="token comment">/* Error condition.  */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">POLLHUP</span>	<span class="token expression"><span class="token number">0x010</span>	</span><span class="token comment">/* Hung up.  */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">POLLNVAL</span>	<span class="token expression"><span class="token number">0x020</span>	</span><span class="token comment">/* Invalid polling request.  */</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ <code>pollfd</code>结构中还有一个<code>revents</code>字段，全称是<code>returned events</code>，这是<code>poll</code>与<code>select</code>的第1个不同点。</p><p>​ <strong>poll会将每次遍历之后的结果保存到revents字段中，没有select那种值-结果参数，也就不需要每次调用poll的时候重置我们感兴趣的描述符以及相关事件</strong>。还有一点，<strong>错误事件不能在events中进行设置，但是当相应事件发生时会通过revents字段返回</strong>。这是<code>poll</code>与<code>select</code>的第2个不同点。</p><p>​ 再来看<code>poll</code>的第2个参数<code>nfds</code>，表示的是数组<code>fds</code>的元素个数，也就是用户进程想让<code>poll</code>同时监听的描述符的个数。如此一来，<strong>poll函数将设置最大监听数量的权限给了程序设计者，自由控制pollfd结构数组的大小，突破了select函数1024个最大描述符的限制</strong>。这是<code>poll</code>与<code>select</code>的第3个不同点。</p><p>​ 至于<code>timeout</code>参数就更好理解了，就是设置超时时间罢了。<code>poll</code>本质上和<code>select</code>没有太大的变化。<code>poll</code>函数返回之后，被唤醒的用户进程依然是懵的，循环去遍历文件描述符、检查相关事件、进行相应逻辑处理。</p><hr><h4 id="epoll" tabindex="-1"><a class="header-anchor" href="#epoll" aria-hidden="true">#</a> epoll</h4><p>不同于<code>select/poll</code>单个函数走天下，<code>epoll</code>用起来稍微麻烦了一点点，它提供了函数三件套，<code>epoll_create</code>、<code>epoll_ctl</code>、<code>epoll_wait</code>。</p><h5 id="创建epoll实例" tabindex="-1"><a class="header-anchor" href="#创建epoll实例" aria-hidden="true">#</a> 创建epoll实例</h5><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// size参数从Linux2.6.8之后失去意义，为保持向前兼容，需要使size参数 &gt; 0</span>
<span class="token keyword">int</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 这个函数是最新款，如果falgs为0，等同于epoll_create()</span>
<span class="token keyword">int</span> <span class="token function">epoll_create1</span><span class="token punctuation">(</span><span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ <code>epoll_create()</code> 方法创建了一个 epoll 实例，并返回了指向epoll实例的描述符，这个描述符用于下文即将介绍的另外两个函数。也可以使用<code>epoll_create1()</code>这个新函数，这个函数相比前者可以多添加<code>EPOLL_CLOEXEC</code>这个可选项。这个epoll实例内部维护了两个重要结构，分别是<code>需要监听的文件描述符树</code>和<code>就绪的文件描述符</code>，对于就绪的文件描述符，他们会被返回给用户进程进行处理，从这个角度来说，<strong>epoll避免了每次select/poll之后用户进程需要扫描所有文件描述符的问题</strong>。</p><h5 id="epoll注册事件" tabindex="-1"><a class="header-anchor" href="#epoll注册事件" aria-hidden="true">#</a> epoll注册事件</h5><p>​ 创建完epoll实例之后，我们可以使用<code>epoll_ctl</code>（<code>ctl</code>就是control的缩写）函数，向epoll实例中添加、修改或删除我们感兴趣的某个文件描述符的某些事件。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">//  返回值: 若成功返回0；若返回-1表示出错</span>
<span class="token keyword">int</span> <span class="token function">epoll_ctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">int</span> op<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>第一个参数<code>epfd</code>就是刚才调用<code>epoll_create</code>创建的epoll实例的描述符，也就是epoll的句柄。</p><p>第二个参数<code>op</code>表示要进行什么控制操作，有3个选项</p><ul><li><code>EPOLL_CTL_ADD</code>： 向 epoll 实例<strong>注册</strong>文件描述符对应的事件；</li><li><code>EPOLL_CTL_DEL</code>：向 epoll 实例<strong>删除</strong>文件描述符对应的事件；</li><li><code>EPOLL_CTL_MOD</code>： <strong>修改</strong>文件描述符对应的事件。</li></ul><p>第三个参数<code>fd</code>很简单，就是被操作的文件描述符。</p><p>第四个参数就是注册的事件类型，先看一下<code>epoll_event</code>的定义：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token punctuation">{</span>
     <span class="token class-name">uint32_t</span>     events<span class="token punctuation">;</span>      <span class="token comment">/* 向epoll订阅的事件 */</span>
     <span class="token class-name">epoll_data_t</span> data<span class="token punctuation">;</span>        <span class="token comment">/* 用户数据 */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">union</span> epoll_data <span class="token punctuation">{</span>
     <span class="token keyword">void</span>        <span class="token operator">*</span>ptr<span class="token punctuation">;</span>
     <span class="token keyword">int</span>          fd<span class="token punctuation">;</span>
     <span class="token class-name">uint32_t</span>     u32<span class="token punctuation">;</span>
     <span class="token class-name">uint64_t</span>     u64<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token class-name">epoll_data_t</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ <code>events</code>这个字段和<code>poll</code>的<code>events</code>参数一样，都是通过二进制掩码设置事件类型，epoll的事件类型在<code>/usr/include/sys/epoll.h</code>中有定义，更详细的可以使用<code>man epoll_ctl</code>看一下文档说明，其中内容很多，知道有这么回事儿就行了，但是注意一下<code>EPOLLET</code>这个事件，特意加了注释。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">enum</span> <span class="token class-name">EPOLL_EVENTS</span> <span class="token punctuation">{</span>
      EPOLLIN <span class="token operator">=</span> <span class="token number">0x001</span><span class="token punctuation">,</span>
  	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EPOLLIN</span> <span class="token expression">EPOLLIN</span></span>
      EPOLLPRI <span class="token operator">=</span> <span class="token number">0x002</span><span class="token punctuation">,</span>
  	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EPOLLPRI</span> <span class="token expression">EPOLLPRI</span></span>
      EPOLLOUT <span class="token operator">=</span> <span class="token number">0x004</span><span class="token punctuation">,</span>
  	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EPOLLOUT</span> <span class="token expression">EPOLLOUT</span></span>
      EPOLLRDNORM <span class="token operator">=</span> <span class="token number">0x040</span><span class="token punctuation">,</span>
  	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EPOLLRDNORM</span> <span class="token expression">EPOLLRDNORM</span></span>
      EPOLLRDBAND <span class="token operator">=</span> <span class="token number">0x080</span><span class="token punctuation">,</span>
  	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EPOLLRDBAND</span> <span class="token expression">EPOLLRDBAND</span></span>
      EPOLLWRNORM <span class="token operator">=</span> <span class="token number">0x100</span><span class="token punctuation">,</span>
  	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EPOLLWRNORM</span> <span class="token expression">EPOLLWRNORM</span></span>
      EPOLLWRBAND <span class="token operator">=</span> <span class="token number">0x200</span><span class="token punctuation">,</span>
  	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EPOLLWRBAND</span> <span class="token expression">EPOLLWRBAND</span></span>
      EPOLLMSG <span class="token operator">=</span> <span class="token number">0x400</span><span class="token punctuation">,</span>
  	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EPOLLMSG</span> <span class="token expression">EPOLLMSG</span></span>
      EPOLLERR <span class="token operator">=</span> <span class="token number">0x008</span><span class="token punctuation">,</span>
  	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EPOLLERR</span> <span class="token expression">EPOLLERR</span></span>
      EPOLLHUP <span class="token operator">=</span> <span class="token number">0x010</span><span class="token punctuation">,</span>
  	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EPOLLHUP</span> <span class="token expression">EPOLLHUP</span></span>
      EPOLLRDHUP <span class="token operator">=</span> <span class="token number">0x2000</span><span class="token punctuation">,</span>
  	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EPOLLRDHUP</span> <span class="token expression">EPOLLRDHUP</span></span>
      EPOLLWAKEUP <span class="token operator">=</span> <span class="token number">1u</span> <span class="token operator">&lt;&lt;</span> <span class="token number">29</span><span class="token punctuation">,</span>
  	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EPOLLWAKEUP</span> <span class="token expression">EPOLLWAKEUP</span></span>
      EPOLLONESHOT <span class="token operator">=</span> <span class="token number">1u</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">,</span>
  	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EPOLLONESHOT</span> <span class="token expression">EPOLLONESHOT</span></span>
  	<span class="token comment">// 设置为 edge-triggered，默认为 level-triggered</span>
      EPOLLET <span class="token operator">=</span> <span class="token number">1u</span> <span class="token operator">&lt;&lt;</span> <span class="token number">31</span>
  	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EPOLLET</span> <span class="token expression">EPOLLET</span></span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>data</code>字段比较有意思，我们可以在<code>data</code>中设置我们需要的数据。</p><h5 id="epoll-wait" tabindex="-1"><a class="header-anchor" href="#epoll-wait" aria-hidden="true">#</a> epoll_wait</h5><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// 返回值: 成功返回的是一个大于0的数，表示事件的个数；0表示超时；出错返回-1.</span>
<span class="token keyword">int</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>events<span class="token punctuation">,</span> <span class="token keyword">int</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>​ <code>epoll_wait</code>的用法和<code>select/poll</code>很类似，用户进程被阻塞。不同的是，<code>epoll</code>会直接告诉用户进程哪些描述符已经就绪了。第一个参数是<code>epoll</code>实例的描述符。第二个参数是返回给用户空间的需要处理的I/O事件，是一个<code>epoll_event</code>类型的数组，数组的长度就是<code>epoll_wait</code>函数的返回值，再看一眼这个结构吧。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token punctuation">{</span>
     <span class="token class-name">uint32_t</span>     events<span class="token punctuation">;</span>      <span class="token comment">/* 向epoll订阅的事件 */</span>
     <span class="token class-name">epoll_data_t</span> data<span class="token punctuation">;</span>        <span class="token comment">/* 用户数据 */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">union</span> epoll_data <span class="token punctuation">{</span>
     <span class="token keyword">void</span>        <span class="token operator">*</span>ptr<span class="token punctuation">;</span>
     <span class="token keyword">int</span>          fd<span class="token punctuation">;</span>
     <span class="token class-name">uint32_t</span>     u32<span class="token punctuation">;</span>
     <span class="token class-name">uint64_t</span>     u64<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token class-name">epoll_data_t</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ <code>events</code> 表示具体的事件类型，至于这个<code>data</code>就是在<code>epoll_ctl</code>中设置的<code>data</code>，这样用户进程收到这个<code>epoll_event</code>，根据之前设置的<code>data</code>就能获取到相关信息，然后进行逻辑处理了。第三个参数是一个大于 <code>0</code> 的整数，表示 <code>epoll_wait</code> 可以返回的最大事件值。第四个参数是 <code>epoll_wait</code> 阻塞调用的超时值，如果设置为 <code>-1</code>，表示不超时；如果设置为 <code>0</code> 则立即返回，即使没有任何 I/O 事件发生。</p><h5 id="edge-triggered-和-level-triggered" tabindex="-1"><a class="header-anchor" href="#edge-triggered-和-level-triggered" aria-hidden="true">#</a> edge-triggered 和 level-triggered</h5><p>​ <code>epoll</code>还提供了一个利器 —— 边缘触发（edge-triggered），也就是上文我没解释的<code>EPOLLET</code> 参数。</p><p>​ 啥意思呢？举个例子。如果有个socket有100个字节的数据可读，边缘触发（edge-triggered）和条件触发（level-triggered）都会产生<strong>读就绪</strong>事件。但是如果用户进程只读取了50个字节，边缘触发就会陷入等待，数据不会丢失，但是你爱读不读，反正老子已经通知过你了；而条件触发会因为你还没有读完，兢兢业业地不停产生<strong>读就绪</strong>事件催你去读。边缘触发只会产生一次事件提醒，效率和性能要高于条件触发，这是epoll的一个大杀器。</p><h5 id="file-operations与poll" tabindex="-1"><a class="header-anchor" href="#file-operations与poll" aria-hidden="true">#</a> file_operations与poll</h5><p>Linux下所有文件都可以使用<code>select/poll/epoll</code>来监听文件变化吗？</p><p><strong>答案是不行！</strong></p><p>只有底层驱动实现了 <code>file_operations</code> 中 <code>poll</code> 函数的文件类型才可以被 <code>epoll</code> 监视！</p><blockquote><p>注意，这里的<code>file_operations</code>中定义的<code>poll</code>和上文讲到的<code>poll()</code>是两码事儿，只是恰好名字一样罢了。</p></blockquote><p><strong>socket 类型的文件驱动实现了 poll 函数，具体实现是sock_poll()，因此才可以被 epoll 监视</strong>。</p><p>下面摘录了 <code>file_operations</code> 中我们常见的函数定义。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// file: include/linux/fs.h</span>
<span class="token keyword">struct</span> <span class="token class-name">file_operations</span> <span class="token punctuation">{</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token class-name">ssize_t</span> <span class="token punctuation">(</span><span class="token operator">*</span>read<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token class-name">size_t</span><span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">ssize_t</span> <span class="token punctuation">(</span><span class="token operator">*</span>write<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token class-name">size_t</span><span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>poll<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">poll_table_struct</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>open<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>flush<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token class-name">fl_owner_t</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>release<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ Linux对文件的操作做了高度的抽象，每个开发者都可以开发自己的文件系统，Linux并不知道其中的具体文件应该怎样<code>open</code>、<code>read/write</code>或者<code>release</code>，所以Linux定义了<code>file_operations</code>这个“接口”，设备类型需要自己实现<code>struct file_operations</code>结构中定义的函数的细节。有点类似于Java中的接口和具体实现类的关系。</p><h5 id="epoll内核对象的创建" tabindex="-1"><a class="header-anchor" href="#epoll内核对象的创建" aria-hidden="true">#</a> epoll内核对象的创建</h5><p><code>epoll_create()</code>的主要作用是创建一个<code>struct eventpoll</code>内核对象，后续epoll的操作大部分都是对这个数据结构的操作。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/image-20230604222511882.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><code>wq</code>：等待队列。双向链表，软中断就绪的时候会通过<code>wq</code>找到阻塞在epoll对象上的进程；</li><li><code>rdllist</code>：就绪的描述符链表。双向链表，当描述符就绪时，内核会将就绪的描述符放到<code>rdllist</code>，这样用户进程就可以通过该链表直接找到就绪的描述符；</li><li><code>rbr</code>：<strong>R</strong>ed <strong>B</strong>lack <strong>R</strong>oot。指向红黑树根节点，里边的每个节点表示的就是epoll监听的文件描述符。</li></ul><p>然后，内核将<code>eventpoll</code>加入到当前进程已打开的文件列表中。(<code>eventpool</code>也是一个文件)</p><p><code>epoll_create1</code>的源码：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">//file: /fs/eventpoll.c</span>
<span class="token function">SYSCALL_DEFINE1</span><span class="token punctuation">(</span>epoll_create1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> error<span class="token punctuation">,</span> fd<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">eventpoll</span> <span class="token operator">*</span>ep <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">;</span>
	
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  
  <span class="token comment">// 1. 为struct eventpoll分配内存并初始化</span>
  <span class="token comment">// 	初始化操作主要包括初始化等待队列wq、rdllist、rbr等</span>
	error <span class="token operator">=</span> <span class="token function">ep_alloc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  
  <span class="token comment">// 2. 获取一个可用的描述符号fd，此时fd还未与具体的file绑定</span>
	fd <span class="token operator">=</span> <span class="token function">get_unused_fd_flags</span><span class="token punctuation">(</span>O_RDWR <span class="token operator">|</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> O_CLOEXEC<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    
  <span class="token comment">// 3. 创建一个名为&quot;[eventpoll]&quot;的匿名文件file</span>
  <span class="token comment">//	并将eventpoll对象赋值到匿名文件file的private_data字段进行关联</span>
	file <span class="token operator">=</span> <span class="token function">anon_inode_getfile</span><span class="token punctuation">(</span><span class="token string">&quot;[eventpoll]&quot;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>eventpoll_fops<span class="token punctuation">,</span> ep<span class="token punctuation">,</span>
	 O_RDWR <span class="token operator">|</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> O_CLOEXEC<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
  <span class="token comment">// 4. 将eventpoll对象的file指针指向刚创建的匿名文件file</span>
	ep<span class="token operator">-&gt;</span>file <span class="token operator">=</span> file<span class="token punctuation">;</span>
  
  <span class="token comment">// 5. 将fd和匿名文件file进行绑定</span>
	<span class="token function">fd_install</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> file<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> fd<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行过程如下：</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/image-20230604222616245.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>​ 调用<code>epoll_create1</code>后得到的文件描述符本质上是匿名文件<code>[eventpoll]</code>的描述符，该匿名文件中的<code>private_data</code>字段才指向了真正的<code>eventpoll</code>对象。Linux中的一切皆文件并非虚言。这样一来，<code>eventpoll文件</code>也可以被epoll本身监测，也就是说epoll实例可以监听其他的epoll实例，这一点很重要。至此，<code>epoll_create1</code>调用结束。</p><h5 id="添加socket到epoll" tabindex="-1"><a class="header-anchor" href="#添加socket到epoll" aria-hidden="true">#</a> 添加socket到epoll</h5><p>​ 现在考虑使用<code>EPOLL_CTL_ADD</code>向epoll实例中添加fd的情况。这时候就要用到上文的<code>rbr</code>红黑树了， <code>epoll_ctl</code>对fd的增删改操查作实际上就是对这棵红黑树进行操作，树的节点结构<code>epitem</code>如下所示：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// file: /fs/eventpoll.c</span>
<span class="token keyword">struct</span> <span class="token class-name">epitem</span> <span class="token punctuation">{</span>
	<span class="token comment">/* 红黑树的节点 */</span>
	<span class="token keyword">struct</span> <span class="token class-name">rb_node</span> rbn<span class="token punctuation">;</span>

	<span class="token comment">/* 用于将当前epitem连接到eventpoll中rdllist中的工具 */</span>
	<span class="token keyword">struct</span> <span class="token class-name">list_head</span> rdllink<span class="token punctuation">;</span>

	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

	<span class="token comment">/* 该结构保存了我们想让epoll监听的fd以及该fd对应的file */</span>
	<span class="token keyword">struct</span> <span class="token class-name">epoll_filefd</span> ffd<span class="token punctuation">;</span>


	<span class="token comment">/* 当前epitem属于哪个eventpoll */</span>
	<span class="token keyword">struct</span> <span class="token class-name">eventpoll</span> <span class="token operator">*</span>ep<span class="token punctuation">;</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/image-20230604222929136.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>接着我们看一下<code>epoll_ctl</code>的源码:</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// file: /fs/eventpoll.c</span>
<span class="token function">SYSCALL_DEFINE4</span><span class="token punctuation">(</span>epoll_ctl<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> epfd<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> op<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> fd<span class="token punctuation">,</span>
	<span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> event<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token operator">*</span>tfile<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">eventpoll</span> <span class="token operator">*</span>ep<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">epitem</span> <span class="token operator">*</span>epi<span class="token punctuation">;</span>

	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

	<span class="token comment">/* 根据epfd找到eventpoll对应的匿名文件 */</span>
	file <span class="token operator">=</span> <span class="token function">fget</span><span class="token punctuation">(</span>epfd<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/* fd是我们感兴趣的socket描述符，根据它找到对应的文件 */</span>
	tfile <span class="token operator">=</span> <span class="token function">fget</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
  <span class="token comment">/* 根据file的private_data字段找到eventpoll实例 */</span>
	ep <span class="token operator">=</span> file<span class="token operator">-&gt;</span>private_data<span class="token punctuation">;</span>

	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token comment">/* 在红黑树中查找一下，看看是不是已经存在了
	如果存在了，那就报错；否则，执行ep_insert */</span>
  epi <span class="token operator">=</span> <span class="token function">ep_find</span><span class="token punctuation">(</span>ep<span class="token punctuation">,</span> tfile<span class="token punctuation">,</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
	<span class="token keyword">switch</span> <span class="token punctuation">(</span>op<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">case</span> EPOLL_CTL_ADD<span class="token operator">:</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>epi<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	epds<span class="token punctuation">.</span>events <span class="token operator">|=</span> POLLERR <span class="token operator">|</span> POLLHUP<span class="token punctuation">;</span>
	error <span class="token operator">=</span> <span class="token function">ep_insert</span><span class="token punctuation">(</span>ep<span class="token punctuation">,</span> <span class="token operator">&amp;</span>epds<span class="token punctuation">,</span> tfile<span class="token punctuation">,</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span>
	error <span class="token operator">=</span> <span class="token operator">-</span>EEXIST<span class="token punctuation">;</span>
	<span class="token function">clear_tfile_check_list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">break</span><span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token punctuation">}</span>
  
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ <code>epoll_ctl</code>中，首先根据传入的<code>epfd</code>以及<code>fd</code>找到相关的内核对象，然后在红黑树中判断这个<code>epitem</code>是不是已经存在，存在的话就报错，否则继续执行<code>ep_insert</code>函数。<code>ep_insert</code>故名思义就是将<code>epitem</code>结构插入到红黑树当中，但是并非单纯插入那么简单，其中涉及到一些细节。</p><h6 id="ep-insert" tabindex="-1"><a class="header-anchor" href="#ep-insert" aria-hidden="true">#</a> ep_insert</h6><p>很多关键操作都是在<code>ep_insert</code>函数中完成的，看一下源码。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// file: /fs/eventpoll.c</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ep_insert</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">eventpoll</span> <span class="token operator">*</span>ep<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>event<span class="token punctuation">,</span>
	     <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>tfile<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> error<span class="token punctuation">,</span> revents<span class="token punctuation">,</span> pwake <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>
	<span class="token keyword">long</span> user_watches<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">epitem</span> <span class="token operator">*</span>epi<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">ep_pqueue</span> epq<span class="token punctuation">;</span>

	<span class="token comment">// 1. 分配epitem内存空间</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>epi <span class="token operator">=</span> <span class="token function">kmem_cache_alloc</span><span class="token punctuation">(</span>epi_cache<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">return</span> <span class="token operator">-</span>ENOMEM<span class="token punctuation">;</span>
	
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    
	<span class="token comment">// 2. 将epitem进行初始化</span>
	<span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>epi<span class="token operator">-&gt;</span>rdllink<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>epi<span class="token operator">-&gt;</span>fllink<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>epi<span class="token operator">-&gt;</span>pwqlist<span class="token punctuation">)</span><span class="token punctuation">;</span>
	epi<span class="token operator">-&gt;</span>ep <span class="token operator">=</span> ep<span class="token punctuation">;</span>
	<span class="token function">ep_set_ffd</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>epi<span class="token operator">-&gt;</span>ffd<span class="token punctuation">,</span> tfile<span class="token punctuation">,</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
	epi<span class="token operator">-&gt;</span>event <span class="token operator">=</span> <span class="token operator">*</span>event<span class="token punctuation">;</span>
	epi<span class="token operator">-&gt;</span>nwait <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	epi<span class="token operator">-&gt;</span>next <span class="token operator">=</span> EP_UNACTIVE_PTR<span class="token punctuation">;</span>
	
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

	<span class="token comment">/* 3. 初始化 poll table，设置回调函数为ep_ptable_queue_proc */</span>
	epq<span class="token punctuation">.</span>epi <span class="token operator">=</span> epi<span class="token punctuation">;</span>
	<span class="token function">init_poll_funcptr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>epq<span class="token punctuation">.</span>pt<span class="token punctuation">,</span> ep_ptable_queue_proc<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/*
	 * 4. 调用ep_ptable_queue_proc函数，
	 * 	设置socket等待队列的回调函数为ep_poll_callback
	 */</span>
	revents <span class="token operator">=</span> <span class="token function">ep_item_poll</span><span class="token punctuation">(</span>epi<span class="token punctuation">,</span> <span class="token operator">&amp;</span>epq<span class="token punctuation">.</span>pt<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	
	<span class="token comment">/* 5. epitem插入eventpoll的红黑树 */</span>
	<span class="token function">ep_rbtree_insert</span><span class="token punctuation">(</span>ep<span class="token punctuation">,</span> epi<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>分配与初始化epitem</li></ul><p>虽然源码行数不少，但是这一步非常简单，就是将<code>epitem</code>中的数据准备好，到插入的时候直接拿来用就行了。用一张图来说明这一步的重点问题。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/image-20230604223150567.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>​ <code>epitem</code>已经准备好了，也就是监听的socket对象已经有了，就差插入到红黑树了，但是在插入之前需要解决个问题，当监听的对象就绪了之后内核该怎么办？</p><p>​ 那就是设置回调函数！</p><p>​ 这个回调函数是通过函数 <code>ep_ptable_queue_proc</code> 来进行设置的。回调函数是干什么的呢？就是当对应的文件描述符上有事件发生，就会调用这个函数，比如socket缓冲区有数据了，内核就会回调这个函数。这个函数就是 <code>ep_poll_callback</code>。</p><ul><li>设置回调函数</li></ul><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// file: /include/linux/poll.h</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">init_poll_funcptr</span><span class="token punctuation">(</span>poll_table <span class="token operator">*</span>pt<span class="token punctuation">,</span> poll_queue_proc qproc<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	pt<span class="token operator">-&gt;</span>_qproc <span class="token operator">=</span> qproc<span class="token punctuation">;</span>
	pt<span class="token operator">-&gt;</span>_key   <span class="token operator">=</span> <span class="token operator">~</span><span class="token number">0UL</span><span class="token punctuation">;</span> <span class="token comment">/* all events enabled */</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ <code>init_poll_funcptr</code>函数将<code>poll_table</code>结构的<code>_qproc</code>函数指针设置为<code>qproc</code>参数，也就是在<code>ep_insert</code>中看到的<code>ep_ptable_queue_proc</code>函数。接下来轮到<code>ep_item_poll</code>了，扒开它看看。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// file: /fs/eventpoll.c</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">ep_item_poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">epitem</span> <span class="token operator">*</span>epi<span class="token punctuation">,</span> poll_table <span class="token operator">*</span>pt<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  pt<span class="token operator">-&gt;</span>_key <span class="token operator">=</span> epi<span class="token operator">-&gt;</span>event<span class="token punctuation">.</span>events<span class="token punctuation">;</span>
	
  <span class="token comment">// 这行是重点</span>
	<span class="token keyword">return</span> epi<span class="token operator">-&gt;</span>ffd<span class="token punctuation">.</span>file<span class="token operator">-&gt;</span>f_op<span class="token operator">-&gt;</span><span class="token function">poll</span><span class="token punctuation">(</span>epi<span class="token operator">-&gt;</span>ffd<span class="token punctuation">.</span>file<span class="token punctuation">,</span> pt<span class="token punctuation">)</span> <span class="token operator">&amp;</span> epi<span class="token operator">-&gt;</span>event<span class="token punctuation">.</span>events<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ 重点来了，通过上文我们知道了，<code>ffd.file</code>指的是socket代表的文件，也就是调用了socket文件自己实现的<code>poll</code>方法，也就是上文提到过的<code>sock_poll()</code>。然后经过下面层层函数调用，最终来到了<code>poll_wait</code>函数。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/2023-01-30-064134.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// file: /include/linux/poll.h</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">poll_wait</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span> filp<span class="token punctuation">,</span> <span class="token class-name">wait_queue_head_t</span> <span class="token operator">*</span> wait_address<span class="token punctuation">,</span> poll_table <span class="token operator">*</span>p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">&amp;&amp;</span> p<span class="token operator">-&gt;</span>_qproc <span class="token operator">&amp;&amp;</span> wait_address<span class="token punctuation">)</span>
	p<span class="token operator">-&gt;</span><span class="token function">_qproc</span><span class="token punctuation">(</span>filp<span class="token punctuation">,</span> wait_address<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ <code>poll_wait</code>又调用了<code>poll_table</code>的<code>_qproc</code>函数，我们刚刚在<code>init_poll_funcptr</code>中将其设置为了<code>ep_ptable_queue_proc</code>，于是，代码来到了<code>ep_ptable_queue_proc</code>。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// file: /fs/eventpoll.c</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">ep_ptable_queue_proc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token class-name">wait_queue_head_t</span> <span class="token operator">*</span>whead<span class="token punctuation">,</span>
	 poll_table <span class="token operator">*</span>pt<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    
	<span class="token keyword">if</span> <span class="token punctuation">(</span>epi<span class="token operator">-&gt;</span>nwait <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>pwq <span class="token operator">=</span> <span class="token function">kmem_cache_alloc</span><span class="token punctuation">(</span>pwq_cache<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	
    <span class="token comment">// 设置最终的回调方法ep_poll_callback</span>
    <span class="token function">init_waitqueue_func_entry</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pwq<span class="token operator">-&gt;</span>wait<span class="token punctuation">,</span> ep_poll_callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    
    <span class="token comment">// 将包含ep_poll_callback在内的信息放入socket的等待队列</span>
	<span class="token function">add_wait_queue</span><span class="token punctuation">(</span>whead<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pwq<span class="token operator">-&gt;</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token punctuation">}</span> 
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ <code>ep_ptable_queue_proc</code>被我简化地只剩2个函数调用了，socket自己维护了一个等待队列<code>sk_wq</code>，并且这个等待队列中的每一项保存了阻塞在当前socket上的进程描述符（明确知道该唤醒谁）以及回调函数（内核明确知道数据来了该怎么做）。这一系列的操作就是设置回调函数为<code>ep_poll_callback</code>，并封装队列项数据结构，然后把这个结构放到socket的等待队列中。</p><p>​ 还有一个小问题，<strong>不保存当前用户进程信息</strong>，这也是epoll更加高效的一个原因，现在socket已经完全托管给epoll了，因此我们不能在一个socket准备就绪的时候就立刻去唤醒进程，唤醒的时机得交给epoll，这就是为什么<code>eventpoll</code>对象还有一个队列的原因，里边存放的就是阻塞在epoll上的进程。</p><ul><li>插入红黑树</li></ul><p>​ 最后一步就是通过<code>ep_rbtree_insert(ep, epi)</code>把<code>epitem</code>插入到红黑树中。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/image-20230604223735495.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>​ 至此，<code>epoll_ctl</code>的整个调用过程全部结束。为什么内核开发者选择了红黑树这个结构，自然就是为了高效地管理<code>epitem</code>，使得在插入、查找、删除等各个方面不会因为<code>epitem</code>数量的增加而产生性能的剧烈波动。总结如下：</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/image-20230604223907916.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h5 id="epoll-wait-1" tabindex="-1"><a class="header-anchor" href="#epoll-wait-1" aria-hidden="true">#</a> epoll_wait</h5><p>​ epoll本身是阻塞的，阻塞也正是在这一步中体现的。大部分人听到阻塞这个词就觉得很低效，这种想法并不对。</p><p>​ <code>epoll_wait</code>做的事情就是检查<code>eventpoll</code>对象中的就绪fd列表<code>rdllist</code>中是否有数据，如果有，就说明有socket已经准备好了，那就直接返回，用户进程对该列表中的fd进行处理。如果列表为空，那就将当前进程加入到<code>eventpoll</code>的进程等待队列<code>wq</code>中，让出CPU，主动进入睡眠状态。也就是说，只要有活儿（fd就绪），epoll会玩儿命一直干，绝对不阻塞。但是一旦没活儿了，阻塞就是一种正确的选择，要不然一直占用CPU也是一种极大的浪费。因此，epoll避免了很多不必要的进程上下文切换。</p><p>​ 好了，现在来看<code>epoll_wait</code>的实现吧。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// file: /fs/eventpoll.c</span>
<span class="token function">SYSCALL_DEFINE4</span><span class="token punctuation">(</span>epoll_wait<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> epfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> events<span class="token punctuation">,</span>
	<span class="token keyword">int</span><span class="token punctuation">,</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> timeout<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	error <span class="token operator">=</span> <span class="token function">ep_poll</span><span class="token punctuation">(</span>ep<span class="token punctuation">,</span> events<span class="token punctuation">,</span> maxevents<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ep_poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">eventpoll</span> <span class="token operator">*</span>ep<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> __user <span class="token operator">*</span>events<span class="token punctuation">,</span>
	   <span class="token keyword">int</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">long</span> timeout<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

fetch_events<span class="token operator">:</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	
  <span class="token comment">// 如果就绪队列上没有时间发生，进入下面的逻辑</span>
  <span class="token comment">// 否则，就返回</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">ep_events_available</span><span class="token punctuation">(</span>ep<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">/*
	 * We don&#39;t have any available event to return to the caller.
	 * We need to sleep here, and we will be wake up by
	 * ep_poll_callback() when events will become available.
	 */</span>
    <span class="token comment">// 定义等待队列项，并将当前线程和其进行绑定，并设置回调函数</span>
	<span class="token function">init_waitqueue_entry</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wait<span class="token punctuation">,</span> current<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 将等待队列项加入到wq等待队列中</span>
	<span class="token function">__add_wait_queue_exclusive</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-&gt;</span>wq<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">/*
	 * We don&#39;t want to sleep if the ep_poll_callback() sends us
	 * a wakeup in between. That&#39;s why we set the task state
	 * to TASK_INTERRUPTIBLE before doing the checks.
	 */</span>
      <span class="token comment">// 让出CPU，进入睡眠状态</span>
	<span class="token function">set_current_state</span><span class="token punctuation">(</span>TASK_INTERRUPTIBLE<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">schedule_hrtimeout_range</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> slack<span class="token punctuation">,</span> HRTIMER_MODE_ABS<span class="token punctuation">)</span><span class="token punctuation">)</span>
	timed_out <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token punctuation">}</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>ep_poll</code>做了以下几件事：</p><ol><li>判断<code>eventpoll</code>的<code>rdllist</code>队列上有没有就绪fd，如果有，那就直接返回；否则执行下面的步骤；</li><li>定义<code>eventpoll</code>的<code>wq</code>等待队列项，将当前进程绑定至队列项，并且设置回调函数；</li><li>将等待队列项加入到<code>wq</code>队列；</li><li>当前进程让出CPU，进入睡眠状态，进程阻塞。</li></ol><p>每一步都比较好理解，我们重点来看一下第2步，也就是<code>init_waitqueue_entry</code>函数。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// file: /include/linux/wait.h</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">init_waitqueue_entry</span><span class="token punctuation">(</span><span class="token class-name">wait_queue_t</span> <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	q<span class="token operator">-&gt;</span>flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	q<span class="token operator">-&gt;</span>private <span class="token operator">=</span> p<span class="token punctuation">;</span>
	q<span class="token operator">-&gt;</span>func <span class="token operator">=</span> default_wake_function<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ <code>wait_queue_t</code>就是<code>wq</code>等待队列项的结构体类型，将其中的<code>private</code>字段设置成了当前进程的<code>task_struct</code>结构体指针。然后将<code>default_wake_function</code>作为回调函数，赋值给了<code>func</code>字段。至此，流程如下：</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/image-20230604224235462.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h5 id="epollo处理数据流程" tabindex="-1"><a class="header-anchor" href="#epollo处理数据流程" aria-hidden="true">#</a> epollo处理数据流程</h5><p>​ 收到数据之后，首先干苦力活的是网卡，网卡会将数据放到某块关联的内存当中，这个操作不需要CPU的参与。等到数据保存完了之后，网卡会向CPU发起一个<strong>硬中断</strong>，通知CPU数据来了。这个时候CPU就要开始对中断进行处理了，但是CPU太忙了，它必须时时刻刻准备好接收各种设备的中断，比如鼠标、键盘等，而且还不能卡在一个中断上太长时间，要不然可以想像我们的计算机得“卡”成什么样子。</p><p>​ 所以实际设计中硬中断只负责做一些简单的事情，然后接着触发<strong>软中断</strong>，比较耗时且复杂的工作就交给软中断处理程序去做了。</p><p>​ 软中断以内核线程的方式运行，每个CPU都会对应一个软中断内核线程，名字叫做<code>ksoftirqd/CPU编号</code>，比如 <code>0</code> 号 CPU 对应的软中断内核线程的名字是 <code>ksoftirqd/0</code>，为了方便，我们直接叫做ksoftirqd好了。从这个角度上来说，操作系统就是一个死循环，在循环中不断接收各种中断，处理不同逻辑。内核线程经过各个函数调用，最终会调用到就绪的socket等待队列项中的回调函数<code>ep_poll_callback</code>，是时候看看这个函数了。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// file: /fs/eventpoll.c</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ep_poll_callback</span><span class="token punctuation">(</span><span class="token class-name">wait_queue_t</span> <span class="token operator">*</span>wait<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> mode<span class="token punctuation">,</span> <span class="token keyword">int</span> sync<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token comment">// 获取等待队列项对应的epitem</span>
	<span class="token keyword">struct</span> <span class="token class-name">epitem</span> <span class="token operator">*</span>epi <span class="token operator">=</span> <span class="token function">ep_item_from_wait</span><span class="token punctuation">(</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token comment">// 获取epitem对应的eventpoll实例</span>
	<span class="token keyword">struct</span> <span class="token class-name">eventpoll</span> <span class="token operator">*</span>ep <span class="token operator">=</span> epi<span class="token operator">-&gt;</span>ep<span class="token punctuation">;</span>

	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

	<span class="token comment">/* 如果当前epitem指向的socket已经在就绪队列里了，那就直接退出
	否则，将epitem添加到eventpoll的就绪队列rdllist中
	If this file is already in the ready list we exit soon 
	*/</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">ep_is_linked</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>epi<span class="token operator">-&gt;</span>rdllink<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">list_add_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>epi<span class="token operator">-&gt;</span>rdllink<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ep<span class="token operator">-&gt;</span>rdllist<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 查看eventpoll等待队列上是否有等待的进程</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">waitqueue_active</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-&gt;</span>wq<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token function">wake_up_locked</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-&gt;</span>wq<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ <code>ep_poll_callback</code>的逻辑非常简洁清晰。先找到就绪socket对应的等待队列项中的<code>epitem</code>，继而找到对应的<code>eventpoll</code>实例，再接口着判断当前的<code>epitem</code>是不是已经在<code>rdllist</code>就绪队列里了，如果在，那就没啥好做的了，函数退出就行了；如果不在，那就把<code>epitem</code>加入到<code>rdllist</code>中。最后看看<code>eventpoll</code>的等待队列上是不是有阻塞的进程，有的话就调用设置的<code>default_wake_function</code>回调函数来唤醒这个进程。</p><p>​ epoll中重点介绍的两个回调函数，<code>ep_poll_callback</code>和<code>default_wake_function</code>就串起来了。前者调用了后者，后者唤醒了进程。<code>epoll_wait</code>的最终使命就是将<code>rdllist</code>中的就绪fd返回给用户进程。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/image-20230604224520524.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h5 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h5><p>梳理一下epoll的整个过程。</p><ol><li><code>epoll_create</code>创建了<code>eventpoll</code>实例，并对其中的就绪队列<code>rdllist</code>、等待队列<code>wq</code>以及红黑树<code>rbr</code>进行了初始化；</li><li><code>epoll_ctl</code>将我们感兴趣的socket封装成<code>epitem</code>对象加入红黑树，除此之外，还封装了socket的<code>sk_wq</code>等待队列项，里边保存了socket就绪之后的函数回调，也就是<code>ep_poll_callback</code>；</li><li><code>epoll_wait</code>检查<code>eventpoll</code>的就绪队列是不是有就绪的socket，有的话直接返回；否则就封装一个<code>eventpoll</code>的等待队列项，里边保存了当前的用户进程信息以及另一个回调函数<code>default_wake_function</code>，然后把当前进程投入睡眠；</li><li>直到数据到达，内核线程找到就绪的socket，先调用<code>ep_poll_callback</code>，然后<code>ep_poll_callback</code>又调用<code>default_wake_function</code>，最终唤醒<code>eventpoll</code>等待队列中保存的进程，处理<code>rdllist</code>中的就绪fd；</li><li>epoll结束！</li></ol><h5 id="eventpoll处理" tabindex="-1"><a class="header-anchor" href="#eventpoll处理" aria-hidden="true">#</a> eventpoll处理</h5><p>​ <code>eventpoll文件</code>也可以被epoll本身监测，也就是说epoll实例可以监听其他的epoll实例，这一点很重要。怎么个重要法，这就涉及到<code>eventpoll</code>实例中的另一个队列了，叫做<code>poll_wait</code>。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">eventpoll</span> <span class="token punctuation">{</span>
	
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

	<span class="token class-name">wait_queue_head_t</span> wq<span class="token punctuation">;</span>

	<span class="token comment">/* 就是它！！！！！！！ */</span>
	<span class="token class-name">wait_queue_head_t</span> poll_wait<span class="token punctuation">;</span>

	<span class="token keyword">struct</span> <span class="token class-name">list_head</span> rdllist<span class="token punctuation">;</span>

	<span class="token keyword">struct</span> <span class="token class-name">rb_root</span> rbr<span class="token punctuation">;</span>

	<span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/2023-01-31-031620.png" alt="递归监听的情况" tabindex="0" loading="lazy"><figcaption>递归监听的情况</figcaption></figure><p>如上图所示</p><ul><li><code>epollfd1</code>监听了2个普通描述符<code>fd1</code>和<code>fd2</code></li><li><code>epollfd2</code>监听了<code>epollfd1</code>和2个普通描述符<code>fd3</code>、<code>fd4</code></li></ul><p>​ 如果<code>fd1</code>或<code>fd2</code>有<strong>可读事件</strong>触发，那么就绪的fd的回调函数<code>ep_poll_callback</code>对将该fd放到<code>epollfd1</code>的<code>rdllist</code>就绪队列中。由于<code>epollfd1</code>本身也是个文件，它的可读事件此时也被触发，但是<code>ep_poll_callback</code>怎么知道该把<code>epollfd1</code>放到谁的<code>rdllist</code>中呢？</p><p><code>poll_wait</code>来喽～～</p><p>​ 当epoll监听epoll类型的文件的时候，会把监听者放入被监听者的<code>poll_wait</code>队列中，上面的例子就是<code>epollfd1</code>的<code>poll_wait</code>队列保存了<code>epollfd2</code>，这样一来，<code>当epollfd1</code>有可读事件触发，就可以在<code>poll_wait</code>中找到<code>epollfd2</code>，调用<code>epollfd1</code>的<code>ep_poll_callback</code>将<code>epollfd1</code>放入<code>epollfd2</code>的<code>rdllist</code>中。所以<code>poll_wait</code>队列就是用来处理这种递归监听的情况的。</p><hr><h3 id="io分类" tabindex="-1"><a class="header-anchor" href="#io分类" aria-hidden="true">#</a> IO分类</h3><p>先看一个非常简单的IO流程，不涉及任何阻塞非阻塞、同步异步概念的图。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/2023-02-04-001950.png" alt="IO流程" tabindex="0" loading="lazy"><figcaption>IO流程</figcaption></figure><p>客户端发起系统调用之后，内核的操作可以被分成两步：</p><ul><li><p>等待数据</p><p>此阶段网络数据进入网卡，然后网卡将数据放到指定的内存位置，此过程CPU无感知。然后经过网卡发起硬中断，再经过软中断，内核线程将数据发送到socket的<strong>内核缓冲区</strong>中。</p></li><li><p>数据拷贝</p><p>数据从socket的<strong>内核缓冲区</strong>拷贝到<strong>用户空间</strong>。</p></li></ul><h4 id="阻塞与非阻塞" tabindex="-1"><a class="header-anchor" href="#阻塞与非阻塞" aria-hidden="true">#</a> 阻塞与非阻塞</h4><p>假设socket为阻塞模式，则IO调用如下图所示。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/image-20230604225532038.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>​ 当处于运行状态的用户线程发起recv系统调用时，如果socket内核缓冲区内没有数据，则内核会将当前线程投入睡眠，让出CPU的占用。直到网络数据到达网卡，网卡DMA数据到内存，再经过硬中断、软中断，由内核线程唤醒用户线程。此时socket的数据已经准备就绪，用户线程由用户态进入到内核态，执行数据拷贝，将数据从内核空间拷贝到用户空间，系统调用结束。此阶段，开发者通常认为用户线程处于等待（称为阻塞也行）状态，因为在用户态的角度上，线程确实啥也没干（虽然在内核态干得累死累活）。</p><p>​ 如果将socket设置为非阻塞模式，调用便换了一副光景。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/image-20230604225658522.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>​ 用户线程发起系统调用，如果socket内核缓冲区中没有数据，则系统调用立即返回，不会挂起线程。而线程会继续轮询，直到socket内核缓冲区内有数据为止。如果socket内核缓冲区内有数据，则用户线程进入内核态，将数据从内核空间拷贝到用户空间，这一步阻塞没有区别</p><h4 id="同步与异步" tabindex="-1"><a class="header-anchor" href="#同步与异步" aria-hidden="true">#</a> 同步与异步</h4><p>​ <strong>同步</strong>和<strong>异步</strong>主要看请求发起方对消息结果的获取方式，是<strong>主动获取</strong>还是<strong>被动通知</strong>。区别主要体现在数据拷贝阶段。</p><p>​ 同步指的是数据到达socket内核缓冲区之后，由用户线程参与到数据拷贝过程中，直到数据从内核空间拷贝到用户空间。因此，<strong>IO多路复用，对于应用程序而言，仍然只能算是一种同步</strong>，因为应用程序仍然花费时间等待IO结果，等待期间CPU要么用于遍历文件描述符的状态，要么用于休眠等待事件发生。</p><p>​ 以<code>select</code>为例，用户线程发起<code>select</code>调用，会切换到内核空间，如果没有数据准备就绪，则用户线程阻塞到有数据来为止，<code>select</code>调用结束。结束之后用户线程获取到的只是「内核中有N个socket已经就绪」的这么一个信息，还需要用户线程对着1024长度的描述符数组进行遍历，才能获取到socket中的数据，这就是同步。</p><p>​ 理想中的完美异步应该是用户进程发起非阻塞调用，内核直接返回结果之后，用户线程可以立即处理下一个任务，只需要IO完成之后通过信号或回调函数的方式将数据传递给用户线程。如下图所示。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/image-20230604230059665.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>​ <strong>在理想的异步环境下，数据准备阶段和数据拷贝阶段都是由内核完成的</strong>，不会对用户线程进行阻塞，这种内核级别的改进自然需要操作系统底层的功能支持。Windows上的<code>IOCP</code>，它在某种程度上提供了理想的异步，其内部依然采用的是多线程的原理，不过是内核级别的多线程。linux高版本的<code>io_uring</code>也提供了异步IO的支持。</p><h4 id="详解" tabindex="-1"><a class="header-anchor" href="#详解" aria-hidden="true">#</a> 详解</h4><h5 id="内核态和用户态" tabindex="-1"><a class="header-anchor" href="#内核态和用户态" aria-hidden="true">#</a> 内核态和用户态</h5><p>我们的电脑可能同时运行着非常多的程序，这些程序分别来自不同公司。</p><p>谁也不知道在电脑上跑着的某个程序会不会发疯似得做一些奇怪的操作，比如定时把内存清空了。</p><p>因此 CPU 划分了非特权指令和特权指令，做了权限控制，一些危险的指令不会开放给普通程序，只会开放给操作系统等特权程序。</p><p>你可以理解为我们的代码调用不了那些可能会产生“危险”操作，而操作系统的内核代码可以调用。</p><p>这些“危险”的操作指：内存的分配回收，磁盘文件读写，网络数据读写等等。</p><p>如果我们想要执行这些操作，只能调用操作系统开放出来的 API ，也称为系统调用。</p><p>这就好比我们去行政大厅办事，那些敏感的操作都由官方人员帮我们处理（系统调用），所以道理都是一样的，目的都是为了防止我们(普通程序)乱来。</p><p>这里又有两个名词：</p><ul><li>用户空间</li><li>内核空间。</li></ul><p>我们普通程序的代码是跑在用户空间上的，而操作系统的代码跑在内核空间上，<strong>用户空间无法直接访问内核空间的</strong>。当一个进程运行在用户空间时就处于用户态，运行在内核空间时就处于内核态。</p><p>当处于用户空间的程序进行系统调用，也就是调用操作系统内核提供的 API 时，就会进行上下文的切换，切换到内核态中，也时常称之为陷入内核态。</p><p>那为什么开头要先介绍这个知识点呢？</p><p>因为当程序请求获取网络数据的时候，需要经历两次拷贝：</p><ul><li>程序需要等待数据从网卡拷贝到内核空间。</li><li>因为用户程序无法访问内核空间，所以内核又得把数据拷贝到用户空间，这样处于用户空间的程序才能访问这个数据。</li></ul><p>介绍这么多就是让你理解为什么会有两次拷贝，且系统调用是有开销的，因此最好不要频繁调用。</p><p>然后我们今天说的 I/O 模型之间的差距就是这拷贝的实现有所不同！</p><p>今天我们就以 read 调用，即读取网络数据为例子来展开 I/O 模型。</p><h5 id="同步阻塞-i-o" tabindex="-1"><a class="header-anchor" href="#同步阻塞-i-o" aria-hidden="true">#</a> 同步阻塞 I/O</h5><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/image-10-1024x586.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>当用户程序的线程调用 read 获取网络数据的时候，首先这个数据得有，也就是网卡得先收到客户端的数据，然后这个数据有了之后需要拷贝到内核中，然后再被拷贝到用户空间内，这整一个过程用户线程都是被阻塞的。</p><p>假设没有客户端发数据过来，那么这个用户线程就会一直阻塞等着，直到有数据。即使有数据，那么两次拷贝的过程也得阻塞等着。</p><p>所以这称为同步阻塞 I/O 模型。</p><p>它的优点很明显，简单。调用 read 之后就不管了，直到数据来了且准备好了进行处理即可。</p><p>缺点也很明显，<strong>一个线程对应一个连接</strong>，一直被霸占着，即使网卡没有数据到来，也同步阻塞等着。</p><p>我们都知道线程是属于比较重资源，这就有点浪费了。</p><p>所以我们不想让它这样傻等着。</p><p>于是就有了同步非阻塞 I/O。</p><h5 id="同步非阻塞-i-o" tabindex="-1"><a class="header-anchor" href="#同步非阻塞-i-o" aria-hidden="true">#</a> 同步非阻塞 I/O</h5><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/image-11-1024x525.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>从图中我们可以很清晰的看到，同步非阻塞I/O 基于同步阻塞I/O 进行了优化：</p><p>在没数据的时候可以不再傻傻地阻塞等着，而是直接返回错误，告知暂无准备就绪的数据！</p><p>这里要注意，<strong>从内核拷贝到用户空间这一步，用户线程还是会被阻塞的</strong>。</p><p>这个模型相比于同步阻塞 I/O 而言比较灵活，比如调用 read 如果暂无数据，则线程可以先去干干别的事情，然后再来继续调用 read 看看有没有数据。</p><p>但是如果你的线程就是取数据然后处理数据，不干别的逻辑，那这个模型又有点问题了。</p><p>等于你不断地进行系统调用，如果你的服务器需要处理海量的连接，那么就需要有海量的线程不断调用，上下文切换频繁，CPU 也会忙死，做无用功而忙死。</p><p>那怎么办？</p><p>于是就有了I/O 多路复用。</p><h5 id="i-o-多路复用" tabindex="-1"><a class="header-anchor" href="#i-o-多路复用" aria-hidden="true">#</a> I/O 多路复用</h5><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/image-12-1024x514.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>从图上来看，好像和上面的同步非阻塞 I/O 差不多啊，其实不太一样，<strong>线程模型不一样</strong>。</p><p>既然同步非阻塞 I/O 在太多的连接下频繁调用太浪费了， 那就招个专员吧。</p><p>这个专员工作就是管理多个连接，帮忙查看连接上是否有数据已准备就绪。</p><p>也就是说，<strong>可以只用一个线程查看多个连接是否有数据已准备就绪</strong>。</p><p>具体到代码上，这个专员就是 select ，我们可以往 select 注册需要被监听的连接，由 select 来监控它所管理的连接是否有数据已就绪，如果有则<strong>可以</strong>通知别的线程来 read 读取数据，<strong>这个 read 和之前的一样，还是会阻塞用户线程</strong>。</p><p>这样一来就可以<strong>用少量的线程去监控多条连接</strong>，减少了线程的数量，降低了内存的消耗且减少了上下文切换的次数，很舒服。</p><p>想必到此你已经理解了什么叫 I/O 多路复用。</p><p>所谓的多路指的是多条连接，复用指的是用一个线程就可以监控这么多条连接。</p><p>看到这，再想想，还有什么地方可以优化的？</p><h5 id="信号驱动式i-o" tabindex="-1"><a class="header-anchor" href="#信号驱动式i-o" aria-hidden="true">#</a> 信号驱动式I/O</h5><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/image-13-1024x530.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>上面的 select 虽然不阻塞了，但是他得时刻去查询看看是否有数据已经准备就绪，那是不是可以让内核告诉我们数据到了而不是我们去轮询呢？</p><p>信号驱动 I/O 就能实现这个功能，由内核告知数据已准备就绪，然后用户线程再去 read（还是会阻塞）。</p><p>听起来是不是比 I/O 多路复用好呀？那为什么好像很少听到信号驱动 I/O？</p><blockquote><p>为什么市面上用的都是 I/O 多路复用而不是信号驱动?</p></blockquote><p>因为我们的应用通常用的都是 TCP 协议，而 <strong>TCP 协议的 socket 可以产生信号事件有七种</strong>。</p><p>也就是说不仅仅只有数据准备就绪才会发信号，其他事件也会发信号，而这个信号又是同一个信号，所以我们的应用程序无从区分到底是什么事件产生的这个信号。</p><p>所以我们的应用基本上用不了信号驱动 I/O，但如果你的应用程序用的是 UDP 协议，那是可以的，因为 UDP 没这么多事件。</p><p>因此，这么一看对我们而言信号驱动 I/O 也不太行。</p><h5 id="异步-i-o" tabindex="-1"><a class="header-anchor" href="#异步-i-o" aria-hidden="true">#</a> 异步 I/O</h5><p>信号驱动 I/O 虽然对 TCP 不太友好，但是这个思路对的：<strong>往异步发展</strong>，但是它并没有完全异步，因为其后面那段 read 还是会阻塞用户线程，所以它算是半异步。</p><p>因此，我们得想下如何弄成全异步的，也就是把 read 那步阻塞也省了。</p><p>其实思路很清晰：让内核直接把数据拷贝到用户空间之后再告知用户线程，来实现真正的非阻塞I/O！</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/image-14-1024x451.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>所以异步 I/O 其实就是用户线程调用 <code>aio_read</code> ，然后包括将数据从内核拷贝到用户空间那步，所有操作都由内核完成，当内核操作完毕之后，再调用之前设置的回调，此时用户线程就拿着已经拷贝到用户控件的数据可以继续执行后续操作。</p><p>在整个过程中，用户线程没有任何阻塞点，<strong>这才是真正的非阻塞I/O</strong>。</p><p>那么问题又来了:</p><blockquote><p>为什么常用的还是I/O多路复用，而不是异步I/O？</p></blockquote><p>因为 Linux 对异步 I/O 的支持不足，你可以认为还未完全实现，所以用不了异步 I/O。</p><p>这里可能有人会说不对呀，像 Tomcat 都实现了 AIO的实现类，其实像这些组件或者你使用的一些类库看起来支持了 AIO(异步I/O)，<strong>实际上底层实现是用 epoll 模拟实现的</strong>。</p><p>而 Windows 是实现了真正的 AIO，不过我们的服务器一般都是部署在 Linux 上的，所以主流还是 I/O 多路复用。</p><h5 id="同步-异步" tabindex="-1"><a class="header-anchor" href="#同步-异步" aria-hidden="true">#</a> 同步&amp;异步</h5><p>同步和异步指的是：当前线程是否需要等待方法调用执行完毕。</p><p>比如你调用一个搬运一百块石头的方法：</p><ul><li>同步指的是调用这个方法，你的线程需要等待这一百块石头搬完，然后得到搬完了的结果，接着再继续执行剩下的代码逻辑。</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 同步方式 </span>
result <span class="token operator">=</span> <span class="token function">搬一百块石头</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">// 需等待搬完的结果，才能执行下面的逻辑 </span>
<span class="token keyword">if</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">石头搬完了发工资</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 
<span class="token function">计算下一次搬石头的任务</span><span class="token punctuation">(</span><span class="token punctuation">)</span>；
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>异步指的是调用这个方法，立马就直接返回，不必等候这一百块石头还未搬完，可以立马执行后面的代码逻辑，然后利用回调或者事件通知的方式得到石头已经搬完的结果。</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 异步方式 </span>
<span class="token function">搬一百块石头</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    
  <span class="token comment">// 回调 </span>
  <span class="token function">石头搬完了发工资</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">// 不必等待石头搬完，立马执行下面的逻辑 </span>
<span class="token function">计算下一次搬石头的任务</span><span class="token punctuation">(</span><span class="token punctuation">)</span>；
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以很直观的看出，同步和异步就是调用方式的不同，这使得我们的编码方式也有所不同。</p><p>在异步调用下的代码逻辑相对而言不太直观，需要借助回调或事件通知，这在复杂逻辑下对编码能力的要求较高。而同步调用就是直来直去，等待执行完毕然后拿到结果紧接着执行下面的逻辑，对编码能力的要求较低，也更不容易出错。</p><p>所以你会发现有很多方法它是异步调用的方式，但是最终的使用还是异步转同步。</p><p>比如你向线程池提交一个任务，得到一个 future，此时是异步的，然后你在紧接着在代码里调用 <code>future.get()</code>，那就变成等待这个任务执行完成，这就是所谓的异步转同步，像 Dubbo RPC 调用同步得到返回结果就是这样实现的。</p><h5 id="阻塞-非阻塞" tabindex="-1"><a class="header-anchor" href="#阻塞-非阻塞" aria-hidden="true">#</a> 阻塞&amp;非阻塞</h5><p>阻塞和非阻塞指的是：当前接口数据还未准备就绪时，线程是否被阻塞挂起。</p><p>何为阻塞挂起？就是当前线程还处于 CPU 时间片当中，调用了阻塞的方法，由于数据未准备就绪，则时间片还未到就让出 CPU。</p><p>所以阻塞和同步看起来都是等，但是本质上它们不一样，同步的时候可没有让出 CPU。</p><p>而非阻塞就是当前接口数据还未准备就绪时，线程不会被阻塞挂起，可以不断轮询请求接口，看看数据是否已经准备就绪。</p><p>至此我们可以得到一个结论：</p><ul><li>同步&amp;异步指：当数据还未处理完成时，代码的逻辑处理方式不同。</li><li>阻塞&amp;非阻塞指：当数据还未处理完成时(未就绪)，线程的状态。</li></ul><p>所以同步&amp;异步其实是处于框架这种高层次维度来看待的，而阻塞&amp;非阻塞往往针对底层的系统调用方面来抉择，也就是说两者是从不同维度来考虑的。</p><h5 id="再结合-i-o-来看" tabindex="-1"><a class="header-anchor" href="#再结合-i-o-来看" aria-hidden="true">#</a> 再结合 I/O 来看</h5><blockquote><p>前提：程序和硬件之间隔了个操作系统，而为了安全考虑，Linux 系统分了：用户态和内核态</p></blockquote><p>在这个前提下，我们再明确 I/O 操作有两个步骤：</p><ol><li>发起 I/O 请求</li><li>实际 I/O 读写，即数据从内核缓存拷贝到用户空间</li></ol><p>阻塞 I/O 和非阻塞 I/O。按照上文，其实指的就是用户线程是否被阻塞，这里指代的步骤1（发起I/O请求）。</p><ul><li>阻塞 I/O，指用户线程发起 I/O 请求的时候，如果数据还未准备就绪（例如暂无网络数据接收），就会阻塞当前线程，让出 CPU。</li><li>非阻塞 I/O，指用户线程发起 I/O 请求的时候，如果数据还未准备就绪（例如暂无网络数据接收），也不会阻塞当前线程，可以继续执行后续的任务。</li></ul><p>可以发现，这里的阻塞和非阻塞其实是指用户线程是否会被阻塞。</p><p>同步 I/O 和异步 I/O。按照上文，我们可以得知这就是根据 I/O 响应方式不同而划分的。</p><ul><li>同步 I/O，指用户线程发起 I/O 请求的时候，数据是有的，那么将进行步骤2（实际 I/O 读写，即数据从内核缓存拷贝到用户空间），这个过程用户线程是要等待着拷贝完成。</li><li>异步 I/O，指用户线程发起 I/O 请求的时候，数据是有的，那么将进行步骤2（实际 I/O 读写，即数据从内核缓存拷贝到用户空间），拷贝的过程中不需要用户线程等待，用户线程可以去执行其它逻辑，等内核将数据从内核空间拷贝到用户空间后，用户线程会得到一个“通知”。</li></ul><p>再仔细思考下，在 I/O 场景下同步和异步说的其实是内核的实现，因为拷贝的执行者是内核，一种是同步将数据拷贝到用户空间，用户线程是需要等着的。一个是通过异步的方式，用户线程不用等，在拷贝完之后，内核会调用指定的回调函数。</p><p><strong>如果不理解上面，就只需记住：</strong></p><ul><li>同步I/O：指的是用户线程会需要等待步骤 2 执行完毕。</li><li>异步I/O：指的是用户线程不需要等待步骤 2 执行。</li></ul><p>好了，如果以上的概念你都已经理解了的话，那么平日里我们所说的同步阻塞I/O，同步非阻塞I/O等其实就是把上面的两个步骤合起来看，应该不难理解。</p><p>我再简单的总结一下，关于 I/O 的阻塞、非阻塞、同步、异步：</p><ul><li><p>阻塞和非阻塞指的是发起 I/O 请求后，用户线程状态的不同，阻塞I/O在数据未准备就绪的时候会阻塞当前用户线程，而非阻塞 I/O 会立马返回一个错误，不会阻塞当前用户线程。</p></li><li><p>同步和异步是指，内核的 I/O 拷贝实现，当数据准备就绪后，需要将内核空间的数据拷贝至用户空间，如果是同步 I/O 那么用户线程会等待拷贝的完成，而异步 I/O则这个拷贝过程用户线程该干嘛可以去干吗，当内核拷贝完毕之后会“通知”用户线程。</p></li></ul>`,314),o=[p];function c(l,i){return s(),a("div",null,o)}const u=n(t,[["render",c],["__file","Java IO.html.vue"]]);export{u as default};
