<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta property="og:url" content="https://newzone.top/MyNotes/interview/Java/Java.html"><meta property="og:site_name" content="nocetfy"><meta property="og:title" content="Java 基础"><meta property="og:description" content="Java 基础 [toc] 浮点数 浮点数是计算机对实数的近似值数值表现法。IEEE 754 是现今最广泛使用的二进制浮点数运算标准。它定义了表示浮点数的格式、反常值、特殊数值、以及这些数值的“浮点数运算符”。IEEE 754 标准指定的浮点数格式建立于二进制科学计数法的基础之上，其数值表示式为： Value=(−1)s2e(1+m)"><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"Java 基础","image":[""],"dateModified":null,"author":[]}</script><title>Java 基础 | nocetfy</title><meta name="description" content="Java 基础 [toc] 浮点数 浮点数是计算机对实数的近似值数值表现法。IEEE 754 是现今最广泛使用的二进制浮点数运算标准。它定义了表示浮点数的格式、反常值、特殊数值、以及这些数值的“浮点数运算符”。IEEE 754 标准指定的浮点数格式建立于二进制科学计数法的基础之上，其数值表示式为： Value=(−1)s2e(1+m)">
    <meta name="keywords" content="自我提升,效率提升,开源工具,学习笔记" />
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #252232;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/MyNotes/assets/style-fdc52a0b.css" as="style"><link rel="stylesheet" href="/MyNotes/assets/style-fdc52a0b.css">
    <link rel="modulepreload" href="/MyNotes/assets/app-59c87434.js"><link rel="modulepreload" href="/MyNotes/assets/framework-1ee2252c.js"><link rel="modulepreload" href="/MyNotes/assets/Java.html-f9d922bb.js"><link rel="modulepreload" href="/MyNotes/assets/Java.html-7e56cf69.js">

    <!-- 看板娘区块 -->
    <link href="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-y/font-awesome/6.0.0/css/all.min.css" type="text/css" rel="stylesheet" />
    <script src="/live2d-widget/autoload.js"></script>
    <!-- End 看板娘区块 -->

    <!-- Matomo 此区块为统计代码，请删除-->
    <script>
      var _paq = window._paq = window._paq || [];
      /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
      _paq.push(['trackPageView']);
      _paq.push(['enableLinkTracking']);
      (function() {
        var u="https://piwik.seoipo.com/";
        _paq.push(['setTrackerUrl', u+'matomo.php']);
        _paq.push(['setSiteId', '7']);
        var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
        g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
      })();
    </script>
    <!-- End Matomo Code 此区块为统计代码，请删除-->

  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">跳至主要內容</a><!--]--><!--[--><div class="theme-container has-toc"><!--[--><header class="navbar" id="navbar"><div class="navbar-start"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><a href="/MyNotes/" class="brand"><img class="logo" src="/MyNotes/logo.svg" alt="nocetfy"><!----><span class="site-name hide-in-pad">nocetfy</span></a><!--[--><!----><!--]--></div><div class="navbar-center"><!--[--><!----><!--]--><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/MyNotes/blog" class="nav-link" aria-label="博客"><span class="font-icon icon iconfont icon-blog" style=""></span>博客<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="代码"><span class="title"><span class="font-icon icon iconfont icon-code" style=""></span>代码</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/MyNotes/code/Markdown" class="nav-link" aria-label="/code/Markdown"><!---->/code/Markdown<!----></a></li><li class="dropdown-item"><a href="/MyNotes/code/AutoHotkey" class="nav-link" aria-label="/code/AutoHotkey"><!---->/code/AutoHotkey<!----></a></li><li class="dropdown-item"><a href="/MyNotes/code/Electron" class="nav-link" aria-label="/code/Electron"><!---->/code/Electron<!----></a></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>页面开发</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/MyNotes/web/VuePress" class="nav-link" aria-label="/web/VuePress"><!---->/web/VuePress<!----></a></li><li class="dropdown-subitem"><a href="/MyNotes/web/docsify" class="nav-link" aria-label="/web/docsify"><!---->/web/docsify<!----></a></li><li class="dropdown-subitem"><a href="/MyNotes/deploy/VPS" class="nav-link" aria-label="/deploy/VPS"><!---->/deploy/VPS<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="应用"><span class="title"><span class="font-icon icon iconfont icon-app" style=""></span>应用</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/MyNotes/apps/Applist" class="nav-link" aria-label="/apps/Applist"><!---->/apps/Applist<!----></a></li><li class="dropdown-item"><a href="/MyNotes/apps/ChatGPT" class="nav-link" aria-label="/apps/ChatGPT"><!---->/apps/ChatGPT<!----></a></li><li class="dropdown-item"><a href="/MyNotes/apps/livestreaming/1_obs_basic" class="nav-link" aria-label="直播手册"><span class="font-icon icon iconfont icon-quote" style=""></span>直播手册<!----></a></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>服务/系统</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/MyNotes/services/NAS" class="nav-link" aria-label="/services/NAS"><!---->/services/NAS<!----></a></li><li class="dropdown-subitem"><a href="/MyNotes/windows/faq" class="nav-link" aria-label="/windows/faq"><!---->/windows/faq<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="生活"><span class="title"><span class="font-icon icon iconfont icon-emmet" style=""></span>生活</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/MyNotes/family/Diet" class="nav-link" aria-label="/family/Diet"><!---->/family/Diet<!----></a></li><li class="dropdown-item"><a href="/MyNotes/family/Shoppinglist" class="nav-link" aria-label="/family/Shoppinglist"><!---->/family/Shoppinglist<!----></a></li><li class="dropdown-item"><a href="/MyNotes/family/Coupon" class="nav-link" aria-label="/family/Coupon"><!---->/family/Coupon<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a href="https://nav.newzone.top/" rel="noopener noreferrer" target="_blank" aria-label="工具收藏" class="nav-link"><span class="font-icon icon iconfont icon-tool" style=""></span>工具收藏<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div></nav><!--[--><!----><!--]--></div><div class="navbar-end"><!--[--><!----><!--]--><div class="nav-item"><a class="repo-link" href="https://github.com/nocetfy" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button class="outlook-button" tabindex="-1" ariahidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="outlook-dropdown"><!----></div></button></div><!--[--><button class="search-pro-button" role="search" aria-label="搜索"><svg xmlns="http://www.w3.org/2000/svg" class="icon search-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="search icon"><path d="M192 480a256 256 0 1 1 512 0 256 256 0 0 1-512 0m631.776 362.496-143.2-143.168A318.464 318.464 0 0 0 768 480c0-176.736-143.264-320-320-320S128 303.264 128 480s143.264 320 320 320a318.016 318.016 0 0 0 184.16-58.592l146.336 146.368c12.512 12.48 32.768 12.48 45.28 0 12.48-12.512 12.48-32.768 0-45.28"></path></svg></button><!--]--><!--[--><!----><!--]--><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar" id="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">🧰 算法笔记</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable active"><!----><span class="title">🚀 面试笔记</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-ability" style=""></span><span class="title">计算机基础</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable active"><span class="font-icon icon iconfont icon-ability" style=""></span><span class="title">Java</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><a href="/MyNotes/interview/Java/Java%20IO.html" class="nav-link sidebar-link sidebar-page" aria-label="Java IO"><!---->Java IO<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/MyNotes/interview/Java/Java.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="Java 基础"><!---->Java 基础<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/MyNotes/interview/Java/Java.html#浮点数" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="浮点数"><!---->浮点数<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/MyNotes/interview/Java/Java.html#集合" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="集合"><!---->集合<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/MyNotes/interview/Java/Java.html#fail-fast-机制" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Fail-Fast 机制"><!---->Fail-Fast 机制<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/MyNotes/interview/Java/Java.html#hashmap" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="HashMap"><!---->HashMap<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/MyNotes/interview/Java/Java.html#反射、动态代理、agent" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="反射、动态代理、agent"><!---->反射、动态代理、agent<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/MyNotes/interview/Java/Java.html#反射" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="反射"><!---->反射<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/MyNotes/interview/Java/Java.html#javaagent" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="javaagent"><!---->javaagent<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/MyNotes/interview/Java/Java.html#动态代理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="动态代理"><!---->动态代理<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/MyNotes/interview/Java/Java.html#问题排查" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="问题排查"><!---->问题排查<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/MyNotes/interview/Java/Java.html#cpu100-排查思路" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="cpu100%排查思路"><!---->cpu100%排查思路<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/MyNotes/interview/Java/Java.html#oom-与-fullgc-排查" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="OOM 与 FullGC 排查"><!---->OOM 与 FullGC 排查<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/MyNotes/interview/Java/Java.html#死锁排查" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="死锁排查"><!---->死锁排查<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/MyNotes/interview/Java/Java.html#堆外内存泄漏排查" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="堆外内存泄漏排查"><!---->堆外内存泄漏排查<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li></ul><!--]--></li><li><!--[--><a href="/MyNotes/interview/Java/Java%20Thread.html" class="nav-link sidebar-link sidebar-page" aria-label="Java 并发"><!---->Java 并发<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/MyNotes/interview/Java/JVM.html" class="nav-link sidebar-link sidebar-page" aria-label="JVM"><!---->JVM<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/MyNotes/interview/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html" class="nav-link sidebar-link sidebar-page" aria-label="设计模式"><!---->设计模式<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-ability" style=""></span><span class="title">MySQL</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-ability" style=""></span><span class="title">Redis</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-ability" style=""></span><span class="title">消息队列</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-ability" style=""></span><span class="title">框架</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-ability" style=""></span><span class="title">数据结构与算法</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-ability" style=""></span><span class="title">网络</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-ability" style=""></span><span class="title">架构</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-ability" style=""></span><span class="title">分布式</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-ability" style=""></span><span class="title">运维开发</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-ability" style=""></span><span class="title">开放设计</span><span class="arrow right"></span></button><!----></section></li></ul></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->Java 基础</h1><div class="page-info"><!----><!----><span class="page-word-info" aria-label="字数🔠" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon word-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="word icon"><path d="M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z"></path><path d="M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z"></path></svg><span>约 12284 字</span><meta property="wordCount" content="12284"></span><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 41 分钟</span><meta property="timeRequired" content="PT41M"></span><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容<button class="print-button" title="print"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/MyNotes/interview/Java/Java.html#浮点数" class="router-link-active router-link-exact-active toc-link level2">浮点数</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/MyNotes/interview/Java/Java.html#集合" class="router-link-active router-link-exact-active toc-link level2">集合</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/MyNotes/interview/Java/Java.html#fail-fast-机制" class="router-link-active router-link-exact-active toc-link level3">Fail-Fast 机制</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/MyNotes/interview/Java/Java.html#hashmap" class="router-link-active router-link-exact-active toc-link level3">HashMap</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/MyNotes/interview/Java/Java.html#反射、动态代理、agent" class="router-link-active router-link-exact-active toc-link level2">反射、动态代理、agent</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/MyNotes/interview/Java/Java.html#反射" class="router-link-active router-link-exact-active toc-link level3">反射</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/MyNotes/interview/Java/Java.html#javaagent" class="router-link-active router-link-exact-active toc-link level3">javaagent</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/MyNotes/interview/Java/Java.html#动态代理" class="router-link-active router-link-exact-active toc-link level3">动态代理</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/MyNotes/interview/Java/Java.html#问题排查" class="router-link-active router-link-exact-active toc-link level2">问题排查</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/MyNotes/interview/Java/Java.html#cpu100-排查思路" class="router-link-active router-link-exact-active toc-link level3">cpu100%排查思路</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/MyNotes/interview/Java/Java.html#oom-与-fullgc-排查" class="router-link-active router-link-exact-active toc-link level3">OOM 与 FullGC 排查</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/MyNotes/interview/Java/Java.html#死锁排查" class="router-link-active router-link-exact-active toc-link level3">死锁排查</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/MyNotes/interview/Java/Java.html#堆外内存泄漏排查" class="router-link-active router-link-exact-active toc-link level3">堆外内存泄漏排查</a></li><!----><!--]--></ul><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h1 id="java-基础" tabindex="-1"><a class="header-anchor" href="#java-基础" aria-hidden="true">#</a> Java 基础</h1><p>[toc]</p><h2 id="浮点数" tabindex="-1"><a class="header-anchor" href="#浮点数" aria-hidden="true">#</a> 浮点数</h2><p>浮点数是计算机对实数的近似值数值表现法。IEEE 754 是现今最广泛使用的二进制浮点数运算标准。它定义了表示浮点数的格式、反常值、特殊数值、以及这些数值的“浮点数运算符”。IEEE 754 标准指定的浮点数格式建立于二进制科学计数法的基础之上，其数值表示式为：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo>=</mo><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mi>s</mi></msup><msup><mn>2</mn><mi>e</mi></msup><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Value=(-1)^s2^e(1+m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">Va</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span></span></span></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></p><p>这里<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>为符号位， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span>是指数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>被称为尾数。以 IEEE 754 标准规定的 32 位单精度浮点数为例，如下图，从右到左第 31 位为符号位表示正负，中间 8 位（第 23 到 30 位）表示指数加偏移量 127 后的数值，后 23 位储存尾数的有效数位（最高的第 22 位对应<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>，最低的第 0 位对应 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mo>−</mo><mn>23</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{−23}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">23</span></span></span></span></span></span></span></span></span></span></span></span>）：</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/Float_example.svg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>由此可以算出实际数值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mn>0</mn></msup><msup><mn>2</mn><mrow><mn>124</mn><mo>−</mo><mn>127</mn></mrow></msup><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>2</mn></mrow></msup><mo stretchy="false">)</mo><mo>=</mo><mn>0.15625</mn></mrow><annotation encoding="application/x-tex">(-1)^02^{124-127}(1+2^{-2})=0.15625</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">124</span><span class="mbin mtight">−</span><span class="mord mtight">127</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.15625</span></span></span></span></p><p><strong>浮点数并非实数</strong>，它所表示的数会与实际的数值存在偏差。<strong>32 位单精确度浮点数只可以保证 7 位十进制有效数字，而 64 位双精度浮点数可以保证 15 位十进制有效数字</strong></p><hr><h2 id="集合" tabindex="-1"><a class="header-anchor" href="#集合" aria-hidden="true">#</a> 集合</h2><h3 id="fail-fast-机制" tabindex="-1"><a class="header-anchor" href="#fail-fast-机制" aria-hidden="true">#</a> Fail-Fast 机制</h3><p>我们使用的增强 <code>for</code> 循环，其实是 Java 提供的语法糖，其实现原理是借助 <code>Iterator</code> 进行元素的遍历。但是如果在遍历过程中，不通过 <code>Iterator</code>，而是通过集合类自身的方法对集合进行添加 / 删除操作。那么在 <code>Iterator</code> 进行下一次的遍历时，经检测发现有一次集合的修改操作并未通过自身进行，那么可能是发生了并发被其他线程执行的，这时候就则会抛出 <strong>Concurrent Modification Exception</strong>（并发修改异常），来提示用户可能发生了并发修改，这就是所谓的 <code>fail-fast</code> 机制。</p><p>采用安全失败机制的集合容器，在 <code>Iterator</code> 的实现上没有设计抛出 <code>ConcurrentModificationException</code> 的代码段，从而避免了<code>fail-fast</code>，这就是<code>fail-safe</code>。</p><hr><h3 id="hashmap" tabindex="-1"><a class="header-anchor" href="#hashmap" aria-hidden="true">#</a> HashMap</h3><h4 id="hash" tabindex="-1"><a class="header-anchor" href="#hash" aria-hidden="true">#</a> Hash</h4><p>Hash function 推荐译为散列函数，其本质是一种单向散列函数(one-way hash function)，从上述定义看到，好的散列函数通常具备几个特点：</p><ul><li>单向性(One-way) 输出确定，且无法逆推出源数据。这也是单向散列函数定义</li><li>抗冲突性(Collision-resistant) 要求产生 2 个相同的散列值是概率低，即对任意两个不同的 x,y，使得 h(x)=h(y)是困难的。</li><li>雪崩效应(Avalanche effect) 即映射分布均匀性和差分分布均匀性，或者说 原始输入数据的微小改动，能导致散列值差异非常大</li></ul><p>当然最好能具有快速计算的特性，除此以外，信息安全领域中的 Hash 算法可能还有其他要求。</p><h4 id="hashcode" tabindex="-1"><a class="header-anchor" href="#hashcode" aria-hidden="true">#</a> hashcode</h4><p>提供随机数、自增 sequence、1、内存地址、Marsaglia’s xor-shift scheme with thread-specific state，默认就是 第五类实现，即含线程级别初始状态的 hash 码，可以看到 _hashStateX 就是一个 os::random()的随机数，其他参数是恒定值，这<strong>也意味着 Object.hashCode 默认是随机</strong>的，也即如果你未重写 hashCode，那么这个类即便每个属性都是一样的值，jvm 重启之后/甚至在两个线程里 new 的两个对象，他们各自的 hashCode 是很可能不等的。</p><p><strong>需要指出的是：</strong> 1） 上述，对象在调用一次 hashCode 之后，其 hashCode 缓存在其对象头字段里，以便之后使用，即 mark-&gt;hash()。 2）通过 jvm 参数，-XX:hashCode=4 可以指定 hashcode 生成策略为内存地址。</p><h4 id="介绍" tabindex="-1"><a class="header-anchor" href="#介绍" aria-hidden="true">#</a> 介绍</h4><p>在 Java8 中，HashMap 由数组 + 链表 + 红黑树组成的。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/image-20230521235349075.png" alt="HashMap" tabindex="0" loading="lazy"><figcaption>HashMap</figcaption></figure><ul><li>HashMap 解决了什么问题</li></ul><blockquote><p>如何有效的存取一组 <code>key-vaule</code> 键值对。</p></blockquote><ul><li>如何表示<code>key-value</code>键值对</li></ul><p>定义一个类，表示键值对</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>
    <span class="token class-name">K</span> key<span class="token punctuation">;</span>
    <span class="token class-name">V</span> value<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>如何存储键值对集合</li></ul><p>存储一个对象的集合无外乎两种方式：数组 OR 链表。数组大小有限，查找性能好，插入和删除性能差。链表大小不限，查找性能差，插入和删除性能好。在实际的应用场景中，对于键值对的查找操作居多，所以我们当然选择数组形式。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>如何有效地根据<code>key</code>查找<code>value</code></li></ul><p>如果直接遍历，查看它的 <code>key</code> 是不是我们要找的 <code>key</code>，效率低下。为了利用索引来查找，我们需要建立一个 <code>key -&gt; index</code> 的映射关系，这样每次我们要查找一个 <code>key</code> 时，首先根据映射关系，计算出对应的数组下标，然后根据数组下标，直接找到对应的 <code>key-value</code> 对象，这样基本能以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>​ 的时间复杂度得到结果。将 <code>key</code> 映射成 <code>index</code> 的方法称为 <code>hash</code> 算法。使用 <code>hash</code> 算法同样补足了数组插入和删除性能差的短板，我们知道，数组之所以插入删除性能差是因为它是顺序存储的，在一个位置插入节点或者删除节点需要一个个移动它的后续节点来腾出位或者覆盖位置。使用 <code>hash</code> 算法后，数组不再按顺序存储，插入删除操作只需要关注一个存储桶即可，而不需要额外的操作.</p><ul><li>如何解决<code>hash</code>冲突</li></ul><p>虽然我们要求 <code>hash</code> 算法能将 <code>key</code> 均匀的分布到数组中，但是它只能<strong>尽量</strong>做到，并不是绝对的，更何况我们的数组大小是有限的。解决冲突的方法有很多，如开放寻址法、链地址法、再哈希法、建立公共溢出区法。我们选择链地址法，即在产生冲突的存储桶中改为单链表存储。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/hashmap.jpg" alt="链地址法" tabindex="0" loading="lazy"><figcaption>链地址法</figcaption></figure><ul><li>链表长度过长</li></ul><p>在 <code>Java8</code> 中，容量大于<code>64</code>时会开启树化，当链表长度超过<code>8</code>之后，将会自动将链表转换成红黑树，以实现<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>的时间复杂度，从而提升查找性能。理想情况下在随机哈希码和默认大小调整阈值为 0.75 的情况下，存储桶中元素个数出现的频率遵循泊松分布，一个哈希桶中链表长度达到 8 个元素的概率为 0.00000006，几乎是不可能事件。</p><ul><li>取模</li></ul><p>公式：<code>e.hash &amp; (capacity - 1) = e.hash % capacity</code>，二进制角度，除以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>，等于右移<code>n</code>位，被移掉的低<code>n</code>位就是余数，即模。如果使用位运算<code>&amp;(capacity - 1)</code>，同样是余数。可得两者相等。这也是为什么要求容量是<code>2</code>的幂，使用位运算取模，可以大大提高性能。</p><ul><li>哈希</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> h<span class="token punctuation">;</span>
  	<span class="token comment">// key可以为null且在数组第一个位置</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>int 类型是 <code>32</code> 位的，<code>h ^ h &gt;&gt;&gt; 16</code> 其实就是将 <code>hashCode</code> 的高 16 位和低 16 位进行异或，这充分利用了高半位和低半位的信息，对低位进行了<code>扰动</code> , 目的是为了使该 hashCode 映射成数组下标时可以更均匀。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/format,png.png" alt="扰动" tabindex="0" loading="lazy"><figcaption>扰动</figcaption></figure><ul><li>扩容</li></ul><p>扩容的时机：</p><ol><li>HashMap 中 put 入第一个元素，初始化数组 table。</li><li>HashMap 中的元素数量大于阈值 threshold (容量 * 负载因子)。</li></ol><p>扩容操作：数组容量翻倍，将元素迁移到新数组。同一桶内元素只可能在两个位置：原位或<code>原索引+oldCap</code>。<code>rehash</code>的值与<code>oldCap</code>做与运算，为<code>0</code>则在原位，否则在<code>原索引+oldCap</code>的位置。</p><blockquote><p>旧数组中：<code>e.hash &amp; (oldCap - 1)</code> 相当于取 <code>e.hash</code> 的低<code>n</code>位的值，该值为<code>x</code>。</p><p>新数组中：<code>e.hash &amp; (2oldCap - 1)</code> 相当于取 <code>e.hash</code> 的低<code>n + 1</code>位的值，该值为<code>y</code>。</p><p>所以当<code>e.hash &amp; oldCap = e.hash &amp; 2^n</code>为<code>0</code>时，倒数第<code>n + 1</code>位的值是<code>0</code>，此时<code>y = x</code>。若为<code>1</code>，此时倒数第<code>n + 1</code>位的值是<code>1</code>，此时<code>y = x + oldCap</code>。</p></blockquote><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/1460000015812441.png" alt="rezise" tabindex="0" loading="lazy"><figcaption>rezise</figcaption></figure><ul><li>头插法 尾插法</li></ul><p>缓存的时间局部性原则，最近访问过的数据下次大概率会再次访问，把刚访问过的元素放在链表最前面可以直接被查询到，减少查找次数。所以 7 之前使用头插法，但是在多线程环境下有成环问题。8 才会采用尾插法。</p><ul><li><code>put</code>操作</li></ul><ol><li>在 put 之前会检查 table 是否为空，说明 table 真正的初始化并不是发生在构造函数中， 而是发生在第一次 put 的时候。</li><li>查找当前 key 是否存在的条件是：</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="3"><li><p>如果插入的 key 值不存在，则值会插入到链表的末尾。</p></li><li><p>每次插入操作结束后，都会检查当前 table 节点数是否大于 <code>threshold</code>, 若超过，则扩容。</p></li><li><p>当链表长度超过 <code>TREEIFY_THRESHOLD</code>（默认是 8）个时，会将链表转换成红黑树以提升查找性能。</p></li></ol><hr><h2 id="反射、动态代理、agent" tabindex="-1"><a class="header-anchor" href="#反射、动态代理、agent" aria-hidden="true">#</a> 反射、动态代理、agent</h2><h3 id="反射" tabindex="-1"><a class="header-anchor" href="#反射" aria-hidden="true">#</a> 反射</h3><p>反射(Reflection)是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。</p><p><strong>通过反射机制，可以在运行时访问 Java 对象的属性，方法，构造方法等。</strong></p><h4 id="反射的应用场景" tabindex="-1"><a class="header-anchor" href="#反射的应用场景" aria-hidden="true">#</a> 反射的应用场景</h4><p>反射的主要应用场景有：</p><ul><li><strong>开发通用框架</strong> - 反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 JavaBean、Filter 等），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。</li><li><strong>动态代理</strong> - 在切面编程（AOP）中，需要拦截特定的方法，通常，会选择动态代理方式。这时，就需要反射技术来实现了。</li><li><strong>注解</strong> - 注解本身仅仅是起到标记作用，它需要利用反射机制，根据注解标记去调用注解解释器，执行行为。如果没有反射机制，注解并不比注释更有用。</li><li><strong>可扩展性功能</strong> - 应用程序可以通过使用完全限定名称创建可扩展性对象实例来使用外部的用户定义类。</li></ul><p>方法的反射调用会带来不少性能开销，原因主要有三个：</p><ul><li>变长参数方法导致的 Object 数组</li><li>基本类型的自动装箱、拆箱</li><li>还有最重要的方法内联</li></ul><p><code>Class.forName</code> 会调用本地方法，<code>Class.getMethod</code> 则会遍历该类的公有方法。如果没有匹配到，它还将遍历父类的公有方法。可想而知，这两个操作都非常费时。</p><blockquote><p>注意，以 <code>getMethod</code> 为代表的查找方法操作，会返回查找得到结果的一份拷贝。因此，我们应当避免在热点代码中使用返回 <code>Method</code> 数组的 <code>getMethods</code> 或者 <code>getDeclaredMethods</code> 方法，以减少不必要的堆空间消耗。在实践中，我们往往会在应用程序中缓存 <code>Class.forName</code> 和 <code>Class.getMethod</code> 的结果。</p></blockquote><p>下面只关注反射调用本身的性能开销。</p><p>第一，由于 Method.invoke 是一个变长参数方法，在字节码层面它的最后一个参数会是 Object 数组（感兴趣的同学私下可以用 javap 查看）。Java 编译器会在方法调用处生成一个长度为传入参数数量的 Object 数组，并将传入参数一一存储进该数组中。</p><p>第二，由于 Object 数组不能存储基本类型，Java 编译器会对传入的基本类型参数进行自动装箱。</p><p>这两个操作除了带来性能开销外，还可能占用堆内存，使得 GC 更加频繁。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/image-20230611214548304.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>要想使用反射，首先需要获得待操作的类所对应的 Class 对象。<strong>Java 中，无论生成某个类的多少个对象，这些对象都会对应于同一个 Class 对象。这个 Class 对象是由 JVM 生成的，通过它能够获悉整个类的结构</strong>。所以，<code>java.lang.Class</code> 可以视为所有反射 API 的入口点。</p><p><strong>反射的本质就是：在运行时，把 Java 类中的各种成分映射成一个个的 Java 对象。</strong></p><p>反射的核心是 JVM 在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。</p><p>Java 反射框架主要提供以下功能：</p><ol><li>在运行时判断任意一个对象所属的类；</li><li>在运行时构造任意一个类的对象；</li><li>在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用 private 方法）；</li><li>在运行时调用任意一个对象的方法</li></ol><hr><h3 id="javaagent" tabindex="-1"><a class="header-anchor" href="#javaagent" aria-hidden="true">#</a> javaagent</h3><p>Java Agent 直译为 Java 代理，也常常被称为 Java 探针技术。</p><p>Java Agent 是在 JDK1.5 引入的，是一种可以动态修改 Java 字节码的技术。Java 中的类编译后形成字节码被 JVM 执行，在 JVM 在执行这些字节码之前获取这些字节码的信息，并且通过字节码转换器对这些字节码进行修改，以此来完成一些额外的功能。</p><p>Java Agent 是一个不能独立运行 jar 包，它通过依附于目标程序的 JVM 进程，进行工作。启动时只需要在目标程序的启动参数中添加-javaagent 参数添加 ClassFileTransformer 字节码转换器，相当于在 main 方法前加了一个拦截器。</p><p>所谓 Java Agent，其功能都是基于<code>java.lang.instrument</code>中的类去完成。<code>Instrument</code>提供了允许 Java 编程语言代理检测 JVM 上运行的程序的功能，<strong>而检测的机制就是修改字节码</strong>。<code>Instrument</code>位于<strong>rt.jar</strong>中，<code>java.lang.instrument</code>包下，使用<code>Instrument</code>可以用来<strong>检测</strong>或<strong>协助</strong>运行在 JVM 中的程序；甚至对已加载 class 进行替换修改，这也就是我们常说的<strong>热部署、热加载</strong>。<strong>一句话总结<code>Instrument</code>：检测类的加载行为对其进行干扰（修改替换）</strong></p><p><code>Instrument</code>的实现基于<code>JVMTI(Java Virtual Machine Tool Interface)</code>的，所谓 JVMTI 就是一套由 Java 虚拟机提供的，为 JVM 相关的工具提供的本地编程接口集合。JVMTI<strong>基于事件驱动</strong>，简单点讲就是在 JVM 运行层面添加一些<strong>钩子</strong>可以供开发者去自定义实现相关功能。</p><p><strong>Java Agent 主要有以下功能</strong></p><ul><li>Java Agent 能够在加载 Java 字节码之前拦截并对字节码进行修改;</li><li>Java Agent 能够在 Jvm 运行期间修改已经加载的字节码;</li></ul><p>Java Agent 的应用场景</p><ul><li>IDE 的调试功能，例如 Eclipse、IntelliJ IDEA ；</li><li>热部署功能，例如 JRebel、XRebel、spring-loaded；</li><li>各种线上诊断工具，例如 Btrace、Greys，还有阿里的 Arthas；</li><li>各种性能分析工具，例如 Visual VM、JConsole 等；</li><li>全链路性能检测工具，例如 Skywalking、Pinpoint 等；</li></ul><h4 id="实现原理" tabindex="-1"><a class="header-anchor" href="#实现原理" aria-hidden="true">#</a> 实现原理</h4><p>一种是在 main 方法执行之前，通过<code>premain</code>来执行，另一种是程序运行中修改，需通过 JVM 中的 Attach 实现，<code>Attach</code>的实现原理是基于<code>JVMTI</code>。主要是在类加载之前，进行拦截，对字节码修改。</p><p>下面我们分别介绍一下这些关键术语：</p><p><code>JVMTI</code> 就是<code>JVM Tool Interface</code>，是 JVM 暴露出来给用户扩展使用的接口集合，JVMTI 是基于事件驱动的，JVM 每执行一定的逻辑就会触发一些事件的回调接口，通过这些回调接口，用户可以自行扩展</p><p>JVMTI 是实现 Debugger、Profiler、Monitor、Thread Analyser 等工具的统一基础，在主流 Java 虚拟机中都有实现</p><p><code>JVMTIAgent</code>是一个动态库，利用 JVMTI 暴露出来的一些接口来干一些我们想做、但是正常情况下又做不到的事情，不过为了和普通的动态库进行区分，它一般会实现如下的一个或者多个函数：</p><ul><li><code>Agent_OnLoad</code>函数，如果 agent 是在启动时加载的，通过 JVM 参数设置</li><li><code>Agent_OnAttach</code>函数，如果 agent 不是在启动时加载的，而是我们先 attach 到目标进程上，然后给对应的目标进程发送 load 命令来加载，则在加载过程中会调用 Agent_OnAttach 函数</li><li><code>Agent_OnUnload</code>函数，在 agent 卸载时调用</li></ul><p><strong><code>javaagent</code></strong> 依赖于 instrument 的 JVMTIAgent（Linux 下对应的动态库是 <a href="http://libinstrument.so" target="_blank" rel="noopener noreferrer">libinstrument.so<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>），还有个别名叫 JPLISAgent(Java Programming Language Instrumentation Services Agent)，专门为 Java 语言编写的插桩服务提供支持的。</p><p><strong><code>instrument</code></strong> 实现了<code>Agent_OnLoad</code>和<code>Agent_OnAttach</code>两方法，也就是说在使用时，<code>agent</code>既可以在启动时加载，也可以在运行时动态加载。其中启动时加载还可以通过类似-javaagent:jar 包路径的方式来间接加载 instrument agent，运行时动态加载依赖的是 JVM 的 attach 机制，通过发送 load 命令来加载 agent。</p><p><strong><code>JVM Attach</code></strong> 是指 JVM 提供的一种进程间通信的功能，能让一个进程传命令给另一个进程，并进行一些内部的操作，比如进行线程 dump，那么就需要执行 jstack 进行，然后把 pid 等参数传递给需要 dump 的线程来执行。</p><h5 id="jvm-启动前的-agent-实现" tabindex="-1"><a class="header-anchor" href="#jvm-启动前的-agent-实现" aria-hidden="true">#</a> JVM 启动前的 agent 实现</h5><p>Instrument 是 JDK5 开始引入，在 JDK5 中 Instrument 要求在目标 JVM 程序运行之前通过命令行参数<strong>javaagent</strong>来设置代理类，在 JVM 初始化之前，Instrument 启动在 JVM 中设置回调函数，检测特点类加载情况完成实际增强工作。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>-javaagent: jarpath<span class="token punctuation">[</span> <span class="token operator">=</span>options<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这里 jarpath 就是我们的 agent jar 的路径，agent jar 必须符合 jar 文件规范。代理 JAR 文件的<code>manifest（META-INF/MANIFEST.MF）</code>必须包含属性<code>Premain-Class</code>。此属性的值是代理类的类名。代理类必须实现一个公共静态<code>premain</code>方法，该方法原则上与主应用程序入口点类似。在 JVM 初始化之后，将按照指定代理的顺序调用每个主方法（premain），然后将调用实际应用程序的主方法(main)。每个 premain 方法必须按照启动顺序返回。</p><p>premain 方法可以有如下两种重载方法，<strong>如果两者同时存在，则优先调用多参数的方法</strong>：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">premain</span><span class="token punctuation">(</span><span class="token class-name">String</span> agentArgs<span class="token punctuation">,</span> <span class="token class-name">Instrumentation</span> inst<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">premain</span><span class="token punctuation">(</span><span class="token class-name">String</span> agentArgs<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/image-20230611223541096.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>premain 模式也有一些缺陷，例如如果 agent 在运行过程中出现异常，那么也会导致主程序的启动失败。</p><h5 id="jvm-启动后的-agent-实现" tabindex="-1"><a class="header-anchor" href="#jvm-启动后的-agent-实现" aria-hidden="true">#</a> JVM 启动后的 agent 实现</h5><p>JDK6 开始为<code>Instrument</code>增加很多强大的功能，其中要指出的就是在 JDK5 中如果想要完成增强处理，必须是在目标 JVM 程序启动前通过命令行指定<code>Instrument</code>,然后在实际应用中，目标程序可能是已经运行中，针对这种场景下如果要保证 JVM 不重启得以完成我们工作，这不是我们想要的，于是 JDK6 中<code>Instrument</code>提供了在 JVM 启动之后指定设置 java agent 达到<code>Instrument</code>的目的。</p><p>该实现需要确保以下 3 点：</p><ol><li>agent jar 中 manifest 必须包含属性 Agent-Class，其值为 agent 类名。</li><li>agent 类中必须包含公有静态方法<strong>agentmain</strong></li><li>system classload 必须支持可以将 agent jar 添加到 system class path。</li></ol><p><code>agent jar</code>将被添加到<code>system class path</code>，这个路径就是<code>SystemClassLoader</code>加载主应用程序的地方，<code>agent class</code>被加载后，JVM 将会尝试执行它的<code>agentmain</code>方法，同样的，如果以下两个方法都存在，则优先执行多参数方法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">agentmain</span><span class="token punctuation">(</span><span class="token class-name">String</span> agentArgs<span class="token punctuation">,</span> <span class="token class-name">Instrumentation</span> inst<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">agentmain</span><span class="token punctuation">(</span><span class="token class-name">String</span> agentArgs<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>看到这里，结合 JVM 前启动前 agent 的实现和 JVM 启动后 agent 的实现，可能想问是否可以在一个<code>agent class</code>中同时包含<code>premain、agentmain</code>呢，答案是可以的，只不过在 JVM 启动前不会执行<code>agentmain</code>，同样的，JVM 启动后不会执行<code>premain</code>。</p><p><strong>如果我们的 agent 无法启动（agent class 无法被加载、agentmain 出异常、agent class 没有合法的 agentmain 方法等），JVM 将不会终止！</strong></p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/image-20230611223841335.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="agent-代理监控-jvm" tabindex="-1"><a class="header-anchor" href="#agent-代理监控-jvm" aria-hidden="true">#</a> agent 代理监控 JVM</h4><h5 id="背景" tabindex="-1"><a class="header-anchor" href="#背景" aria-hidden="true">#</a> 背景</h5><p>当我们使用 JDK 工具排查问题的时候，潜台词往往就是问题已经发生并且可能对业务造成了影响，并且我们无法通过 JDK 工具了解到问题出现前发生了什么。如果我们能够将 JVM 监控接入到公司的监控平台 ，持续监控并且辅以合理的告警阈值，我们可以做到在问题发生前就将其处理掉，避免对业务的影响，对比使用 JDK 排查问题的方式，JVM 监控工具有以下优势：</p><ul><li>更加简单易用。</li><li>直观。通过监控图表看到各方面的性能数据</li><li>持续实时采集数据</li><li>历史可回溯。协助分析问题</li><li>可告警通知。设置阈值告警，先于问题发生进行处理</li></ul><p>#####对 JVM Agent 的要求</p><p>除了要满足 JVM 性能数据采集的功能需要，作为对 JVM 性能进行监控的工具，必须要保证避免或较少的对所监控的 JVM 造成影响。故 JVM Agent 应当关注同时也尽量满足以下几点：</p><ul><li>较低的性能损耗。启动快，资源占用少，Agent 的数据采集较少的影响到 JVM 的性能</li><li>容错性。Agent 自身的运行时错误不应影响到 JVM 之上业务的运行</li><li>低侵入性。监控逻辑不应该侵入到业务逻辑当中</li><li>可配置化。能灵活打开关闭或调整 Agent 的监控行为</li><li>实时性。每一次的采集到数据应当是那一刻的真实 JVM 性能数据</li><li>兼容性。针对不同的 Java 应用程序以及 JDK 版本均能正常采集数据</li></ul><h5 id="jvm-agent-应当采集的数据" tabindex="-1"><a class="header-anchor" href="#jvm-agent-应当采集的数据" aria-hidden="true">#</a> JVM Agent 应当采集的数据</h5><p>JVM Agent 主要采集 JVM 的内存使用、GC 以及线程的状态信息，具体如下：</p><table><thead><tr><th style="text-align:left;">指标</th><th style="text-align:left;">含义</th></tr></thead><tbody><tr><td style="text-align:left;">heap_init</td><td style="text-align:left;">堆内存初始字节数</td></tr><tr><td style="text-align:left;">heap_max</td><td style="text-align:left;">堆内存最大字节数</td></tr><tr><td style="text-align:left;">heap_used</td><td style="text-align:left;">堆内存已使用字节数</td></tr><tr><td style="text-align:left;">heap_committed</td><td style="text-align:left;">堆内存已提交字节数</td></tr><tr><td style="text-align:left;">non_heap_init</td><td style="text-align:left;">非堆内存初始字节数</td></tr><tr><td style="text-align:left;">non_heap_max</td><td style="text-align:left;">非堆内存最大字节数</td></tr><tr><td style="text-align:left;">non_heap_used</td><td style="text-align:left;">非堆内存已使用字节数</td></tr><tr><td style="text-align:left;">non_heap_committed</td><td style="text-align:left;">非堆内存已提交字节数</td></tr><tr><td style="text-align:left;">direct_capacity</td><td style="text-align:left;">DirectBuffer 总字节大小</td></tr><tr><td style="text-align:left;">direct_used</td><td style="text-align:left;">DirectBuffer 已使用字节数</td></tr><tr><td style="text-align:left;">mapped_capacity</td><td style="text-align:left;">MappedBuffer 总字节大小</td></tr><tr><td style="text-align:left;">mapped_used</td><td style="text-align:left;">MappedBuffer 已使用字节数</td></tr><tr><td style="text-align:left;">eden_space_init</td><td style="text-align:left;">新生代 Eden 初始字节数</td></tr><tr><td style="text-align:left;">eden_space_max</td><td style="text-align:left;">新生代 Eden 最大字节数</td></tr><tr><td style="text-align:left;">eden_space_used</td><td style="text-align:left;">新生代 Eden 已使用字节数</td></tr><tr><td style="text-align:left;">eden_space_committed</td><td style="text-align:left;">新生代 Eden 已提交字节数</td></tr><tr><td style="text-align:left;">survivor_space_init</td><td style="text-align:left;">新生代 Survivor 初始字节数</td></tr><tr><td style="text-align:left;">survivor_space_max</td><td style="text-align:left;">新生代 Survivor 最大字节数</td></tr><tr><td style="text-align:left;">survivor_space_used</td><td style="text-align:left;">新生代 Survivor 已使用字节数</td></tr><tr><td style="text-align:left;">survivor_space_committed</td><td style="text-align:left;">新生代 Survivor 已提交字节数</td></tr><tr><td style="text-align:left;">old_gen_init</td><td style="text-align:left;">老年代初始字节数</td></tr><tr><td style="text-align:left;">old_gen_max</td><td style="text-align:left;">老年代最大字节数</td></tr><tr><td style="text-align:left;">old_gen_used</td><td style="text-align:left;">老年代已使用字节数</td></tr><tr><td style="text-align:left;">old_gen_committed</td><td style="text-align:left;">老年代已提交字节数</td></tr><tr><td style="text-align:left;">perm_gen_init</td><td style="text-align:left;">永生代初始字节数</td></tr><tr><td style="text-align:left;">perm_gen_max</td><td style="text-align:left;">永生代最大字节数</td></tr><tr><td style="text-align:left;">perm_gen_used</td><td style="text-align:left;">永生代已使用字节数</td></tr><tr><td style="text-align:left;">perm_gen_committed</td><td style="text-align:left;">永生代已提交字节数</td></tr><tr><td style="text-align:left;">metaspace_init</td><td style="text-align:left;">Metaspace 初始字节数(JDK8+)</td></tr><tr><td style="text-align:left;">metaspace_max</td><td style="text-align:left;">Metaspace 最大字节数(JDK8+)</td></tr><tr><td style="text-align:left;">metaspace_used</td><td style="text-align:left;">Metaspace 已使用字节数(JDK8+)</td></tr><tr><td style="text-align:left;">metaspace_committed</td><td style="text-align:left;">Metaspace 已提交字节数(JDK8+)</td></tr><tr><td style="text-align:left;">minor_gc_time</td><td style="text-align:left;">MinorGC 耗时</td></tr><tr><td style="text-align:left;">minor_gc_cnt</td><td style="text-align:left;">MinorGC 次数</td></tr><tr><td style="text-align:left;">major_gc_time</td><td style="text-align:left;">MajorGC 耗时</td></tr><tr><td style="text-align:left;">major_gc_cnt</td><td style="text-align:left;">MajorGC 次数</td></tr><tr><td style="text-align:left;">live_thread_cnt</td><td style="text-align:left;">当前线程总数</td></tr><tr><td style="text-align:left;">peak_thread_cnt</td><td style="text-align:left;">最大线程数</td></tr><tr><td style="text-align:left;">total_thread_cnt</td><td style="text-align:left;">累计已启动线程数</td></tr><tr><td style="text-align:left;">daemon_thread_cnt</td><td style="text-align:left;">守护线程数</td></tr><tr><td style="text-align:left;">new_thread_cnt</td><td style="text-align:left;">New 状态线程数</td></tr><tr><td style="text-align:left;">runnable_thread_cnt</td><td style="text-align:left;">Runnable 状态线程数</td></tr><tr><td style="text-align:left;">blocked_thread_cnt</td><td style="text-align:left;">Blocked 状态线程数</td></tr><tr><td style="text-align:left;">waiting_thread_cnt</td><td style="text-align:left;">Waiting 状态线程数</td></tr><tr><td style="text-align:left;">timedwaiting_thread_cnt</td><td style="text-align:left;">TimedWaiting 状态线程数</td></tr><tr><td style="text-align:left;">terminated_thread_cnt</td><td style="text-align:left;">Terminated 状态线程数</td></tr><tr><td style="text-align:left;">deadlock_thread_cnt</td><td style="text-align:left;">死锁线程数</td></tr><tr><td style="text-align:left;">java_spec_version</td><td style="text-align:left;">Java 版本</td></tr><tr><td style="text-align:left;">java_vm_name</td><td style="text-align:left;">JVM 名称</td></tr><tr><td style="text-align:left;">java_vm_version</td><td style="text-align:left;">JVM 版本</td></tr></tbody></table><h5 id="java-agent-及相关-api" tabindex="-1"><a class="header-anchor" href="#java-agent-及相关-api" aria-hidden="true">#</a> Java Agent 及相关 API</h5><p>JVM 性能监控 Agent 的实现主要使用了 Java Agent 技术，以及 Management API。本节将对 <code>java.lang.instument</code> 和 <code>java.lang.management</code> 这两个用到的主要 API 作简单的介绍，接着对 Java Agent 的特点，并结合 demo 对 Java Agent 的使用和开发进行介绍。</p><h5 id="java-lang-instrument-api-简介" tabindex="-1"><a class="header-anchor" href="#java-lang-instrument-api-简介" aria-hidden="true">#</a> java.lang.instrument API 简介</h5><p><code>java.lang.instrument</code> 从 JDK5 开始引入，它是基于 JVMTI 工具提供的一套 Java API， 利用 JVMTI 提供的丰富编程接口，可以完成很多跟 JVM 有关的功能。它为开发者提供了 API 用于检测 Java 应用程序，例如监控应用程序或者收集性能信息；同时开发者也可以通过 <code>java.lang.instrument</code> API 来修改 class 的字节码(字节码增强)，从而达到动态改变和操作类定义的目的，其最常见的用途是在无侵入的情况下为 Java 方法提供 AOP 服务。</p><h5 id="java-agent-开发指南" tabindex="-1"><a class="header-anchor" href="#java-agent-开发指南" aria-hidden="true">#</a> Java Agent 开发指南</h5><p>Java Agent 与 <code>java.lang.instrument</code> API 有莫大的关系，它是 <code>java.lang.instrument</code> API 提供的的编程入口，在 Java Agent 中可以很方便的使用到 Instrument API，以及完成其他一些操作。</p><p>Java Agent 的使用有以下几个重点：</p><ol><li>Java Agent 必须打包成 jar 包部署，同时在 jar 包的 manifest 文件中指定需要启动的 Java Agent 类</li><li>Java Agent 支持两种启动方式。两种启动方式的区别在于 Java Agent 被加载和启动的时机不一样，第一种方式是命令行接口， Agent 会伴随 JVM 的启动被加载，且早于<code>main</code>方法被调用；第二种方式是在 JVM 启动后，通过 Attach API 启动 Agent</li><li>Java Agent 的 jar 包会被加入到 SystemClassLoader 的 ClassPath 中，并且由 SystemClassLoader 加载</li></ol><p>Java Agent 的两种启动方式介绍如下：</p><h5 id="命令行接口" tabindex="-1"><a class="header-anchor" href="#命令行接口" aria-hidden="true">#</a> 命令行接口</h5><p>在命令行接口中，Agent 的启动必须在 JVM 启动参数中加入以下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>-javaagent:jarpath<span class="token punctuation">[</span><span class="token operator">=</span>options<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>jarpath</code> 指的是 Agent jar 包的路径，<code>options</code>为需要传入到 Agent 的参数，当有多个 Agent 的时候可以多次使用 <code>javaagent</code> 参数。</p><p>Agent jar 包的 manifest 文件必须包含参数 <code>Premain-Class</code>， 其值为 Agent 类名。Agent 类提供了两个重载的<code>premain()</code>方法，<code>premain()</code>方法的作用类似于<code>main（）</code>方法作为调用入口，当 JVM 完成初始化后，每一个 Agent 的 <code>premain()</code>方法会先被调用，然后才调用真正的应用程序的 <code>main()</code>方法。两个重载的方法如下：</p><ol><li><p>JVM 会先尝试调用 Agent 类中带两个参数的<code>premain</code>重载方法</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">premain</span><span class="token punctuation">(</span><span class="token class-name">String</span> agentArgs<span class="token punctuation">,</span> <span class="token class-name">Instrumentation</span> inst<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>如果 Agent 类中没有实现上面的方法，那么 JVM 会尝试调用带一个参数的<code>premain</code>重载方法</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">premain</span><span class="token punctuation">(</span><span class="token class-name">String</span> agentArgs<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ol><p>需要注意的是，如果 Agent 类解析失败(例如 Agent 的 class 加载失败或者 Agent 类中没有实现 <code>premain</code> 方法)，那么 JVM 将退出；又或者 <code>premain</code> 方法抛出了未捕获异常，那么 JVM 也会退出。</p><h5 id="jvm-运行时加载-agent" tabindex="-1"><a class="header-anchor" href="#jvm-运行时加载-agent" aria-hidden="true">#</a> JVM 运行时加载 Agent</h5><p>通过 Attach API 提供了在运行时加载 Agent 的机制，至于 Agent 是什么时候被加载视乎具体 attach 的时机而定，而一般 attach 的时候，应用程序已经启动并且 <code>main</code> 方法已经被调用。</p><p>Agent jar 包的 manifest 文件必须包含参数 <code>Agent-Class</code>，其值为 Agent 类名。同样的 Agent 提供了两个重载的 <code>agentmain</code> 方法作为调用入口，并且传入 Agent 参数以及 Instrumentation 对象。两个重载的方法如下：</p><ol><li><p>JVM 会首先尝试调用 Agent 类中带两个参数的 <code>agentmain</code> 重载方法</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>public static void agentmain(String agentArgs, Instrumentation inst);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>如果 Agent 类中没有实现上面的方法，那么 JVM 会尝试调用带一个参数的 <code>agentmain</code>方法</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>public static void agentmain(String agentArgs);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ol><p>与前面一种启动方式不同，如果 Agent 不能成功启动(例如：Agent 类加载失败或者没有实现<code>agentmain</code>方法)，那么 JVM 将不会退出；另外，如果<code>agentmain</code>方法抛出了未捕捉异常，那么这个异常将被忽略，而不会导致 JVM 的退出</p><h5 id="java-agent-示例" tabindex="-1"><a class="header-anchor" href="#java-agent-示例" aria-hidden="true">#</a> Java Agent 示例</h5><p>Agent 的更多详细内容可以参考<a href="https://docs.oracle.com/javase/7/docs/api/java/lang/instrument/package-summary.html" target="_blank" rel="noopener noreferrer">官方文档<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>，如果对 JVMTI 以及 Attach API 有兴趣的童鞋也可去了解一下。下面通过一个简单 demo 演示了一下使用第一种启动方式开发的 Agent。</p><p>Main 方法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AgentTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// main方法调用时打印</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;AgentTest main function invoked!!!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Agent 类：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>instrument<span class="token punctuation">.</span></span><span class="token class-name">Instrumentation</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JavaAgent</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">premain</span><span class="token punctuation">(</span><span class="token class-name">String</span> agentArgs<span class="token punctuation">,</span> <span class="token class-name">Instrumentation</span> instrumentation<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 采用伴随 JVM 启动加载 Agent 的方式，premain 方法应当先于 main 方法被调用</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;JavaAgent premain invoke!!!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>manifest：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Manifest-Version: 1.0
Premain-Class: JavaAgent
Created-By: 1.8.0_161 (Oracle Corporation)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 jar 命令打包：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>ken@vm1 src<span class="token punctuation">]</span>$ /usr/local/jdk1.8/bin/jar <span class="token parameter variable">-cvfm</span> JavaAgent.jar JavaAgent_manifest JavaAgent.class
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>JVM 参数：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>// 启动时，通过 <span class="token parameter variable">-javaagent</span> 参数指定 Agent jar 包的路径
<span class="token punctuation">[</span>ken@vm1 src<span class="token punctuation">]</span>$ /usr/local/jdk1.8/bin/java -javaagent:/home/ken/tmp/javaAgent/src/JavaAgent.jar AgentTest
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>JavaAgent premain invoke<span class="token operator">!</span><span class="token operator">!</span><span class="token operator">!</span>
AgentTest main <span class="token keyword">function</span> invoked<span class="token operator">!</span><span class="token operator">!</span><span class="token operator">!</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="java-lang-manament-api-简介" tabindex="-1"><a class="header-anchor" href="#java-lang-manament-api-简介" aria-hidden="true">#</a> java.lang.manament API 简介</h5><p><code>java.lang.management</code> 包提供管理接口用于监控以及管理 JVM 以及 Java 运行时的其他组件。我们开发的 JVM Agent 就是通过这个包提供的接口，收集到 JVM 中包括内存、GC、线程在内的信息。<code>java.lang.management</code> 包提供了以下的接口：</p><ul><li>BufferPoolMXBean：bufferPool 管理接口，例如：直接缓冲池、映射缓冲池</li><li>ClassLoadingMXBean：JVM 的类加载系统管理接口</li><li>CompilationMXBean：JVM 编译系统管理接口</li><li>GarbageCollectionMXBean：JVM GC 管理接口，提供不同垃圾回收器的回收次数和耗时信息</li><li>MemoryManagerMXBean：内存管理器接口，内存管理器负责管理各个分区的内存，包括了我们常说的垃圾回收器</li><li>MemoryMXBean：JVM 内存系统管理接口，提供获取堆内存以及非堆内存信息</li><li>MemoryPoolMXBean：内存池管理接口，内存池也就是我们常说的 Java 内存分代分区，如：新生代、老年代、永生代等等</li><li>OperatingSystemMXBean：提供 JVM 所运行的操作系统信息</li><li>RuntimeMXBean：提供 JVM 运行时系统信息</li><li>ThreadMXBean：JVM 线程管理接口，提供 JVM 线程的相关信息</li></ul><p>各个 MXBean 提供的具体数据获取接口，可以查看<a href="https://docs.oracle.com/javase/7/docs/api/java/lang/instrument/package-summary.html" target="_blank" rel="noopener noreferrer">官方文档<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>进一步了解。</p><p>下面以 MemoryMXBean 为例，其提供了主要接口获取内存信息：</p><ul><li><code>MemoryUsage getHeapMemoryUsage()</code></li><li><code>MemoryUsage getNonHeapMemoryUsage()</code></li></ul><p>上面两个接口将返回当前堆或非堆的内存使用信息，这些信息封装在 MemoryUsage 对象中。MemoryUsage 对象提供了内存的四个属性，分别是：init、used、committed、max，表示当前堆或非堆内存的：初始化内存大小，已使用内存大小，已提交内存大小，最大内存大小，单位为字节数。</p><p>通过以上的属性，我们就可以清晰的了解到内存的详细使用情况，对于 JVM 的其他监控指标同理。</p><h5 id="jvm-agent-设计实现" tabindex="-1"><a class="header-anchor" href="#jvm-agent-设计实现" aria-hidden="true">#</a> JVM Agent 设计实现</h5><p>在上一篇文章中已经对 JVM 性能监控 Agent 所涉及的技术和 API 做了简单的介绍，接下来第二部分将探讨 JVM 性能监控 Agent 的设计实现以及一些问题的解决思路</p><h5 id="最简单的-jvm-agent-实现" tabindex="-1"><a class="header-anchor" href="#最简单的-jvm-agent-实现" aria-hidden="true">#</a> 最简单的 JVM Agent 实现</h5><p>通过对 Java Agent 以及相关 API，我想大家应该想到一种 JVM Agent 的设计方案，基本思路就是利用 Java Agent 的先于 main 方法执行而且无需修改应用程序源代码的特性，实现一个 Java Agent 的 <code>premain</code> 方法，并且在 <code>premain</code> 中启动一个独立线程，该线程负责定时通过 <code>java.lang.management</code> 包提供的 API 收集 JVM 的性能数据并打包上报，如下图所示：</p><p>![](<a href="https://blog-share-1255904243.cos.ap-guangzhou.myqcloud.com/JVM%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7Agent%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/%E7%AE%80%E5%8D%95JVM" target="_blank" rel="noopener noreferrer">https://blog-share-1255904243.cos.ap-guangzhou.myqcloud.com/JVM性能监控Agent设计实现/简单JVM<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> Agent.PNG)</p><p>看上去似乎这种设计方案就可以满足我们的要求了，是真的如此吗？实际上，基于这种设计方案实现的监控 Agent 接入到普通的简单 Java 应用程序是可以胜任工作的，JVM 的性能数据能够被成功的采集并且上报。</p><p>但是，考虑到我们将应用到生产环境，需要监控的运行于 JVM 之上的应用程序有：Tomcat，Resin，Spark，Hadoop，ElasticSearch 等等。这些不同的应用程序的运行环境各有差别，那么我们设计开发的 JVM 性能监控 Agent 必须考虑之前提到的兼容性。</p><p>下面我将以常见的 Web 容器(Tomcat 和 Resin)为例来探讨 JVM Agent 的设计实现。</p><h5 id="classnotfoundexception-问题" tabindex="-1"><a class="header-anchor" href="#classnotfoundexception-问题" aria-hidden="true">#</a> ClassNotFoundException 问题</h5><p>考虑以下情况，在 Tomcat 中部署的 Web 服务引用了公司的一个公共 jar 包，这里简单叫做 <code>package1.jar</code>，而在我按照上面思路开发的第一版 JVM Agent 中也使用到了这个公共 jar 包中的类<code>com.xxx.Comm</code>。</p><p>当我将 JVM Agent 接入到 Tomcat 中进行测试的时候，并没有在简单 Java 应用程序中的那样顺利收集并上报 JVM 性能数据，而是出现了 <code>ClassNotFoundException</code> 异常，具体为找不到<code>com.xxx.Comm</code>这个类，导致 Tomcat 启动失败。</p><p>在前后翻查思考一轮后意识到了问题与 Java 类加载机制有关，不过为了让大家更好的理解其中的具体原因，在揭晓答案前我先简单的谈谈 Java 的类加载机制以及在 Web 容器( Tomcat 和 Resin )中实现的类加载机制。</p><h5 id="浅谈-java-类加载机制" tabindex="-1"><a class="header-anchor" href="#浅谈-java-类加载机制" aria-hidden="true">#</a> 浅谈 Java 类加载机制</h5><p>Java 源代码编译后生成的 class 文件需要经过 JVM 的加载，才能够在应用程序中使用。这个类加载过程分为多个阶段：加载、验证、准备、解析、初始化等等，不过这个加载的细节我们不需要过多的去关心，因为在 JVM 中，类的加载已经封装抽象成类加载器(ClassLoader)来完成，这个 ClassLoader 隐藏了底层类加载的细节，但是也保持了一定灵活性，使得开发者可以通过 ClassLoader 来控制类的加载行为。</p><h6 id="类与类加载器" tabindex="-1"><a class="header-anchor" href="#类与类加载器" aria-hidden="true">#</a> 类与类加载器</h6><p>对于任意一个类，都需要同它的类加载器和这个类本身一同确定其在 Java 虚拟机中的唯一性。换言之，同样类名的一个类，由 ClassLoaderA 加载的和由 ClassLoaderB 加载的实际上是两个不一样的类 。</p><h6 id="类加载的时机" tabindex="-1"><a class="header-anchor" href="#类加载的时机" aria-hidden="true">#</a> 类加载的时机</h6><p>JVM 启动时不会一次性将所有的类加载进来，而是在运行时根据应用程序的需要动态的由类加载进行加载。至于一个类具体时什么时候被加载进来，比较复杂需要视情况而定(在这里不做详细说明，有兴趣的可以自行了解以下)，一个简单不怎么严谨的概括就是：在类第一次被使用的被加载。</p><h6 id="双亲委派模型" tabindex="-1"><a class="header-anchor" href="#双亲委派模型" aria-hidden="true">#</a> 双亲委派模型</h6><p>双亲委派模型是 Java 中类加载机制的关键，它是 JDK 中的类加载机制实现。其主要目的是为了，通过双亲委派模型来组织类加载器之间的关系，使得 Java 类随它的类加载器一起形成具备优先级的层次关系，保证了 JDK 核心类的唯一性，避免类加载的混乱。</p><p>在 JDK 的双亲委派模型中，有三种不同的类加载器，负责不同类的加载，分别是：</p><ul><li><p>BootstrapClassLoader</p><p>负责 JDK 核心类库的加载，如：rt.jar。一般为存放在 <code>&lt;JAVA_HOME&gt;\lib</code> 目录下的，或者是被 <code>-Xbootstrappath</code> 参数所指定的路径中的类</p></li><li><p>ExtensionClassLoader</p><p>主要负责 JDK 扩展类库的加载。一般为<code>&lt;JAVA_HOME&gt;\lib\ext</code> 目录中，或者被 <code>java.ext.dirs</code> 系统变量所指定的路径中的所有类库</p></li><li><p>SystemClassLoader(ApplicationClassLoader)</p><p>负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载，一般情况下这个就是程序中默认的类加载器</p></li></ul><p>双亲委派模型中，这三种类加载器的关系如下：</p><figure><a href="https://blog-share-1255904243.cos.ap-guangzhou.myqcloud.com/JVM%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7Agent%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/JDK%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.PNG" target="_blank" rel="noopener noreferrer"><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/JDK类加载器.png" alt="img" tabindex="0" loading="lazy"><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a><figcaption>img</figcaption></figure><p>双亲委派模型中除了顶层的 BootstrapClassLoader 外，其余的的类加载都应该有自己的父类加载器。类加载的过程如下：</p><ol><li>当一个类加载器收到了类加载请求后，首先会检查类是否已经被加载</li><li>如果类没有被加载，那么当前类加载器会委托父类加载器去完成，每一层次的类加载器都是如此；相反，如果发现类已经被加载，将会直接返回</li><li>在向上委托的过程中，如果父类加载器无法完成类加载，那么当前类加载器将会尝试自己加载</li><li>如果当前类加载器还是不能完成类的加载，那么说明类加载失败，报 ClassNotFoundException</li></ol><p>整个过程在 JDK 源码实现中非常简单，但是用处很大，而在涉及类加载的开发，也应当了解这么一个流程。</p><p>JDK 源码如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token function">getClassLoadingLock</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// First, check if the class has already been loaded</span>
            <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">long</span> t0 <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                        c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// ClassNotFoundException thrown if class not found</span>
                    <span class="token comment">// from the non-null parent class loader</span>
                <span class="token punctuation">}</span>

                <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// If still not found, then invoke findClass in order</span>
                    <span class="token comment">// to find the class.</span>
                    <span class="token keyword">long</span> t1 <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>

                    <span class="token comment">// this is the defining class loader; record the stats</span>
                    <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>PerfCounter</span><span class="token punctuation">.</span><span class="token function">getParentDelegationTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addTime</span><span class="token punctuation">(</span>t1 <span class="token operator">-</span> t0<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>PerfCounter</span><span class="token punctuation">.</span><span class="token function">getFindClassTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addElapsedTimeFrom</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>PerfCounter</span><span class="token punctuation">.</span><span class="token function">getFindClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> c<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="web-tomcat-resin-的类加载机制" tabindex="-1"><a class="header-anchor" href="#web-tomcat-resin-的类加载机制" aria-hidden="true">#</a> Web(Tomcat &amp; Resin) 的类加载机制</h5><p>常见的 Web 容器，如 Tomcat 以及 Resin，它们的类加载机制都在 JDK 原有的基础上进行了扩展，因此我们设计开发的 JVM Agent 也应该适应这种情况进行处理。</p><p>Tomcat 与 Resin 作为 Web 容器，其类加载机制是类似的，这里放在一起介绍，同时对其类加载器结构作了一定简化。</p><figure><a href="https://blog-share-1255904243.cos.ap-guangzhou.myqcloud.com/JVM%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7Agent%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/Web%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.jpg" target="_blank" rel="noopener noreferrer"><img src="https://blog-share-1255904243.cos.ap-guangzhou.myqcloud.com/JVM性能监控Agent设计实现/Web类加载器.jpg" alt="img" tabindex="0" loading="lazy"><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a><figcaption>img</figcaption></figure><p>对于这类 Web 类加载器，它们是支持单个实例运行多个不同的 Web 应用。为了避免不同的 Web 应用依赖的类库发生冲突(如：版本不一样)，Web 容器为不同的 Web 应用创建了其专属的类加载器负责相关类库的加载，将不同的 Web 应用的类加载隔离开来。另外，对于部分公共的基础类库，如容器自身的类库，将会由各 WebAppClassLoader 的父类加载器——CommonClassLoader 负责，这样可以降低一部分的资源占用。</p><p>而一般的，Web 服务所依赖的 jar 包均放到 <code>WEB-INF/lib/</code>目录下，由 WebAppClassLoader 负责加载。</p><h5 id="jvm-agent-中的解决方案" tabindex="-1"><a class="header-anchor" href="#jvm-agent-中的解决方案" aria-hidden="true">#</a> JVM Agent 中的解决方案</h5><h5 id="异常原因" tabindex="-1"><a class="header-anchor" href="#异常原因" aria-hidden="true">#</a> 异常原因</h5><p>通过上面对 JDK 类加载机制以及 Web 和 Svr 的类加载机制的简单介绍，大家应该大概可以猜到当 JVM Agent 接入到 Tomcat 后出现的 <code>ClassNotFoundException</code> 原因了：</p><figure><a href="https://blog-share-1255904243.cos.ap-guangzhou.myqcloud.com/JVM%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7Agent%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/web%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%94%99%E8%AF%AF%E5%8E%9F%E5%9B%A0.png" target="_blank" rel="noopener noreferrer"><img src="https://blog-share-1255904243.cos.ap-guangzhou.myqcloud.com/JVM性能监控Agent设计实现/web类加载错误原因.png" alt="img" tabindex="0" loading="lazy"><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a><figcaption>img</figcaption></figure><p>我们知道 Java Agent 由 SystemClassLoader 类加载器负责加载，在 JVM Agent 中依赖到的 <code>com.xxx.Comm</code> 类位于 <code>....xxx/WEB-INF/lib/</code> 目录下，由 WebAppClassLoader 类加载器负责加载。由双亲委派模型可知，类的加载是向上查找的，当 JVM Agent 在 SystemClassLoader、ExtensionClassLoader 以及 BootstrapClassLoader 的 ClassPath 中均查找不到 <code>com.xxx.Comm</code> 类后就只能抛出 <code>ClassNotFoundException</code> 了。</p><h5 id="解决思路" tabindex="-1"><a class="header-anchor" href="#解决思路" aria-hidden="true">#</a> 解决思路</h5><p>在讨论解决方案前，先回忆以下几个比较重要的点：</p><ul><li>Java Agent 由 SystemClassLoader 加载</li><li>一般情况下，当需要创建一个类的实例的时候(使用 new)，将会由当前所在类的类加载器负责加载</li></ul><p>换言之，如果由 SystemClassLoader 加载的 JavaAgent 中需要用到的其他类也将会由 SystemClassLoader 负责加载。为了能让 <code>com.xxx.Comm</code> 类能够被 JVM Agent 查找得到，不外乎就是将其放到 JVM Agent 相同的类加载路径中(ClassPath)。</p><p>主要思路有两个：</p><ul><li>将依赖到的类库 jar 包加入到 SystemClassLoader 的类加载路径中。</li><li>采用类似 Tomcat 的实现，JVM Agent 由以 SystemClassLoader 为父类加载器的自定义类加载器加载，自己拥有另外一份 jar 包，独立于应用程序的类加载器，将 JVM Agent 的逻辑与 JavaAgent 的入口逻辑分离。</li></ul><p>第一种方式看似简单，但实际上，由于依赖的公共 jar 包 <code>package1.jar</code> 内类的依赖情况较为复杂，会依赖到其他的一些 jar 包，反而导致其他类的 <code>ClassNotFoundException</code> 异常</p><p>而第二种方式，虽然是实现上要较为复杂，但是 JVM Agent 中使用到的公共 jar 包类 <code>com.xxx.Comm</code>并没有依赖包外的其他类，故比较可取。而且另外的一个好处是，之后如果 JVM Agent 中需要依赖到一些第三方包，也可以避免与原应用程序依赖的包发生冲突。</p><h6 id="使用自定义类加载器" tabindex="-1"><a class="header-anchor" href="#使用自定义类加载器" aria-hidden="true">#</a> 使用自定义类加载器</h6><blockquote><p>注意：上面方式二提到，因为要把 JavaAgent 入口方法逻辑从实现的 JVM Agent 分离出去，故下面的提到 JVM Agent 指代的仅仅包含 JVM 监控逻辑</p></blockquote><p>一般情况下直接创建对象实例，如 new，会使用当前类或实例所属的类加载器完成加载，那么我们怎样才能够让 JVM Agent 由自定义类加载器来加载呢？答案是借助 ClassLoader 的 loadClass 方法和 Java 反射(reflect)来实现，步骤如下：</p><ol><li>JavaAgent 入口中创建自定义类加载器实例，同时将依赖的 jar 包加入到这个自定义类加载器的 ClassPath 中</li><li>调用这个自定义类加载器的 loadClass 方法 加载 JVM Agent 类，获取到其 class 对象</li><li>由 class 对象反射创建 JVM Agent 对象实例</li></ol><p>实现代码片段：</p><figure><a href="https://blog-share-1255904243.cos.ap-guangzhou.myqcloud.com/JVM%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7Agent%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5.jpg" target="_blank" rel="noopener noreferrer"><img src="https://blog-share-1255904243.cos.ap-guangzhou.myqcloud.com/JVM性能监控Agent设计实现/自定义类加载器代码片段.jpg" alt="img" tabindex="0" loading="lazy"><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a><figcaption>img</figcaption></figure><h6 id="分离-jar-包" tabindex="-1"><a class="header-anchor" href="#分离-jar-包" aria-hidden="true">#</a> 分离 jar 包</h6><p><img src="https://blog-share-1255904243.cos.ap-guangzhou.myqcloud.com/JVM性能监控Agent设计实现/整体类加载机制.png" alt="" loading="lazy">](htt</p><p>为了将 JavaAgent 入口逻辑与 JVM Agent 监控逻辑分离，上面的使用自定义类加载器还未完全解决问题，还需要在物理上(jar 包)做分离。</p><p>在原先的设计中，因为 JavaAgent 必须由 SystemClassLoader 加载，也就是我们的 jar 包也必须在 SystemClassLoader 的 ClassPath 中，使用 CustomClassLoader 去加载 JVM Agent 类时，因为双亲委派模型，还是会先委派由 SystemClassLoader 加载，而包含在其 ClassPath 的 jar 包中有 JVM Agent 的 class，所以还是无效。因此我们需要将 JVM Agent 的监控逻辑分离出来独立成一个 jar 包，使得在 SystemClassLoader 的 ClassPath 中没有 JVM Agent 的类</p><p>而另一方面，因为 JavaAgent 逻辑负责 Agent 的启动和配置读取等等，会有改动的可能，而且今后可能会有多个类似 Agent 的开发，如果这部分的逻辑发生改动就需要将全部的 Agent 重新编译打包上线。而当 JavaAgent 入口分离出来后，只需要重新编译 JavaAgent 这部分逻辑就可以了。</p><p>因此我们将 JavaAgent 的入口与 JVM Agent 的监控逻辑相分离，JavaAgent 入口封装到 <code>agent-boostrap.jar</code> 包中，依然由 SystemClassLoader 负责加载；而 JVM Agent 的监控逻辑封装到 <code>agent-jvm.jar</code> 包中，与其他依赖到的包(<code>package1.jar</code>)一起放到<code>path/to/javaAgent/</code>这个独立的目录中，由自定义类加载器负责加载，这样 JVM Agent 中依赖到的类都会由这个自定义类加载器加载，与原本的 Web 应用程序的类加载机制独立。</p><p>流程：</p><ol><li>JVM 启动后</li><li>调用 <code>agent-bootstrap.jar</code> 包中的 JavaAgent <code>premain()</code>入口</li><li>创建自定义类加载器，通过这个类加载器从 <code>agent-jvm.jar</code> 包中加载 JVM Agent 对应的 class</li><li>创建 JVM Agent 实例</li><li>启动 JVM Agent 定时采集上报线程</li><li>完成 JVM Agent 的启动，调用 <code>main()</code>方法</li></ol><h5 id="更进一步-agent-可插拔化" tabindex="-1"><a class="header-anchor" href="#更进一步-agent-可插拔化" aria-hidden="true">#</a> 更进一步：Agent 可插拔化</h5><p>因为目前已经分离出来两个 jar 包，<code>agent-bootstrap.jar</code> 包负责引导启动，而 <code>agent-jvm.jar</code> 包则包含 JVM 监控逻辑，负责数据的采集上报。考虑到之后可能有其他开发类似的使用 JavaAgent 开发的需求，因此实际上可以进一步抽象成简单的开发框架：新开发的 Agent 只需要实现指定的接口并打成 jar 包，然后配置到 Agent 列表中就可以启用，无需考虑 JavaAgent 实现、 配置读取以及一些类加载的细节。</p><h6 id="设计思路" tabindex="-1"><a class="header-anchor" href="#设计思路" aria-hidden="true">#</a> 设计思路</h6><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/Agent可插拔.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在之前的实现中，JVM Agent 监控逻辑所在的类是由自定义类加载器根据提供的类名加载的，也即<code>ClassLoader.loadClass(String name, boolean resolve)</code>方法。因此我们可以配置化的指定 Agent 的类名，就可以加载并创建该 Agent 类的实例。同时，这些 Agent 实现了 <code>com.xxx.Agent</code> 接口的接口方法 <code>boot()</code>作为入口方法，AgentBootstrap 逻辑在创建目标 Agent 实例后可以通过反射调用该方法启动目标 Agent 逻辑。</p><p>在实际代码实现中，为了进一步简化 Agent 列表的配置，不需要填写完整的 Agent 类名，如 <code>JvmAgent</code>，参考了 Java SPI 的 ServiceLoader 实现，这里不作详述。</p><h5 id="jvm-agent-最终设计" tabindex="-1"><a class="header-anchor" href="#jvm-agent-最终设计" aria-hidden="true">#</a> JVM Agent 最终设计</h5><p>所以在最终的 JVM Agent 设计方案中，涉及到<code>agent-bootstrap.jar</code>和<code>agent-jvm.jar</code>这么两个 jar 包，以及需要配置这么一个 JVM 参数 <code>-javaagent:/path/to/javaAgent/agent-bootstrap.jar -Dagent.bootstrap.agents=JvmAgent</code>就可以完成 JVM 监控的接入</p><p>JVM Agent 的启动流程如下：</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/Agent启动流程1.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h3 id="动态代理" tabindex="-1"><a class="header-anchor" href="#动态代理" aria-hidden="true">#</a> 动态代理</h3><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/12e1964581f38f04488dfc6d2f84f003110966.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="实现方式" tabindex="-1"><a class="header-anchor" href="#实现方式" aria-hidden="true">#</a> 实现方式</h4><ul><li>静态代理，工程师编辑代理类代码，实现代理模式；在编译期就生成了代理类。</li><li>基于 JDK 实现动态代理，通过 jdk 提供的工具方法 Proxy.newProxyInstance 动态构建全新的代理类(继承 Proxy 类，并持有 InvocationHandler 接口引用 )字节码文件并实例化对象返回。(jdk 动态代理是由 java 内部的反射机制来实例化代理对象，并代理的调用委托类方法)</li><li>基于 CGlib 动态代理模式 基于继承被代理类生成代理子类，不用实现接口。只需要被代理类是非 final 类即可。(cglib 动态代理底层是借助 asm 字节码技术)</li><li>基于 Aspectj 实现动态代理（修改目标类的字节，织入代理的字节，在程序编译的时候 插入动态代理的字节码，不会生成全新的 Class ）</li></ul><blockquote><p>日常工作中使用的基本是 spring aop，其借用了 Aspectj 的一些概念和注解，如<code>@Aspect</code>、<code>@Before</code>等。</p></blockquote><ul><li>基于 instrumentation 实现动态代理（修改目标类的字节码、类装载的时候动态拦截去修改，基于 javaagent） <code>-javaagent:spring-instrument-4.3.8.RELEASE.jar</code> （类装载的时候 插入动态代理的字节码，不会生成全新的 Class）。</li></ul><hr><h2 id="问题排查" tabindex="-1"><a class="header-anchor" href="#问题排查" aria-hidden="true">#</a> 问题排查</h2><h3 id="cpu100-排查思路" tabindex="-1"><a class="header-anchor" href="#cpu100-排查思路" aria-hidden="true">#</a> cpu100%排查思路</h3><ol><li><p>首先，使用 TOP 显示出那个进程 CPU%+</p></li><li><p>然后使用 TOP -Hp PID 查看进程内那个线程的使用率飘高</p></li><li><p>选取几个线程的 id，然后转换为 16 进制</p></li><li><p>jstack pid | grep 线程十六进制 -A 20 --color</p></li><li><p>打印堆栈信息</p></li></ol><h3 id="oom-与-fullgc-排查" tabindex="-1"><a class="header-anchor" href="#oom-与-fullgc-排查" aria-hidden="true">#</a> OOM 与 FullGC 排查</h3><h4 id="事前配置参数" tabindex="-1"><a class="header-anchor" href="#事前配置参数" aria-hidden="true">#</a> 事前配置参数</h4><p>打印 gc 日志、发生 FullGC 和 OOM 时生成 heap dump</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token parameter variable">-XX:+HeapDumpOnOutOfMemoryError</span>
<span class="token parameter variable">-XX:HeapDumpPath</span><span class="token operator">=</span><span class="token variable">$DIR</span>/logs/heap.dump
<span class="token parameter variable">-XX:+PrintGCDetails</span>
<span class="token parameter variable">-XX:+PrintGCDateStamps</span>
-Xloggc:<span class="token variable">$DIR</span>/logs/gc.log
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="获取-dump-文件" tabindex="-1"><a class="header-anchor" href="#获取-dump-文件" aria-hidden="true">#</a> 获取 dump 文件</h4><p>如果配置了上面的参数，就可以获取了，否则使用 jmap、jstack 获取相应的 heap dump、thread dump 文件</p><h4 id="mat-分析" tabindex="-1"><a class="header-anchor" href="#mat-分析" aria-hidden="true">#</a> MAT 分析</h4><p>将导出的文件进行分析，可以使用 JProfile、gceasy、heaphero、fasthread 进行分析。</p><blockquote><p>如我发现的 OOM 异常是用 JProfile 分析，发现大量的 byte[]对象，由 epoll 创建，最终是从 CloseableHttpClient 来的，发现代码中是每次请求都会创建一个连接池导致的。</p></blockquote><h4 id="修改验证" tabindex="-1"><a class="header-anchor" href="#修改验证" aria-hidden="true">#</a> 修改验证</h4><p>修改后进行验证。</p><hr><h3 id="死锁排查" tabindex="-1"><a class="header-anchor" href="#死锁排查" aria-hidden="true">#</a> 死锁排查</h3><ul><li>死锁时线程是什么状态</li></ul><blockquote><p>BLOCKED 或者 WAITING( on parking)，即 synchronized 锁或 ReentrantLock 导致。</p></blockquote><h3 id="堆外内存泄漏排查" tabindex="-1"><a class="header-anchor" href="#堆外内存泄漏排查" aria-hidden="true">#</a> 堆外内存泄漏排查</h3><p>频繁发生 GC，但是堆内内存正常，考虑元空间内存泄漏，导致 GC。</p></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/nocetfy/edit/main/docs/interview/Java/Java.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><!----><!----></div></footer><nav class="page-nav"><a href="/MyNotes/interview/Java/Java%20IO.html" class="nav-link prev" aria-label="Java IO"><div class="hint"><span class="arrow left"></span>上一页</div><div class="link"><!---->Java IO</div></a><a href="/MyNotes/interview/Java/Java%20Thread.html" class="nav-link next" aria-label="Java 并发"><div class="hint">下一页<span class="arrow right"></span></div><div class="link">Java 并发<!----></div></a></nav><!----><!----><!--]--></main><!--]--><!----></div><!--]--><!--]--><!----><!----><!--]--></div>
    <script type="module" src="/MyNotes/assets/app-59c87434.js" defer></script>
    <script src="https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-y/instant.page/5.1.0/instantpage.min.js" type="application/javascript"></script>
  </body>
</html>
