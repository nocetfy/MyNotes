<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta property="og:url" content="https://newzone.top/MyNotes/interview/MQ/Kafka.html"><meta property="og:site_name" content="nocetfy"><meta property="og:title" content="Kafka"><meta property="og:description" content="Kafka [toc] Kafka架构 ​	Apache Kafka 采取了分区日志模型，是一种分布式数据存储。经过优化以实时提取和处理流数据。流数据是指由数千个数据源持续生成的数据，通常可同时发送数据记录。流平台需要处理这些持续流入的数据，按照顺序逐步处理。"><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"Kafka","image":[""],"dateModified":null,"author":[]}</script><title>Kafka | nocetfy</title><meta name="description" content="Kafka [toc] Kafka架构 ​	Apache Kafka 采取了分区日志模型，是一种分布式数据存储。经过优化以实时提取和处理流数据。流数据是指由数千个数据源持续生成的数据，通常可同时发送数据记录。流平台需要处理这些持续流入的数据，按照顺序逐步处理。">
    <meta name="keywords" content="自我提升,效率提升,开源工具,学习笔记" />
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #252232;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/MyNotes/assets/style-5e5da23a.css" as="style"><link rel="stylesheet" href="/MyNotes/assets/style-5e5da23a.css">
    <link rel="modulepreload" href="/MyNotes/assets/app-a0fec2f7.js"><link rel="modulepreload" href="/MyNotes/assets/framework-47f15ee6.js"><link rel="modulepreload" href="/MyNotes/assets/Kafka.html-288bc4e5.js"><link rel="modulepreload" href="/MyNotes/assets/Kafka.html-d95c0b9e.js">

    <!-- 看板娘区块 -->
    <link href="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-y/font-awesome/6.0.0/css/all.min.css" type="text/css" rel="stylesheet" />
    <script src="/live2d-widget/autoload.js"></script>
    <!-- End 看板娘区块 -->

    <!-- Matomo 此区块为统计代码，请删除-->
    <script>
      var _paq = window._paq = window._paq || [];
      /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
      _paq.push(['trackPageView']);
      _paq.push(['enableLinkTracking']);
      (function() {
        var u="https://piwik.seoipo.com/";
        _paq.push(['setTrackerUrl', u+'matomo.php']);
        _paq.push(['setSiteId', '7']);
        var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
        g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
      })();
    </script>
    <!-- End Matomo Code 此区块为统计代码，请删除-->

  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">跳至主要內容</a><!--]--><!--[--><div class="theme-container has-toc"><!--[--><header class="navbar" id="navbar"><div class="navbar-start"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><a href="/MyNotes/" class="brand"><img class="logo" src="/MyNotes/logo.svg" alt="nocetfy"><!----><span class="site-name hide-in-pad">nocetfy</span></a><!--[--><!----><!--]--></div><div class="navbar-center"><!--[--><!----><!--]--><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/MyNotes/blog" class="nav-link" aria-label="博客"><span class="font-icon icon iconfont icon-blog" style=""></span>博客<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="代码"><span class="title"><span class="font-icon icon iconfont icon-code" style=""></span>代码</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/MyNotes/code/Markdown" class="nav-link" aria-label="/code/Markdown"><!---->/code/Markdown<!----></a></li><li class="dropdown-item"><a href="/MyNotes/code/AutoHotkey" class="nav-link" aria-label="/code/AutoHotkey"><!---->/code/AutoHotkey<!----></a></li><li class="dropdown-item"><a href="/MyNotes/code/Electron" class="nav-link" aria-label="/code/Electron"><!---->/code/Electron<!----></a></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>页面开发</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/MyNotes/web/VuePress" class="nav-link" aria-label="/web/VuePress"><!---->/web/VuePress<!----></a></li><li class="dropdown-subitem"><a href="/MyNotes/web/docsify" class="nav-link" aria-label="/web/docsify"><!---->/web/docsify<!----></a></li><li class="dropdown-subitem"><a href="/MyNotes/deploy/VPS" class="nav-link" aria-label="/deploy/VPS"><!---->/deploy/VPS<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="应用"><span class="title"><span class="font-icon icon iconfont icon-app" style=""></span>应用</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/MyNotes/apps/Applist" class="nav-link" aria-label="/apps/Applist"><!---->/apps/Applist<!----></a></li><li class="dropdown-item"><a href="/MyNotes/apps/ChatGPT" class="nav-link" aria-label="/apps/ChatGPT"><!---->/apps/ChatGPT<!----></a></li><li class="dropdown-item"><a href="/MyNotes/apps/livestreaming/1_obs_basic" class="nav-link" aria-label="直播手册"><span class="font-icon icon iconfont icon-quote" style=""></span>直播手册<!----></a></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>服务/系统</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/MyNotes/services/NAS" class="nav-link" aria-label="/services/NAS"><!---->/services/NAS<!----></a></li><li class="dropdown-subitem"><a href="/MyNotes/windows/faq" class="nav-link" aria-label="/windows/faq"><!---->/windows/faq<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="生活"><span class="title"><span class="font-icon icon iconfont icon-emmet" style=""></span>生活</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/MyNotes/family/Diet" class="nav-link" aria-label="/family/Diet"><!---->/family/Diet<!----></a></li><li class="dropdown-item"><a href="/MyNotes/family/Shoppinglist" class="nav-link" aria-label="/family/Shoppinglist"><!---->/family/Shoppinglist<!----></a></li><li class="dropdown-item"><a href="/MyNotes/family/Coupon" class="nav-link" aria-label="/family/Coupon"><!---->/family/Coupon<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a href="https://nav.newzone.top/" rel="noopener noreferrer" target="_blank" aria-label="工具收藏" class="nav-link"><span class="font-icon icon iconfont icon-tool" style=""></span>工具收藏<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div></nav><!--[--><!----><!--]--></div><div class="navbar-end"><!--[--><!----><!--]--><div class="nav-item"><a class="repo-link" href="https://github.com/nocetfy" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button class="outlook-button" tabindex="-1" ariahidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="outlook-dropdown"><!----></div></button></div><!--[--><button class="search-pro-button" role="search" aria-label="搜索"><svg xmlns="http://www.w3.org/2000/svg" class="icon search-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="search icon"><path d="M192 480a256 256 0 1 1 512 0 256 256 0 0 1-512 0m631.776 362.496-143.2-143.168A318.464 318.464 0 0 0 768 480c0-176.736-143.264-320-320-320S128 303.264 128 480s143.264 320 320 320a318.016 318.016 0 0 0 184.16-58.592l146.336 146.368c12.512 12.48 32.768 12.48 45.28 0 12.48-12.512 12.48-32.768 0-45.28"></path></svg></button><!--]--><!--[--><!----><!--]--><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar" id="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">🧰 算法笔记</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable active"><!----><span class="title">🚀 面试笔记</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-ability" style=""></span><span class="title">计算机基础</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-ability" style=""></span><span class="title">Java</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-ability" style=""></span><span class="title">MySQL</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-ability" style=""></span><span class="title">Redis</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable active"><span class="font-icon icon iconfont icon-ability" style=""></span><span class="title">消息队列</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="Kafka"><!---->Kafka<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#kafka架构" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Kafka架构"><!---->Kafka架构<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#设计理念" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="设计理念"><!---->设计理念<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#持久化" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="持久化"><!---->持久化<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#生产者-producer" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="生产者 （Producer）"><!---->生产者 （Producer）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#消费者-consumer" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="消费者 （Consumer）"><!---->消费者 （Consumer）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#kafka-replicas是怎么管理的" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Kafka Replicas是怎么管理的？"><!---->Kafka Replicas是怎么管理的？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#如何确定当前能读到哪一条消息" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="如何确定当前能读到哪一条消息？"><!---->如何确定当前能读到哪一条消息？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#发送消息的分区策略有哪些" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="发送消息的分区策略有哪些？"><!---->发送消息的分区策略有哪些？<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#partition文件存储" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="partition文件存储"><!---->partition文件存储<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#拓展-timeindex" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="拓展-timeindex"><!---->拓展-timeindex<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#拓展-冷热分离" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="拓展-冷热分离"><!---->拓展-冷热分离<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#时间轮" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="时间轮"><!---->时间轮<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#应用场景" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="应用场景"><!---->应用场景<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#分层时间轮" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="分层时间轮"><!---->分层时间轮<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#避免reblance" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="避免reblance"><!---->避免reblance<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#选举" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="选举"><!---->选举<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#常见选主机制的缺点" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="常见选主机制的缺点"><!---->常见选主机制的缺点<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#controller选举" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="controller选举"><!---->controller选举<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#分区leader选举" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="分区leader选举"><!---->分区leader选举<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#消费组leader选举" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="消费组leader选举"><!---->消费组leader选举<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#kafka为什么快" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="kafka为什么快"><!---->kafka为什么快<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#kafka实现延迟队列" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="kafka实现延迟队列"><!---->kafka实现延迟队列<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#排序" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="排序"><!---->排序<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#扩大时间轮" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="扩大时间轮"><!---->扩大时间轮<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#多级时间轮" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="多级时间轮"><!---->多级时间轮<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#延迟加载" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="延迟加载"><!---->延迟加载<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#commitlog保存超长延迟的数据" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="CommitLog保存超长延迟的数据"><!---->CommitLog保存超长延迟的数据<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#bouns" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="BOUNS"><!---->BOUNS<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li></ul><!--]--></li><li><!--[--><a href="/MyNotes/interview/MQ/RabbitMQ.html" class="nav-link sidebar-link sidebar-page" aria-label="RabbitMQ"><!---->RabbitMQ<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/MyNotes/interview/MQ/%E5%9F%BA%E7%A1%80.html" class="nav-link sidebar-link sidebar-page" aria-label="基础"><!---->基础<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-ability" style=""></span><span class="title">框架</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-ability" style=""></span><span class="title">数据结构与算法</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-ability" style=""></span><span class="title">网络</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-ability" style=""></span><span class="title">架构</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-ability" style=""></span><span class="title">分布式</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-ability" style=""></span><span class="title">运维开发</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-ability" style=""></span><span class="title">开放设计</span><span class="arrow right"></span></button><!----></section></li></ul></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->Kafka</h1><div class="page-info"><!----><!----><span class="page-word-info" aria-label="字数🔠" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon word-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="word icon"><path d="M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z"></path><path d="M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z"></path></svg><span>约 9653 字</span><meta property="wordCount" content="9653"></span><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 32 分钟</span><meta property="timeRequired" content="PT32M"></span><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容<button class="print-button" title="print"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#kafka架构" class="router-link-active router-link-exact-active toc-link level2">Kafka架构</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#设计理念" class="router-link-active router-link-exact-active toc-link level2">设计理念</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#持久化" class="router-link-active router-link-exact-active toc-link level3">持久化</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#生产者-producer" class="router-link-active router-link-exact-active toc-link level3">生产者 （Producer）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#消费者-consumer" class="router-link-active router-link-exact-active toc-link level3">消费者 （Consumer）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#kafka-replicas是怎么管理的" class="router-link-active router-link-exact-active toc-link level3">Kafka Replicas是怎么管理的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#如何确定当前能读到哪一条消息" class="router-link-active router-link-exact-active toc-link level3">如何确定当前能读到哪一条消息？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#发送消息的分区策略有哪些" class="router-link-active router-link-exact-active toc-link level3">发送消息的分区策略有哪些？</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#partition文件存储" class="router-link-active router-link-exact-active toc-link level2">partition文件存储</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#拓展-timeindex" class="router-link-active router-link-exact-active toc-link level3">拓展-timeindex</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#拓展-冷热分离" class="router-link-active router-link-exact-active toc-link level3">拓展-冷热分离</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#时间轮" class="router-link-active router-link-exact-active toc-link level2">时间轮</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#应用场景" class="router-link-active router-link-exact-active toc-link level3">应用场景</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#分层时间轮" class="router-link-active router-link-exact-active toc-link level3">分层时间轮</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#避免reblance" class="router-link-active router-link-exact-active toc-link level2">避免reblance</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#选举" class="router-link-active router-link-exact-active toc-link level2">选举</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#常见选主机制的缺点" class="router-link-active router-link-exact-active toc-link level3">常见选主机制的缺点</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#controller选举" class="router-link-active router-link-exact-active toc-link level3">controller选举</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#分区leader选举" class="router-link-active router-link-exact-active toc-link level3">分区leader选举</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#消费组leader选举" class="router-link-active router-link-exact-active toc-link level3">消费组leader选举</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#kafka为什么快" class="router-link-active router-link-exact-active toc-link level2">kafka为什么快</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#kafka实现延迟队列" class="router-link-active router-link-exact-active toc-link level2">kafka实现延迟队列</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#排序" class="router-link-active router-link-exact-active toc-link level3">排序</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#扩大时间轮" class="router-link-active router-link-exact-active toc-link level3">扩大时间轮</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#多级时间轮" class="router-link-active router-link-exact-active toc-link level3">多级时间轮</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#延迟加载" class="router-link-active router-link-exact-active toc-link level3">延迟加载</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#commitlog保存超长延迟的数据" class="router-link-active router-link-exact-active toc-link level3">CommitLog保存超长延迟的数据</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/MyNotes/interview/MQ/Kafka.html#bouns" class="router-link-active router-link-exact-active toc-link level3">BOUNS</a></li><!----><!--]--></ul><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h1 id="kafka" tabindex="-1"><a class="header-anchor" href="#kafka" aria-hidden="true">#</a> Kafka</h1><p>[toc]</p><h2 id="kafka架构" tabindex="-1"><a class="header-anchor" href="#kafka架构" aria-hidden="true">#</a> Kafka架构</h2><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/image-20240307064422329.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>​ Apache Kafka 采取了分区日志模型，是一种分布式数据存储。经过优化以实时提取和处理流数据。流数据是指由数千个数据源持续生成的数据，通常可同时发送数据记录。流平台需要处理这些持续流入的数据，按照顺序逐步处理。</p><p>Kafka 为其用户提供三项主要功能:</p><ul><li><p>发布和订阅记录流</p></li><li><p>按照记录的生成顺序高效地存储记录流</p></li><li><p>实时处理记录流。</p></li></ul><p>kafka的关键概念如下：</p><ul><li>Broker</li></ul><p>​ Broker 是 kafka 实例，每个服务器上有一个或多个 kafka 的实例。每个 kafka 集群内的 broker 都有一个不重复的编号，如图中的 broker-0、broker-1等。</p><ul><li>Topic</li></ul><p>​ 消息的主题，可以理解为消息的分类，kafka 的数据就保存在 topic。在每个 broker 上都可以创建多个 topic。</p><ul><li>Partition</li></ul><p>​ 一个 Topic 可以认为是一类信息，逻辑上的队列，每条消息都要指定 Topic。为了使得 Kafka 的吞吐量可以线性提高，物理上将 Topic 分成一个或多个 Partition。每个 Partition 在存储层面时 append log 文件，消息 push 进来后，会被追加到 log 文件的尾部，每条消息在文件中的位置成为 offset (偏移量)，offset 是一个 long 型数字，唯一的标识一条信息。因为每条消息都追加到 Partition 的尾部，所以属于磁盘的顺序写，效率很高。如下图：</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/1621492405535-d5eced6e-8e75-4ae0-bd8c-ab7eec2de16c-20230226021712285.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><blockquote><p>​ Topic 中的多个 Partition 以文件夹的形式保存到 Broker，每个分区序号从0递增，且消息有序。Partition 文件下有多个Segment（xxx.index，xxx.log），Segment文件里的大小和配置文件大小一致。默认为1GB，但可以根据实际需要修改。如果大小大于1GB时，会滚动一个新的Segment并且以上一个Segment最后一条消息的偏移量命名。</p></blockquote><ul><li>Replication</li></ul><p>​ 每一个分区(partition)都有多个副本，副本的作用是做备份。当主分区（Leader）故障的时候会选择一个备份（Follower）上位，成为 Leader。在 kafka 中默认副本的最大数量是 10 个，且副本的数量不能大于 Broker 的数量，follower 和 leader 绝对是在不同的机器，同一机器对同一个分区也只可能存放一个副本（包括自己）。 生产使用3副本，至少2个<code>ISR</code>成功才认为成功，禁止<code>unclean</code>。</p><blockquote><p>​ Kafka 中的 Partition 是有序消息日志，为了实现高可用性，需要采用备份机制，将相同的数据复制到多个Broker上，而这些备份日志就是 Replica，目的是为了 <strong>防止数据丢失</strong>。所有Partition的副本默认情况下都会均匀地分布到所有 Broker 上，一旦领导者副本所在的Broker宕机，Kafka会从追随者副本中选举出新的领导者继续提供服务。</p><p><strong>Leader：</strong> 副本中的领导者。负责对外提供服务，与客户端进行交互。生产者总是向Leader副本发消息，消费者总是从 Leader 读消息(因为parition只能被一个消费者消费，所以<strong>消费者只与partition所在的broker交互</strong>)。</p><p><strong>Follower：</strong> 副本中的追随者。被动地追随 Leader，不能与外界进行交付。只是向Leader发送消息，请求Leader把最新生产的消息发给它，进而保持同步。</p></blockquote><ul><li>Consumer Group</li></ul><p>​ 我们可以将多个消费组组成一个消费者组，在 kafka 的设计中同一个分区的数据只能被消费者组中的某一个消费者消费。同一个消费者组的消费者可以消费同一个 topic 的不同分区的数据，这也是为了提高 kafka 的吞吐量。</p><ul><li>Controller</li></ul><p>Kafka 集群中的其中一个服务器，用来进行Leader election以及各种 Failover 操作。</p><ul><li>Zookeeper：</li></ul><p>Kafka 通过Zookeeper来存储集群中的 meta 消息。</p><hr><h2 id="设计理念" tabindex="-1"><a class="header-anchor" href="#设计理念" aria-hidden="true">#</a> 设计理念</h2><h3 id="持久化" tabindex="-1"><a class="header-anchor" href="#持久化" aria-hidden="true">#</a> 持久化</h3><ol><li>尽量线性的读写磁盘。一个硬盘的顺序读写速度一般是4k读写的千倍以上，比随机写入内存的速度还快。线性的读写是可以被预测，也能被操作系统大幅的优化的。</li><li>以<code>pagecache</code>为中心的设计风格，使用文件系统并依赖于pagecache要优于维护内存中缓存或其他结构。一方面避免 JVM 中的 gc带来的性能损耗。同时简化了代码实现。常规的文件操作为了提高读写性能，使用了 Page Cache 机制，但是由于页缓存处在内核空间中，不能被用户进程直接寻址，所以读文件时还需要通过系统调用，将页缓存中的数据再次拷贝到用户空间中。而采用 mmap 后，它将磁盘文件与进程虚拟地址做了映射，并不会招致系统调用，以及额外的内存 copy 开销，从而提高了文件读取效率。<strong>只有索引文件的读写才用到了mmap</strong>。</li></ol><blockquote><ul><li>为什么读写log文件不用呢？</li></ul><p>mmap 有多少字节可以映射到内存中与地址空间有关，JAVA限制为<code>Integer.MAX_VALUE</code>字节，约<code>2GB</code>。Kafka 日志通常足够大，可能一次只能映射部分，因此读取它们将变得非常复杂。然而，索引文件是稀疏的，它们相对较小。将它们映射到内存中可以加快查找过程，这是内存映射文件提供的主要好处。</p><ul><li>为什么不直接使用<code>sendfile</code>呢</li></ul><p>因为 sendfile <strong>不支持中途对文件做变更</strong>，mmap 支持在写入磁盘之前，直接在 page Cache 中修改文件。</p></blockquote><ol start="3"><li><p>持久化队列，只需要简单的在文件后面追加写入即可。而不用考虑建立一个索引文件（BTree）。查询和写入的复杂度由 BTree的 O(logN) 减小为线性的 O(1)。大幅提升数据的吞吐量，有利于处理海量数据，且对存储系统的性能要求不高，降低成本。</p></li><li><p>考虑将多条消息聚合在一次。减少平均每条消息的开销。</p></li><li><p>使用<code>零拷贝</code>减少字符拷贝时候的开销。</p></li></ol><blockquote><p>保存消息时使用<code>mmap</code>，消费者拉取消息时使用<code>sendfile</code></p></blockquote><ol start="6"><li>开启压缩协议，减少数据所占的空间。</li></ol><h3 id="生产者-producer" tabindex="-1"><a class="header-anchor" href="#生产者-producer" aria-hidden="true">#</a> 生产者 （Producer）</h3><ol><li>Producer 向 Leader Partition 发送消息。</li><li>Producer 可以向任何一个 Partition 询问整个集群的状态，以及谁是 Leader Partition</li><li>Producer 自己决定写入到哪个 Partition。Producer 可以考虑使用何种负载的策略。随机，轮询，按照key分区都可以。</li><li>支持批量操作。消息攒够一定数量再发送，使用适当的延迟换来更高的数据吞吐量。</li></ol><h3 id="消费者-consumer" tabindex="-1"><a class="header-anchor" href="#消费者-consumer" aria-hidden="true">#</a> 消费者 （Consumer）</h3><ol><li>消费者直接向 Leader Partition发送一个 fetch 的请求，并制定消费的起始位置（offset），取回offset后的一段数据进行处理。</li><li>Consumer 自己决定 Offset，自己决定从什么地方进行消费。</li><li><strong>Push 和 Pull</strong> 的问题。 消息到底是推还是拉？ kafka 采取的机制是，Producer 向 Broker push 消息。 Consumer 向 Broker Pull 消息。这样做有几个好处。第一，消息消费的速率由 Consumer自己决定。第二，可以聚合的数据批量处理数据，如果使用 push，Broker需要考虑到底要等到多条数据，还是及时发送，Consumer可以尽可能多的拉取数据，保证消息尽可能及时被消费。</li><li>Topic 被划分为多个有序的分区，<strong>保证每个分区任何时候只会被同一个Group里面的 Consumer消费</strong>，加上使用了<code>pull</code>模型，保证了<code>分区有序</code>。只需要记录消费的偏移量。同时这个位置可以作为CheckPoint，定时检查。保证ACK的代价很小。</li></ol><hr><h3 id="kafka-replicas是怎么管理的" tabindex="-1"><a class="header-anchor" href="#kafka-replicas是怎么管理的" aria-hidden="true">#</a> Kafka Replicas是怎么管理的？</h3><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/8db0f8fa-f51f-44dd-b70e-d894400006d0.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>AR:分区中的<strong>所有 Replica 统称为 AR</strong></li><li>ISR:所有与 Leader 副本<strong>保持一定程度同步</strong>的Replica(包括 Leader 副本在内)组成 ISR</li><li>OSR:与 Leader 副本<strong>同步滞后过多的</strong> Replica 组成了 OSR</li></ul><p>​ Leader 负责维护和跟踪 ISR 集合中所有 Follower 副本的滞后状态，当 Follower 副本落后过多时，就会将其放入 OSR 集合，当 Follower 副本追上了 Leader 的进度时，就会将其放入 ISR 集合。</p><p>默认情况下，只有 <strong>ISR 中的副本才有资格晋升为 Leader</strong>。</p><h3 id="如何确定当前能读到哪一条消息" tabindex="-1"><a class="header-anchor" href="#如何确定当前能读到哪一条消息" aria-hidden="true">#</a> 如何确定当前能读到哪一条消息？</h3><blockquote><p>这个问题要先了解上一个问题的概念</p></blockquote><p>分区相当于一个日志文件，我们先简单介绍几个概念</p><figure><img src="https://files.mdnice.com/pic/f38ffbe8-6eb7-4241-aa80-3d186717cdf2.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如下图是一个分区日志文件</p><ul><li>标识<strong>共有7条消息</strong>，offset (消息偏移量)分别是0~6</li><li>0 代表这个日志文件的<strong>开始</strong></li><li>HW(High Watermark) 为4，0~3 代表这个日志文件<strong>可以消费的区间</strong>，消费者只能消费到这四条消息</li><li>LEO 代表即将要写入消息的偏移量 offset</li></ul><p><strong>分区 ISR 集合中的每个副本都会维护自己的 LEO，而 ISR 集合中最小的LEO 即为分区的 HW</strong></p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/38c2f8ee-9fc6-4386-83a7-6e676d7d256a.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如上图: 三个分区副本都是 ISR集合当中的，最小的 LEO 为 3，就代表分区的 HW 为3，所以当前分区只能消费到 0~2 之间的三条数据，如下图</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/6c20a791-3435-4080-b568-885467f9887b.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="发送消息的分区策略有哪些" tabindex="-1"><a class="header-anchor" href="#发送消息的分区策略有哪些" aria-hidden="true">#</a> 发送消息的分区策略有哪些？</h3><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/14fdebd5-64d6-489f-85e1-67584e1ea259.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>1.轮询：<strong>依次</strong>将消息发送该topic下的所有分区，如果在创建消息的时候 key 为 null，Kafka 默认采用这种策略。</li><li>2.key 指定分区：在创建消息是 key 不为空，并且使用默认分区器，Kafka 会将 key 进行 hash，然后<strong>根据hash值映射到指定的分区上</strong>。这样的好处是 key 相同的消息会在一个分区下，Kafka 并不能保证全局有序，但是在每个分区下的消息是有序的，按照顺序存储，按照顺序消费。在保证同一个 key 的消息是有序的，这样基本能满足消息的顺序性的需求。但是<strong>如果 partation 数量发生变化，那就很难保证 key 与分区之间的映射关系了</strong>。</li><li>3.自定义策略：实现 Partitioner 接口就能自定义分区策略。</li><li>4.指定 Partiton 发送</li></ul><h2 id="partition文件存储" tabindex="-1"><a class="header-anchor" href="#partition文件存储" aria-hidden="true">#</a> partition文件存储</h2><p>​ 在Kafka文件存储中，同一个topic下有多个不同partition，每个partition为一个目录，partiton命名规则为topic名称+有序序号，第一个partiton序号从0开始，序号最大值为partitions数量减1。</p><ul><li>每个partion(目录)相当于一个巨型文件被平均分配到多个大小相等segment(段)数据文件中。但每个段segment file消息数量不一定相等，这种特性方便old segment file快速被删除。</li><li>每个partiton只需要支持顺序读写就行了，segment文件生命周期由服务端配置参数决定。</li></ul><p>这样做的好处就是能快速删除无用文件，有效提高磁盘利用率。</p><ul><li>segment file组成：由2大部分组成，分别为index file和data file，此2个文件一一对应，成对出现，后缀”.index”和“.log”分别表示为segment索引文件、数据文件.</li><li>segment文件命名规则：partion全局的第一个segment从0开始，后续每个segment文件名为上一个segment文件最后一条消息的offset值。数值最大为64位long大小，19位数字字符长度，没有数字用0填充。</li></ul><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/image-20230226165740785.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/image-20230226165858062.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>​ 索引文件存储大量元数据，数据文件存储大量消息，索引文件中元数据指向对应数据文件中message的物理偏移地址。 其中以索引文件中元数据3,497为例，依次在数据文件中表示第3个message(在全局partiton表示第368772个message)、以及该消息的物理偏移地址为497。</p><p>​ 索引文件使用稀疏索引，<strong>减少索引文件大小，通过mmap可以直接内存操作</strong>，稀疏索引为数据文件的每个对应message设置一个元数据指针,它比稠密索引节省了更多的存储空间，但查找起来需要消耗更多的时间。</p><blockquote><p>​ 采用 “稀疏索引”，可以认为是在磁盘空间、内存空间、查找性能等多方面的一个折中。有了稀疏索引，当给定一个 offset 时，Kafka 采用的是二分查找来高效定位不大于 offset 的物理位移，然后找到目标消息。</p></blockquote><p>​ 以寻找368776为例，先在跳表中二分查找找到索引文件00000000000000368769.index，计算出相对偏移量为7，则读取到<code>floor</code>，即6,1407，然后从00000000000000368769.log的1407偏移量开始按顺序查找offset为368776。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/image-20230226170711673.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><blockquote><p>Kafka中当有新的索引文件建立的时候ConcurrentSkipListMap(跳表)才会更新，而不是每次有数据写入时就会更新，这里的维护量基本可以忽略。</p></blockquote><ul><li>为什么不使用<code>mmap</code>读取log文件</li></ul><blockquote><p>​ mmap 有多少字节可以映射到内存中与地址空间有关，32 位的体系结构只能处理 4GB 甚至更小的文件。Kafka 日志通常足够大，可能一次只能映射部分，因此读取它们将变得非常复杂。然而，索引文件是稀疏的，它们相对较小。将它们映射到内存中可以加快查找过程，这是内存映射文件提供的主要好处。</p></blockquote><h3 id="拓展-timeindex" tabindex="-1"><a class="header-anchor" href="#拓展-timeindex" aria-hidden="true">#</a> 拓展-timeindex</h3><p>存储时间戳-偏移量。使用时间戳查询时，还需要借助index文件，最终定位log文件。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/905646-20220927134018768-473464527.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="拓展-冷热分离" tabindex="-1"><a class="header-anchor" href="#拓展-冷热分离" aria-hidden="true">#</a> 拓展-冷热分离</h3><p>​ Linux使用了页缓存（Page Cache）来实现内存映射，并且一般使用LRU（Least Recently Used）机制来管理页缓存。索引写入时使用了Page Cahce，那么当 Kafka 查询索引时，就很可能出现<strong>缺页中断（Page Fault）问题</strong>。所谓Page Fault，就是说Kafka 线程会被阻塞，等待对应的索引项从磁盘读出并放入到页缓存中，这种加载过程可能长达 1 秒。</p><p>​ Kafka对二分查找算法进行了改进，采用了<strong>缓存友好的搜索算法</strong>。总体的思路是：将所有索引项分成两个部分：<strong>热区（Warm Area）<strong>和</strong>冷区（Cold Area）</strong>，由于大部分查询集中在索引项尾部，那么把尾部的<em>8192字节</em>设置为热区，永远保存在缓存中，然后分别在这两个区域内执行二分查找算法，如下图所示：</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/20210617232400500.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这个改进版算法的<strong>最大好处</strong>在于：<strong>查询最热那部分数据所遍历的 Page 永远是固定的，因此大概率在页缓存中</strong></p><hr><h2 id="时间轮" tabindex="-1"><a class="header-anchor" href="#时间轮" aria-hidden="true">#</a> 时间轮</h2><p>Timer Wheel 时间轮算法，是一种实现延迟队列的巧妙且高效的算法，被应用在 Netty，Zookeeper，Kafka 等各种框架中。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/timer-wheel.jpg" alt="Timer Wheel" tabindex="0" loading="lazy"><figcaption>Timer Wheel</figcaption></figure><p>​ 如上图所示，时间轮是一个存储延迟消息的循环队列，其底层一般采用数组实现，可以高效循环遍历。这个循环队列中的每个元素对应一个桶（Bucket），桶中存放任务列表，这个列表一般是一个双向环形链表，链表中每一项都代表一个需要执行的延迟任务。双向链表的优点是，如果我们可以访问列表中的链接单元，它允许 O(1) 插入/删除列表项，比优先队列的 O(logN) 要快很多。</p><p>​ 时间轮会有表盘指针，表示时间轮当前所指时间，随着时间推移，该指针会不断前进，并处理对应位置上的延迟任务列表。表盘有自己的刻度数，每个刻度数代表一定的过期时间，对于超出表盘时间的延迟任务，有两种实现方案，一种是像 Netty 的 <code>HashedWheelTimer</code> 在每个延迟任务中维护自己轮次，一种是像 Kafka <code>TimingWheel</code> 将表盘分层，就像我们手表的时分秒一样。</p><p>​ Kafka 有一个被称为“请求炼狱（<code>request purgatory</code>）”的数据结构，炼狱会保留任何尚未满足其完成条件但也没出现错误的请求。</p><h3 id="应用场景" tabindex="-1"><a class="header-anchor" href="#应用场景" aria-hidden="true">#</a> 应用场景</h3><p>​ Kafka 在拉请求中有参数，可以使得消费者请求在 “<strong>长轮询”</strong> 中阻塞等待。简单的说就是消费者去 Broker 拉消息，定义了一个超时时间，也就是说消费者去请求消息，如果有的话马上返回消息，如果没有的话消费者等着直到超时，然后再次发起拉消息请求。并且 Broker 也得配合，如果消费者请求过来，有消息肯定马上返回，没有消息那就建立一个延迟操作，等条件满足了再返回。</p><h4 id="消费端" tabindex="-1"><a class="header-anchor" href="#消费端" aria-hidden="true">#</a> 消费端</h4><p>最后<strong>调用的就是 Kafka 包装过的 selector，而最终会调用 Java nio 的 select(timeout)</strong>。</p><h4 id="broker" tabindex="-1"><a class="header-anchor" href="#broker" aria-hidden="true">#</a> broker</h4><p>判断是否过期就是由时间轮来推动判断的，但是总不能等过期的时候再去看消息到了没吧？kafka也会在消息写入的时候提醒这些延迟请求消息来了。如图：</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/image-20230226205649651.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h3 id="分层时间轮" tabindex="-1"><a class="header-anchor" href="#分层时间轮" aria-hidden="true">#</a> 分层时间轮</h3><p>​ 一个简单的时间轮是存放着定时任务桶的循环队列。我们把 <code>u</code> 称为时间单位。一个大小为 <code>n</code> 的时间轮有 <code>n</code> 个桶，可以在 <code>n * u</code> 时间间隔内保存任务。每个桶都保存了属于相应时间范围内的定时任务。一开始，第一个桶保存 <code>[0, u)</code> 的任务，第二个桶保存 <code>[u, 2u)</code>, … 的任务，第 <code>n</code> 个桶保存 <code>[u * (n -1), u * n)]</code>。每过时间单位 <code>u</code> 的间隔，指针走了一格并移动到下一个存储桶，之前桶中的所有定时器任务到期，定时器立即运行过期的任务，清空的桶可用于下一轮倒计时。由于指针移动到新的用于倒计时开始的桶，因此，新的任务只会从该桶开始倒计时。所以如果当前桶的时间为 <code>t</code>，指针移动之后，它变成了 <code>[t + u * n, t + (n + 1) * u)</code> 的桶。时间轮的插入/删除（启动定时器/停止定时器）成本为 O(1)，而基于优先级队列的定时器，例如 <code>java.util.concurrent.DelayQueue</code> 和 <code>java.util.Timer</code>，插入/删除成本为 O(logN)。请注意，<code>DelayQueue</code> 或 <code>Timer</code> 都不支持随机删除。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/timing-wheels.png" alt="Hierarchical timing wheels" tabindex="0" loading="lazy"><figcaption>Hierarchical timing wheels</figcaption></figure><p>​ 简单时间轮的一个主要缺点是它假设定时器的请求距离在当前时间 <code>n * u</code> 的时间间隔内。如果定时器请求超出此间隔，则为溢出，Netty 的单层时间轮是在每个定时任务中维护了轮次。分层时间轮用于处理此类溢出。它是一个分层组织的时间轮，将溢出委托给上层轮。最低级别具有最好的时间精度。当我们向上移动层次结构时，时间精度将变大。如果一个轮子在一级的精度是 u，刻度数是 n，那么在第二级的精度应该是 n*u，第三级 n2 * u，以此类推。在每一层，溢出都委托给更高一层的轮子。当较高级别的轮子 tick 推进时，它会将定时器任务重新插入较低级别。可以按需创建移出的轮层级数。当上层桶中的桶到期时，其中的所有任务都会递归地重新插入定时器。然后将任务移至更细粒度的轮子或者被执行。插入（start-timer）成本是 O(m)，其中 m 是轮盘的数量，与系统中的请求数量相比通常非常小，删除（stop-timer）成本仍然是 O(1)。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/timing-wheels-2.png" alt="Doubly linked list for buckets in timing wheels" tabindex="0" loading="lazy"><figcaption>Doubly linked list for buckets in timing wheels</figcaption></figure><h4 id="时间轮中桶的双向链表" tabindex="-1"><a class="header-anchor" href="#时间轮中桶的双向链表" aria-hidden="true">#</a> 时间轮中桶的双向链表</h4><p>​ 在新设计中，我们对时间轮中的桶使用自己的双向链表实现。双向链表的优点是，如果我们可以访问列表中的链接单元，它允许 O(1) 插入/删除列表项。</p><p>​ 当排队到定时器队列时，定时器任务实例在其自身中保存链接单元。当任务完成或取消时，将使用保存在任务本身中的链接单元更新列表。</p><h4 id="使用-delayqueue-驱动时钟" tabindex="-1"><a class="header-anchor" href="#使用-delayqueue-驱动时钟" aria-hidden="true">#</a> 使用 DelayQueue 驱动时钟</h4><p>​ 一个简单的实现可以使用一个线程，它每单位时间唤醒一次并进行 tick 推进，并检查桶中是否有任何任务。炼狱单位时间为 1ms（u=1ms）。如果请求在最低级别的轮盘上比较稀疏，这可能是浪费的。这通常是因为大多数请求在插入到最低级别的轮盘之前在上层轮盘找到合适的位置。如果一个线程只在有一个非空的桶要到期时才唤醒，那就太好了。新的炼狱与旧实现类似，通过使用 <code>java.util.concurrent.DelayQueue</code> 来实现，但我们将<strong>非空任务桶</strong>而不是单个任务排入队列。这种设计具有性能优势。<code>DelayQueue</code> 中的项目数量受桶数量的限制，非空桶的数量通常远小于任务的数量，因此 DelayQueue 内部优先级队列的 offer/poll 操作次数会明显减少。</p><h4 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h4><p>​ Kafka 用了多层次时间轮来实现，并且是按需创建时间轮，采用任务的绝对时间来判断延期，并且对于每个非空槽都会维护一个过期时间，利用 DelayQueue 来对每个非空槽的过期时间排序，来进行时间的推进，防止空推进的存在。</p><hr><h2 id="避免reblance" tabindex="-1"><a class="header-anchor" href="#避免reblance" aria-hidden="true">#</a> 避免reblance</h2><p>rebalance发生的时机有：</p><ul><li>组成员数量发生变化</li><li>订阅主题数量发生变化</li><li>订阅主题的分区数发生变化</li></ul><p>发生rebalance最常见的原因是消费组成员的变化。如果是正常扩容，那么是正常的，但是如果被错误的踢出组，则是需要避免的，如上线时，重启服务导致的。</p><p><a href="http://xn--heartbeat-zc3rr95cglph53b2qu3g6bmnhip9aba251a.interval.ms" target="_blank" rel="noopener noreferrer">正确设置心跳间隔时间heartbeat.interval.ms<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>，<a href="http://xn--session-lo5k421oa1382ex44aula01rmz0b.timeout.ms" target="_blank" rel="noopener noreferrer">设置会话超时时间session.timeout.ms<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>。如果是消费速度较慢，可以调小每次拉取的消息个数，调长拉取的间隔时间。</p><hr><h2 id="选举" tabindex="-1"><a class="header-anchor" href="#选举" aria-hidden="true">#</a> 选举</h2><h3 id="常见选主机制的缺点" tabindex="-1"><a class="header-anchor" href="#常见选主机制的缺点" aria-hidden="true">#</a> 常见选主机制的缺点</h3><ul><li><p>split-brain (脑裂):</p><p>这是由ZooKeeper的特性引起的，虽然ZooKeeper能保证所有Watch按顺序触发，但是网络延迟，并不能保证同一时刻所有Replica“看”到的状态是一样的，这就可能造成不同Replica的响应不一致，可能选出多个领导“大脑”，导致“脑裂”。</p></li><li><p>herd effect (羊群效应):</p><p>如果宕机的那个Broker上的Partition比较多， 会造成多个Watch被触发，造成集群内大量的调整，导致大量网络阻塞。</p></li><li><p>ZooKeeper负载过重:</p><p>每个Replica都要为此在ZooKeeper上注册一个Watch，当集群规模增加到几千个Partition时ZooKeeper负载会过重。</p></li></ul><h3 id="controller选举" tabindex="-1"><a class="header-anchor" href="#controller选举" aria-hidden="true">#</a> controller选举</h3><blockquote><p>​ Kafka中的控制器选举工作依赖于Zookeeper，成功竞选成为控制器的broker会在Zookeeper中创建/controller临时节点。每个broker会对/controller节点添加监听器，以此来监昕此节点的数据变化，当/controller节点发生变更，就会触发新一轮的选举。</p></blockquote><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/image-1650782274948.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="启动时选举" tabindex="-1"><a class="header-anchor" href="#启动时选举" aria-hidden="true">#</a> 启动时选举</h4><p>​ 集群中第一个启动的broker会通过在zookeeper中创建临时节点/controller来让自己成为控制器，其他broker启动时 会去尝试读取/controller节点的brokerid的值，读取到的brokerid的值不为-1知道已经有其他broker节点成功竞选为控制器，就会在zookeeper中创建watch对象，便于它们收到控制器变更的通知。</p><h4 id="leader异常选举" tabindex="-1"><a class="header-anchor" href="#leader异常选举" aria-hidden="true">#</a> leader异常选举</h4><p>​ 如果broker由于网络原因与zookeeper断开连接或者异常退出，那么其他broker通过watch收到控制器变更的通知，就会去尝试创建临时节点/controller，如果有一个broker创建成功，那么其他broker就会收到创建异常通知，也就意味着集群中已经有了控制器，其他broker只需创建watch对象即可。</p><h4 id="follower异常" tabindex="-1"><a class="header-anchor" href="#follower异常" aria-hidden="true">#</a> follower异常</h4><p>​ 如果集群中有一个broker发生异常退出了，那么控制器就会检查这个broker是否有分区的副本leader，如果有那么这个分区就需要一个新的leader，此时控制器就会去遍历其他副本，决定哪一个成为新的leader，同时更新分区的ISR集合。</p><h4 id="broker加入" tabindex="-1"><a class="header-anchor" href="#broker加入" aria-hidden="true">#</a> broker加入</h4><p>如果有一个broker加入集群中，那么控制器就会通过brokerid去判断新加入的broker中是否含有现有分区的副本，如果有，就会从分区副本中去同步数据。</p><h4 id="epoch防止脑裂" tabindex="-1"><a class="header-anchor" href="#epoch防止脑裂" aria-hidden="true">#</a> epoch防止脑裂</h4><p>Kafka通过controller_epoch来保证控制器的唯一性，进而保证相关操作的一致性。</p><ul><li>controller_epoch是一个整型值，存放在Zookeeper的/controller_epoch这个持久节点中；</li><li>controller_epoch值用于记录控制器发生变更的次数，即记录当前的控制器是第几代控制器；</li><li>controller_epoch的初始值为1，当控制器发生变更时，就将该字段值加1。</li></ul><p>每个和控制器交互的请求都会携带controller_epoch字段：</p><ul><li>如果请求的controller_epoch值小于内存中的controller_epoch值，则认为这个请求是向已经过期的控制器发送的请求，那么这个请求会被认定为无效的请求。</li><li>如果请求的controller_epoch值大于内存中的controller_epoch值，那么说明已经有新的控制器当选了。</li></ul><h3 id="分区leader选举" tabindex="-1"><a class="header-anchor" href="#分区leader选举" aria-hidden="true">#</a> 分区leader选举</h3><blockquote><p>controller感知到分区leader所在的broker挂了，controller会从replicas副本列表（同时在ISR列表里）中取出第一个broker作为leader。</p><ul><li>leader副本介绍</li></ul><p>​ leader副本负责维护和跟踪ISR集合中所有follower副本的滞后状态，当follower副本落后太多或失效时，leader副本会把它从ISR集合中剔除。当OSR集合中有follower副本“追上”了leader副本，那么leader副本会把它从OSR集合转移至ISR集合。默认情况下，当leader副本发生故障时，只有在ISR集合中的副本才有资格被选举为新的leader。</p><p>由 controller 执行：</p><ul><li>从Zookeeper中读取当前分区的所有ISR(in-sync replicas)集合</li><li>调用配置的分区选择算法选择分区的leader</li></ul><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/4ad00dbf-f680-4d0c-9679-849e0b7a734c.png" alt="分区选择算法" tabindex="0" loading="lazy"><figcaption>分区选择算法</figcaption></figure><p>上面五种分区算法都是选择PreferredReplica(优先副本选举)作为当前Partition的leader。区别仅仅是选择leader之后的操作有所不同。</p></blockquote><h3 id="消费组leader选举" tabindex="-1"><a class="header-anchor" href="#消费组leader选举" aria-hidden="true">#</a> 消费组leader选举</h3><blockquote><p>​ GroupCoordinator需要为消费组内的消费者选举出一个消费组的leader，这个选举的算法很简单，当消费组内还没有leader，那么第一个加入消费组的消费者即为消费组的leader，如果当前leader退出消费组，则会挑选以HashMap结构保存的消费者节点数据中，第一个键值对来作为leader。</p></blockquote><hr><h2 id="kafka为什么快" tabindex="-1"><a class="header-anchor" href="#kafka为什么快" aria-hidden="true">#</a> kafka为什么快</h2><ol><li>I/O多路复用</li></ol><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/3297725.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>1：表示 1 个 Acceptor 线程，负责监听新的连接，然后将新连接交给 Processor 线程处理。</p><p>N：表示 N 个 Processor 线程，每个 Processor 都有自己的 selector，负责从 socket 中读写数据。</p><p>M：表示 M 个 KafkaRequestHandler 业务处理线程，它通过调用 KafkaApis 进行业务处理，然后生成 response，再交由给 Processor 线程。</p><p>Reactor 模式正是采用了很经典的 IO 多路复用技术，它可以复用一个线程去处理大量的 Socket 连接，从而保证高性能。</p><ol start="2"><li>顺序读写</li></ol><p>​ 磁盘的顺序读写是磁盘使用模式中最有规律的，并且操作系统也对这种模式做了大量优化，Kafka就是使用了磁盘顺序读写来提升的性能。Kafka的message是不断追加到本地磁盘文件末尾的，而不是随机的写入，这使得Kafka写入吞吐量得到了显著提升。</p><ol start="3"><li>使用page cache，异步刷盘</li></ol><p>​ 当一个进程准备读取磁盘上的文件内容时，操作系统会先查看待读取的数据所在的页（page）是否在页缓存（pagecache）中，如果存在（命中）则直接返回数据，从而避免了对物理磁盘的 I/O 操作；如果没有命中，则操作系统会向磁盘发起读取请求并将读取的数据页存入页缓存，之后再将数据返回给进程。</p><p>​ Memory Mapped Files(后面简称mmap)也被翻译成内存映射文件，在64位操作系统中一般可以表示20G的数据文件，它的工作原理是直接利用操作系统的Page来实现文件到物理内存的直接映射。完成映射之后你对物理内存的操作会被同步到硬盘上（操作系统在适当的时候）。通过mmap，进程像读写硬盘一样读写内存，使用这种方式可以获取很大的I/O提升，省去了用户空间到内核空间复制的开销。</p><p>​ 此外，即使 Kafka 服务重启，页缓存还是会保持有效，然而进程内的缓存却需要重建。这样也极大地简化了代码逻辑，因为维护页缓存和文件之间的一致性交由操作系统来负责，这样会比进程内维护更加安全有效。</p><p>​ Kafka 中通过mmap大量使用了页缓存，这是 Kafka 实现高吞吐的重要因素之一。消息都是先被写入页缓存，然后由操作系统负责具体的刷盘任务的。</p><ol start="4"><li>文件分段</li></ol><p>​ Kafka的队列topic被分为了多个区partition, 每个partition又分为了多个segment。所以一个队列中的消息实际上是保存在N多个片段文件中，通过分段的方式，每次文件操作都是对一个小文件的操作，非常轻便，同时也增加了并行处理能力</p><ol start="5"><li>零拷贝</li></ol><p>​ Kafka 就是这个应用场景，从磁盘中读取一批消息后原封不动地写入网卡（NIC，Network interface controller）进行发送。在没有任何优化技术使用的背景下，操作系统为此会进行 4 次数据拷贝，以及 4 次上下文切换，如下图所示：</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/NoOptimization.jpg" alt="NoOptimization" tabindex="0" loading="lazy"><figcaption>NoOptimization</figcaption></figure><p>4 次 copy：</p><ul><li>物理设备 &lt;-&gt; 内存： <ul><li>CPU 负责将数据从磁盘搬运到内核空间的 Page Cache 中；</li><li>CPU 负责将数据从内核空间的 Socket 缓冲区搬运到的网络中；</li></ul></li><li>内存内部拷贝： <ul><li>CPU 负责将数据从内核空间的 Page Cache 搬运到用户空间的缓冲区；</li><li>CPU 负责将数据从用户空间的缓冲区搬运到内核空间的 Socket 缓冲区中；</li></ul></li></ul><p>4 次上下文切换：</p><ul><li>read 系统调用时：用户态切换到内核态；</li><li>read 系统调用完毕：内核态切换回用户态；</li><li>write 系统调用时：用户态切换到内核态；</li><li>write 系统调用完毕：内核态切换回用户态；</li></ul><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/image-20230226202930570.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>sendfile 主要使用到了两个技术：</p><ol><li>DMA 技术。</li></ol><p>sendfile 依赖于 DMA 技术，将四次 CPU 全程负责的拷贝与四次上下文切换减少到两次，如下图所示：</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/image-20230226203029556.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>DMA 负责磁盘到内核空间中的 Page cache（read buffer）的数据拷贝以及从内核空间中的 socket buffer 到网卡的数据拷贝。</p><ol start="2"><li>传递文件描述符代替数据拷贝。</li></ol><p>传递文件描述可以代替数据拷贝，这是由于两个原因：</p><ul><li>page cache 以及 socket buffer 都在内核空间中。</li><li>数据在传输中没有被更新。</li></ul><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/image-20230226203102425.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>最终效果：</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/sendfile-20230226203435999.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="6"><li>数据压缩</li></ol><p>Kafka还支持消息压缩，Producer可以通过GZIP或者Snappy格式对消息集合进行压缩，从而减少网络传输的压力。</p><ol start="7"><li>使用批次</li></ol><p>在向Kafka写入数据时，可以启用批次写入，这样可以避免在网络上频繁传输单个消息带来的延迟和带宽开销。</p><blockquote><p>Java send file api 是 transferTo 方法和 transferFrom 方法。</p><p>注意：<strong>send file 是一个从磁盘到网卡驱动的 IO 优化</strong>。反过来，网卡到磁盘，是没有这个 IO 优化的。也就是说 transferFrom 方法并没有这种福利。</p><p><code>send file</code>: <code>FileChannel.transforTo</code></p><p><code>mmap</code>: <code>MappedByteBuffer</code></p><p>堆外内存：<code>ByteBuffer</code></p><p>消费消息，会用到sendFile。保存消息，会使用堆外内存与mmap，网卡(ByteBuffer) -&gt; mmap(MappedByteBuffer)</p></blockquote><hr><h2 id="kafka实现延迟队列" tabindex="-1"><a class="header-anchor" href="#kafka实现延迟队列" aria-hidden="true">#</a> kafka实现延迟队列</h2><p>​ 无论定时消息还是延迟消息，最终都是投递后延迟一段时间对用户可见。假设这个延迟时间为X秒，那么<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mspace></mspace><mspace width="0.6667em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mo stretchy="false">(</mo><mi>t</mi><mi>i</mi><mi>c</mi><mi>k</mi><mi>s</mi><mi>P</mi><mi>e</mi><mi>r</mi><mi>W</mi><mi>h</mi><mi>e</mi><mi>e</mi><mi>l</mi><mo>×</mo><mi>t</mi><mi>i</mi><mi>c</mi><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X\mod (ticksPerWheel \times tick)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord mathnormal">Wh</span><span class="mord mathnormal">ee</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>可以计算出X所属的TimeWheel中位置。这里存在一个问题，TimeWheel的size为8，那么延迟1秒和9秒的消息都处在一个链表中。如果用户先发了延迟9秒的消息再发了延迟1秒的消息，他们在一个链表中所以延迟1秒的消息会需要等待延迟9秒的消息先投递。显然这是不能接受的，那么如何解决这个问题？</p><h3 id="排序" tabindex="-1"><a class="header-anchor" href="#排序" aria-hidden="true">#</a> 排序</h3><p>显然，如果对TimeWheel一个tick中的元素进行排序显然就解决了上面的问题。但是显而易见的是排序是不可能的。</p><h3 id="扩大时间轮" tabindex="-1"><a class="header-anchor" href="#扩大时间轮" aria-hidden="true">#</a> 扩大时间轮</h3><p>​ 最直观的方式，我们能不能通过扩大时间轮的方式避免延迟9和延迟1落到一个tick位置上？假设支持30天，精度为1秒，那么ticksPerWheel=30 * 24 * 60 * 60，这样每一个tick上的延迟都是一致的，不存在上述的问题（类似于将RocketMQ的Level提升到了30 * 24 * 60 * 60个）。但是TimeWheel需要被加载到内存操作，这显然是无法接受的。</p><h3 id="多级时间轮" tabindex="-1"><a class="header-anchor" href="#多级时间轮" aria-hidden="true">#</a> 多级时间轮</h3><p>单个TimeWheel无法支持，那么能否显示中的时针、分针的形式，构建多级时间轮来解决呢？</p><figure><img src="https://yqfile.alicdn.com/img_4538f81e001ecc10504dab5941aef7b7.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>多级时间轮解决了上述的问题，但是又引入了新的问题：</p><ol><li>在整点（tick指向0的位置）需要加载大量的数据会导致延迟，比如第二个时间轮到整点需要加载未来一天的数据</li><li>时间轮需要载入到内存，这个开销是不可接受的</li></ol><h3 id="延迟加载" tabindex="-1"><a class="header-anchor" href="#延迟加载" aria-hidden="true">#</a> 延迟加载</h3><p>​ 多级定时轮的问题在于需要加载大量数据到内存，那么能否优化一下将这里的数据延迟加载到内存来解决内存开销的问题呢？</p><pre><code>在多级定时轮的方案中，显然对于未来一小时或者未来一天的数据可以不加载到内存，而可以只加载延迟时间临近的消息。
</code></pre><p>进一步优化，可以将数据按照固定延迟间隔划分，那么每次加载的数据量是大致相同的，不会出tick约大的定时轮需要加载越多的数据，那么方案如下：</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/img_02065da87234cb11a15c0d344f14be7d-20230228223921245.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>​ 基于上述的方案，那么TimeWheel中存储未来30分钟需要投递的消息的索引，索引为一个long型，那么数据量为：30 * 60 * 8 * TPS，相对来说内存开销是可以接受的，比如TPS为1w那么大概开销为200M+。之后的数据按照每30分钟一个块的形式写入文件，那么每个整点时的操作就是计算一下将30分钟的消息Hash到对应的TimeWheel上，那么排序问题就解决了。</p><p>到此为止就只剩下一个问题，如何保存30天的数据？</p><h3 id="commitlog保存超长延迟的数据" tabindex="-1"><a class="header-anchor" href="#commitlog保存超长延迟的数据" aria-hidden="true">#</a> CommitLog保存超长延迟的数据</h3><p>​ CommitLog是有时效性的，比如在我们只保存最近7天的消息，过期数据将被删除。对于延迟消息，可能需要30天之后投递，显然是不能被删除的。</p><p>​ 那么我们怎么保存延迟消息呢？</p><p>​ 直观的方法就是将延迟消息从CommitLog中剥离出来，独立存储以保存更长的时间。</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/img_ca24ed107f55426e5a3c06cce013b943-20230228223914605.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>​ 通过DispatchService将WAL中的延迟消息写入到独立的文件中。这些文件按照延迟时间组成一个链表。链表长度为最大延迟时间/每个文件保存的时间长度。那么WAL可以按照正常的策略进行过期删除，Delay Msg File则在一个文件投递完之后进行删除。唯一的问题是这里会有Delay Msg File带来的随机写问题，但是这个对系统整体性能不会有很大影响，在可接受范围内。</p><h3 id="bouns" tabindex="-1"><a class="header-anchor" href="#bouns" aria-hidden="true">#</a> BOUNS</h3><p>结合TimeWheel和CommitLog保存超长延迟数据的方案，加上一些优化手段，基本就完成了支持任意延迟时间的方案：</p><figure><img src="https://raw.githubusercontent.com/nocetfy/image/main/img/img_a7d38b169dc906798bc9a05e02d06d31.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>消息写入WAL</li><li>Dispatcher处理延迟消息 <ul><li>延迟消息一定时间的直接写入TimeWheel</li><li>延迟超过一定时间写入DelayMessageStorage</li></ul></li><li>DelayMessageStorage对DelayMsgFile构建一层索引，这样在映射到TimeWheel时只需要做一次Hash操作</li><li>通过TimeWheel将消息投递到ConsumeQueue中完成对Consumer的可见</li></ul><p>通过这个方案解决了最初提出来的任意延迟消息的两个难点：</p><ol><li>消息的排序问题</li><li>超长延迟消息的存储问题</li></ol><hr></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/nocetfy/edit/main/docs/interview/MQ/Kafka.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><!----><!----></div></footer><nav class="page-nav"><!----><a href="/MyNotes/interview/MQ/RabbitMQ.html" class="nav-link next" aria-label="RabbitMQ"><div class="hint">下一页<span class="arrow right"></span></div><div class="link">RabbitMQ<!----></div></a></nav><!----><!----><!--]--></main><!--]--><!----></div><!--]--><!--]--><!----><!----><!--]--></div>
    <script type="module" src="/MyNotes/assets/app-a0fec2f7.js" defer></script>
    <script src="https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-y/instant.page/5.1.0/instantpage.min.js" type="application/javascript"></script>
  </body>
</html>
